<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="深入 C 语言的过程"/>




  <meta name="keywords" content="C, 毁于随" />










  <link rel="alternate" href="/atom.xml" title="毁于随">




  <link rel="shortcut icon" type="image/x-icon" href="/icon_ios7.png?v=2.6.0" />



<link rel="canonical" href="http://www.iweeek.com/2018/05/26/c/deep-in-c-proccess/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  


  <script id="google_analytics">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-102765380-1', 'auto');
        ga('send', 'pageview');
  </script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "2JbLYIPhKt2NzUDtxAz8m4eL-gzGzoHsz",
      appKey: "emG4bvM4WSlRew7VB7p13lxw"
    });
  </script>





    <title> 深入 C 语言的过程 - 毁于随 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">毁于随</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/photos/">
        <li class="mobile-menu-item">
          
          
            相册
          
        </li>
      </a>
    
      <a href="/tags/">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories/">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/resume/index.html">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">毁于随</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/photos/">
            
            
              相册
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/resume/index.html">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main" style="line-height: 180%;">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          深入 C 语言的过程
        
      </h1>
      
      <div class="post-meta">
        <span class="post-author">
           作者: <a href="https://www.iweeek.com/"> 毁于随 </a>
        </span>
        <span class="post-time">
           日期: 2018-05-26
        </span>
        
        
        <div class="post-visits"
             data-url="/2018/05/26/c/deep-in-c-proccess/"
             data-title="深入 C 语言的过程">
            阅读次数
          </div>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、操作数指示符"><span class="toc-text">一、操作数指示符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、压入和弹出栈操作"><span class="toc-text">二、压入和弹出栈操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、函数调用的栈帧结构"><span class="toc-text">三、函数调用的栈帧结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、一个例子"><span class="toc-text">四、一个例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#（1）创建新的栈帧"><span class="toc-text">（1）创建新的栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（2）准备调用函数需要的参数"><span class="toc-text">（2）准备调用函数需要的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（3）调用函数"><span class="toc-text">（3）调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（4）执行控制权交接给被调函数"><span class="toc-text">（4）执行控制权交接给被调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（5）继续调用其他函数"><span class="toc-text">（5）继续调用其他函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数返回过程"><span class="toc-text">函数返回过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、小结"><span class="toc-text">五、小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、参考"><span class="toc-text">六、参考</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>过程是软件中一种很重要的抽象，它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。</p>
<p>假设过程 P 调用过程 Q，Q 执行后返回到 P。那么这些动作包括下面一个或多个机制。</p>
<ul>
<li>传递控制</li>
<li>传递数据</li>
<li>分配和释放内存</li>
</ul>
<a id="more"></a>
<h2 id="一、操作数指示符"><a href="#一、操作数指示符" class="headerlink" title="一、操作数指示符"></a>一、操作数指示符</h2><p>各种不同的操作数可以分为三种类型：</p>
<ul>
<li>立即数（immediate）：例如，$3 或 $0x1F。</li>
<li>寄存器（register）：表示某个寄存器的内容，用符号 ra 表示任意寄存器 a，用引用 R[ra] 表示它的值，这将寄存器集合看成一个数组 R，用寄存器标识符作为索引。</li>
<li>内存引用是第三类操作数：它会根据计算出来的地址（有效地址）访问某个内存位置。</li>
<li>寻址模式：Imm（rb, ri, s）由一个立即数偏移Imm，一个基址寄存器 rb，一个变址寄存器 ri 和一个比例因子 s 组成，这里 s 必须是 1、2、4 或者 8。基址和变址寄存器必须是 64 位寄存器。有效地址被计算为 Imm+R[rb]+R[ri]·s。</li>
</ul>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%BC%E5%BC%8F.png" alt=""></p>
<h2 id="二、压入和弹出栈操作"><a href="#二、压入和弹出栈操作" class="headerlink" title="二、压入和弹出栈操作"></a>二、压入和弹出栈操作</h2><p>在聊压栈和弹栈操作之前，我们有必要先了解一下什么是栈？顺便把堆也一块复习了。</p>
<p><strong>(1) 相同点：</strong></p>
<ol>
<li>栈和堆都是用来从底层操作系统中获取内存的。</li>
<li>在多线程环境下每个线程都可以有他自己完全的独立的栈，但是他们共享堆。并行存取是堆来控制，而不是栈。</li>
</ol>
<p><strong>(2) 不同点：</strong><br>栈：</p>
<ol>
<li>栈是为执行线程留出的内存空间，一般提前分配好了，栈必须是连续的内存块。</li>
<li>栈是一种数据结构，可以添加或者删除值，遵循“后进先出”（LIFO）的原则；从栈中释放块（free block）只不过是指针的偏移而已。</li>
<li>每一个线程都有一个栈，但是每一个应用程序通常只有一个堆。</li>
<li>栈经常与 sp 寄存器（stack pointer）一起工作，最初 sp 指向栈顶（栈的高地址）。</li>
<li>CPU 用 push 指令来讲数据压栈，用 pop 指令来弹栈。当用 push 压栈时，sp 值减少（向低地址扩展）。当用 pop 弹栈时，sp 值增大。存储和获取的都是 CPU 寄存器的值。</li>
<li>当函数被调用时，CPU 使用特定的指令把当前的 IP（instruction pointer，指令地址寄存器，用来记录 CPU 指令的位置）压栈。即执行代码的地址。CPU 接下来把将要调用的函数地址赋给 IP，进行调用。当函数返回时，旧的 IP 被弹栈，CPU 继续去调用之前的代码。</li>
</ol>
<p>堆：</p>
<ol>
<li>堆是动态分配预留的内存空间。堆包含一个链表来维护已用和空闲的内存块。在堆上新分配（用 new 或者 malloc）内存是从空闲的内存块中找到一些满足要求的合适块。这个操作会更新堆中的块链表，元信息被存储在每个块头部的区域。</li>
<li>堆通常从低地址向高地址扩展。如果申请的堆内存很小，操作系统可能给它分配的内存为最小的堆内存单元（比申请的大）。</li>
<li>申请和释放许多小的块会产生“堆碎片”，导致申请大块内存失败。</li>
<li>当空闲块旁边的已用块释放时，新的空闲块可能会与相邻的空闲块合并为一个大的空闲块，这样可以减少“堆碎片”的产生。</li>
</ol>
<p>push 和 pop 是汇编中压栈和出栈的指令。这里引用一张图来说明：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E.png" alt=""></p>
<p>当 <code>%rsp</code> 为 <code>0x108</code>，<code>%rax</code> 为 <code>0x123</code> 时</p>
<ul>
<li><p>pushq %rax：做了两件事</p>
<ul>
<li>subq $8, %rsp：内存地址 <code>0x108</code> 向下扩展到 <code>0x100</code>。</li>
<li>movq %rax, (%rsp)：然后将 <code>0x123</code> 存放到内存地址 <code>0x100</code> 处。</li>
</ul>
</li>
<li><p>popq %rdx：做了两件事，这是弹出一个四字的操作。</p>
<ul>
<li>movq (%rsp), %rdx：从栈顶位置读出 <code>0x123</code> 赋值给 <code>%rdx</code>。</li>
<li>addq $8, %rsp：然后将栈顶指针加 <code>8</code>，变为原来的 <code>0x108</code>。</li>
</ul>
</li>
</ul>
<p>注：<code>%rax</code> 是直接寻址操作；<code>(%rsp)</code>是间接寻址操作，也就是先取出 <code>%rsp</code> 里的值作为地址，再根据这个地址到内存中找到相应的位置并取出其中的值。</p>
<h2 id="三、函数调用的栈帧结构"><a href="#三、函数调用的栈帧结构" class="headerlink" title="三、函数调用的栈帧结构"></a>三、函数调用的栈帧结构</h2><p>其实，从某种意义上说，C 语言就是个函数嵌套语言，从一个主函数开始，内部生出几个子函数，每个子函数下面又有更多的子函数，有时候父子函数之间还会出现递归嵌套调用，再加上循环和条件判断，如此复杂的操作，编辑器是怎么翻译成汇编来实现的呢？这依赖于简单实用的栈帧结构，引用《深入理解计算机系统》中的一张图：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E9%80%9A%E7%94%A8%E7%9A%84%E5%B8%A7%E6%A0%88%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>我们先不看栈里面具体的内容，我们带着几个问题去研究栈帧结构，系统中这么多的函数调用，无论函数嵌套有多复杂，肯定有个先后关系。那么这么多的栈，就是根据调用的先后排列顺序入栈，先调用的函数，其栈帧结构就整体先入栈，后调用的函数就后入栈，<strong>栈顶所代表的就是当前栈，就是当前正在调用的函数</strong>。</p>
<p>栈帧结构最难理解的就是那句 “<code>被保存的%rbp</code>”。这句话难的背后，是对 rbp 在栈帧中的作用的理解，可以这么说，只有把 %rbp 理解了，才能真正理解栈帧结构。那么 %rbp 是什么呢？<strong>%rbp 被称为基址指针寄存器（base pointer）或者帧指针（frame pointer），它保存着当前栈帧的基地址</strong>。图中函数 Q 的第一个地址——被保存的%rbp，我们要注意它（在栈中的值）这里保存的可不是函数 Q 的基地址，而是它的调用者函数 P 的基地址。这里大家可能会奇怪，为什么是函数 P 的基地址呢？后文我会讲到这个，这里大家先知道栈中的「被保存的%rbp」保存的是调用者的栈帧首地址。</p>
<p>首先看右侧以帧划分的三个部分，函数 P 要调用函数 Q，较早的帧调用函数 P，可以看出，<strong>函数的调用地址的方向从高地址向低地址扩展的</strong>。</p>
<p>我们接着来看看调用函数 P 的参数部分，参数7…参数n，为什么是从参数 7 开始呢？其实，C 语言的过程 P 调用 Q，通过寄存器，<strong>P 最多可以传送 6 个整数值（指针和整数）给 Q</strong>。假设 Q 需要的参数 n &gt; 6，那么在调用 Q 之前，P 必须在自己的栈帧里为这多出来的参数分配空间，并且分配的帧栈必须能够容纳下 7 到 n 号参数。<strong>参数的压栈顺序是从右向左的</strong>，也就是说参数 7 的地址一定比参数 n 的地址小。</p>
<p>设置好调用参数之后，开始执行 call 指令。call 指令做了两件事，</p>
<ul>
<li>第一件事是 <code>pushl %eip</code>，将返回地址（紧跟在 call 指令的下一条指令）压入栈，用于函数返回继续执行。我们把这个返回地址当做 P 的栈帧的一部分，因为它存放的是与 P 相关的状态。这步执行完后，栈指针 %esp 的值会减少一定大小，用来存放返回地址，即 <code>(%esp)</code>。无论如何，%esp 指向的地址总是在栈顶。 </li>
<li>第二件事是 <code>jmp Q</code>，跳转到函数 Q，会改变程序计数器（PC） <code>%eip</code> 寄存器的值，具体为 call 指令后面跟的地址，在这里为 Q 的第一条指令地址。</li>
</ul>
<p>接下来，进入到了函数 Q 的执行过程，首先我们看到汇编代码的最上面有两句：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushl   %ebp 		# 把父调用者的帧首地址 %ebp 入栈</span><br><span class="line">movl    %esp, %ebp  	# 更新 %ebp 为当前 Q 函数的帧首</span><br></pre></td></tr></table></figure>
<p>关键的地方来了，还记到上面提到过的<strong>栈中的「被保存的%rbp」保存的是调用者的栈帧首地址</strong>吧。根据之前复习过的 push 操作的用法：</p>
<ul>
<li>第一句 <code>pushl %ebp</code> 的意思是 %ebp 寄存器的值压入栈中，我们知道到目前为止，%ebp 的值一直是函数 P 的帧首，所以压入栈帧中的值是函数 P 的帧首。这时候 <code>%rbp</code> 指向的依旧是函数 P 的帧首。</li>
<li>第二句 <code>movl %esp, %ebp</code> 的意思是将当前栈指针寄存器 <code>%esp</code> 的地址赋值给帧指针寄存器 <code>%ebp</code>，这时候 %ebp 指向的是函数 Q 的帧首。对于函数 Q 的栈帧来说，此时栈帧顶和栈帧底指向同一位置。</li>
</ul>
<p>整理一下思路，当一个函数调用另一个函数的时候，需要对栈帧信息进行修改和维护，如何在 Q 函数执行完后让 CPU 顺利地找到 P 函数的帧首地址并成功返回呢？这就要在调用 Q 之前做好充分的准备，我们知道，P 函数有自己的帧首，在 P 函数执行的时候，%ebp 就保存了这个帧首的地址值，或者说 %ebp 指向 P 函数的帧首。当调用 Q 函数的时候，%ebp 的值会更新为 Q 的栈帧首地址，为了让 Q 在返回时能够顺利更新 %ebp 的值，使得帧指针顺利指回到 P 函数的帧首，<strong>有必要在 %ebp 指向 Q 函数（被调用函数）帧首之前，更改 Q 函数帧首空间内所保存的值，为 P 函数（调用函数）的帧首地址值，也就是 Q 栈帧中的「被保存的%rbp」的地址值</strong>。这样一来，每一个当前调用的函数都保存着父函数的帧首，函数执行完后都能顺利更新为父函数的帧首，以此类推，一直到 main 函数的帧首。通过 %ebp 的修改和被保存，就能确保栈帧结构的访问顺利进行，是不是很奇妙？</p>
<h2 id="四、一个例子"><a href="#四、一个例子" class="headerlink" title="四、一个例子"></a>四、一个例子</h2><p>下面用一个例子来说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据汇编代码画了一个图，我们先看看完整的栈结构信息图，这里假设进入 main 函数时栈顶 %rsp 的地址是 <code>0x7fffffffd9e8</code></p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B4.png" alt=""></p>
<p>使用 <code>disassemble</code> 命令显示 main 函数汇编指令代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000400513</span> &lt;main&gt;:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">400513</span>:       <span class="number">55</span>                      <span class="keyword">push</span>   %rbp</span><br><span class="line">  <span class="number">400514</span>:       <span class="number">48</span> <span class="number">89</span> e5                <span class="keyword">mov</span>    %rsp,%rbp</span><br><span class="line">    return f(<span class="number">10</span>)+<span class="number">1</span><span class="comment">;</span></span><br><span class="line">  <span class="number">400517</span>:       bf 0a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>xa,%edi</span><br><span class="line">  40051c:       e8 <span class="built_in">db</span> ff ff ff          callq  4004fc &lt;f&gt;</span><br><span class="line">  <span class="number">400521</span>:       <span class="number">83</span> c0 <span class="number">01</span>                <span class="keyword">add</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">&#125;</span><br><span class="line">  <span class="number">400524</span>:       <span class="number">5d</span>                      <span class="keyword">pop</span>    %rbp</span><br><span class="line">  <span class="number">400525</span>:       c3                      retq</span><br></pre></td></tr></table></figure>
<h3 id="（1）创建新的栈帧"><a href="#（1）创建新的栈帧" class="headerlink" title="（1）创建新的栈帧"></a>（1）创建新的栈帧</h3><p>一个函数被调用，首先默认要完成以下动作：</p>
<ul>
<li>建立新的栈帧，将调用函数的帧首地址入栈，即将 bp 寄存器的值压入调用栈中</li>
<li>将被调函数的帧首地址放入 bp 寄存器中</li>
</ul>
<p>以下两条指令即完成上面动作：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">400513</span>:       <span class="number">55</span>                      <span class="keyword">push</span>   %rbp</span><br><span class="line"><span class="number">400514</span>:       <span class="number">48</span> <span class="number">89</span> e5                <span class="keyword">mov</span>    %rsp,%rbp</span><br></pre></td></tr></table></figure>
<p>执行完之后，%rsp 将减少 8，变为 <code>0x7fffffffd9e0</code>；<code>%rbp</code> 将和 <code>%rsp</code> 一样，指向同一个地址。</p>
<p>有人要问了，不是说 main 函数是程序的入口吗，难道还会有其他函数来调 main 函数？是的，皆因 main 并不是程序拉起后第一个被执行的函数，main 函数是被 <code>_start</code> 函数拉起的，更详细的解释参看<a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch19s02.html" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="（2）准备调用函数需要的参数"><a href="#（2）准备调用函数需要的参数" class="headerlink" title="（2）准备调用函数需要的参数"></a>（2）准备调用函数需要的参数</h3><p>言归正传，一个函数调用另一个函数，需先将参数准备好。main 函数调用 f 函数，一个参数传入通用寄存器中：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">400517</span>:       bf 0a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>xa,%edi</span><br></pre></td></tr></table></figure>
<h3 id="（3）调用函数"><a href="#（3）调用函数" class="headerlink" title="（3）调用函数"></a>（3）调用函数</h3><p>万事具备，是时候将执行控制权交给 <code>f</code> 函数了，call 指令完成交接任务：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return f(<span class="number">10</span>)+<span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="number">400517</span>:       bf 0a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>xa,%edi</span><br><span class="line">40051c:       e8 <span class="built_in">db</span> ff ff ff          callq  4004fc &lt;f&gt;</span><br><span class="line"><span class="number">400521</span>:       <span class="number">83</span> c0 <span class="number">01</span>                <span class="keyword">add</span>    <span class="number">$0</span>x1,%eax</span><br></pre></td></tr></table></figure>
<p>先把 0xa 的值存入 %edi 寄存器。然后，一条 call 指令，完成了两个任务：</p>
<ul>
<li>被调函数执行完之后要返回紧跟在 call 的下一条指令继续执行，所以把 call 的下一条指令的地址（称为<code>返回地址</code>） <code>0x400521</code> 入栈，同时 <code>%rsp</code> 的值将减去 <code>8</code>，<code>%rsp</code> 的值现在是 <code>0x7fffffffd9d8</code>，如下调用栈图所示。</li>
<li>jmp f，跳转到函数 <code>f</code>，这将会改变 <code>%rip</code> 的值，变为 <code>0x4004fc</code>，即程序将跳转到该地址继续执行。</li>
</ul>
<p>用 <code>si</code> 命令执行到 call 指令之后，使用 <code>info registers</code> 指令查看寄存器 %rbp 和 %rsp 的值：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info registers <span class="built_in">rbp</span> <span class="built_in">rsp</span><span class="built_in">rbp</span>            <span class="number">0x7fffffffd9e0</span>	<span class="number">0x7fffffffd9e0</span><span class="built_in">rsp</span>            <span class="number">0x7fffffffd9d8</span>	<span class="number">0x7fffffffd9d8</span>(gdb)</span><br></pre></td></tr></table></figure>
<p>调用栈：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B 1.png" alt=""></p>
<h3 id="（4）执行控制权交接给被调函数"><a href="#（4）执行控制权交接给被调函数" class="headerlink" title="（4）执行控制权交接给被调函数"></a>（4）执行控制权交接给被调函数</h3><p>程序进入 f 函数，其汇编指令：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas /rmDump of assembler code for function f:<span class="number">7</span>	&#123;   <span class="number">0x00000000004004fc</span> &lt;+<span class="number">0</span>&gt;:	<span class="number">55</span>		<span class="keyword">push</span>   %rbp   <span class="number">0x00000000004004fd</span> &lt;+<span class="number">1</span>&gt;:	<span class="number">48</span> <span class="number">89</span> e5	<span class="keyword">mov</span>    %rsp,%rbp   <span class="number">0x0000000000400500</span> &lt;+<span class="number">4</span>&gt;:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>	<span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp   <span class="number">0x0000000000400504</span> &lt;+<span class="number">8</span>&gt;:	<span class="number">89</span> <span class="number">7d</span> fc	<span class="keyword">mov</span>    %edi,-<span class="number">0x4</span>(%rbp)<span class="number">8</span>	    return g(x)<span class="comment">;</span>=&gt; <span class="number">0x0000000000400507</span> &lt;+<span class="number">11</span>&gt;:	8b <span class="number">45</span> fc	<span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbp),%eax   <span class="number">0x000000000040050a</span> &lt;+<span class="number">14</span>&gt;:	<span class="number">89</span> c7		<span class="keyword">mov</span>    %eax,%edi   <span class="number">0x000000000040050c</span> &lt;+<span class="number">16</span>&gt;:	e8 dc ff ff ff	callq  <span class="number">0x4004ed</span> &lt;g&gt;<span class="number">9</span>	&#125;   <span class="number">0x0000000000400511</span> &lt;+<span class="number">21</span>&gt;:	c9		leaveq    <span class="number">0x0000000000400512</span> &lt;+<span class="number">22</span>&gt;:	c3		retq   End of assembler dump.(gdb)</span><br></pre></td></tr></table></figure>
<p>前面两条指令跟 main 函数里的一样：<strong>建立 f 函数的栈帧，将 main 函数的帧首地址入栈，更新 <code>%rbp</code> 为 <code>f</code> 函数的帧首地址</strong>。</p>
<p>这时的 <code>%rsp</code> 和 <code>%rbp</code> 均为 <code>0x7fffffffd9d0</code>，栈信息如图：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B2.png" alt=""></p>
<p>接下来两条指令，将 <code>%rsp</code> 减少 <code>8</code>（向下扩展 <code>8</code> 个字节），变为 <code>0x7fffffffd9c8</code>。接着， <code>%edi</code> 寄存器里的值被设置为相对于 %rbp （<code>0x7fffffffd9d0</code>）向下偏移 <code>4</code> 个字节的地址 <code>0x7fffffffd9cc</code> 。</p>
<p>继续执行 <code>si</code> 指令，让程序走完 call 指令：这个过程同 main 函数里的一样，准备调用参数，调用函数，压入返回地址。这时候寄存器 %rbp 为 <code>0x7fffffffd9d0</code>，%rsp 为 <code>0x7fffffffd9c0</code>：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">si</span>g (x=<span class="number">32767</span>) <span class="meta">at</span> father.c:<span class="number">2</span><span class="number">2</span>	&#123;(gdb) info registers <span class="built_in">rbp</span> <span class="built_in">rsp</span><span class="built_in">rbp</span>            <span class="number">0x7fffffffd9d0</span>	<span class="number">0x7fffffffd9d0</span><span class="built_in">rsp</span>            <span class="number">0x7fffffffd9c0</span>	<span class="number">0x7fffffffd9c0</span></span><br></pre></td></tr></table></figure>
<p>此时的调用栈：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B3.png" alt=""></p>
<h3 id="（5）继续调用其他函数"><a href="#（5）继续调用其他函数" class="headerlink" title="（5）继续调用其他函数"></a>（5）继续调用其他函数</h3><p>接下来调用函数 g，和调用函数 f 一样，压入紧跟在 call 函数之后的指令地址，程序跳转到函数 g 起始处。这时，<code>%rsp</code> 保存的地址值为 <code>0x7fffffffd9c0</code>。</p>
<p>函数 g 的汇编指令如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas /rmDump of assembler code for function g:<span class="number">2</span>	&#123;=&gt; <span class="number">0x00000000004004ed</span> &lt;+<span class="number">0</span>&gt;:	<span class="number">55</span>		<span class="keyword">push</span>   %rbp   <span class="number">0x00000000004004ee</span> &lt;+<span class="number">1</span>&gt;:	<span class="number">48</span> <span class="number">89</span> e5	<span class="keyword">mov</span>    %rsp,%rbp   <span class="number">0x00000000004004f1</span> &lt;+<span class="number">4</span>&gt;:	<span class="number">89</span> <span class="number">7d</span> fc	<span class="keyword">mov</span>    %edi,-<span class="number">0x4</span>(%rbp)<span class="number">3</span>	    return x+<span class="number">5</span><span class="comment">;</span>   <span class="number">0x00000000004004f4</span> &lt;+<span class="number">7</span>&gt;:	8b <span class="number">45</span> fc	<span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbp),%eax   <span class="number">0x00000000004004f7</span> &lt;+<span class="number">10</span>&gt;:	<span class="number">83</span> c0 <span class="number">05</span>	<span class="keyword">add</span>    <span class="number">$0</span>x5,%eax<span class="number">4</span>	&#125;   <span class="number">0x00000000004004fa</span> &lt;+<span class="number">13</span>&gt;:	<span class="number">5d</span>		<span class="keyword">pop</span>    %rbp   <span class="number">0x00000000004004fb</span> &lt;+<span class="number">14</span>&gt;:	c3		retq   End of assembler dump.(gdb)</span><br></pre></td></tr></table></figure>
<p>对于最前面两条指令，我们已经很熟悉了：建立 g 函数的栈帧，将 f 函数的帧首地址入栈，更新 <code>%rbp</code> 为 g 函数的帧首地址。接着一条指令把 <code>%edi</code> 寄存器里的值被设置为相对于 <code>%rbp</code> 向下偏移 <code>4</code> 个字节的地址 <code>0x7fffffffd9b4</code>。注意，这里并没有将 <code>%rsp</code> 继续向下扩展 <code>8</code> 个字节，因为 g 函数之后没有需要额外栈空间的操作了，只需做一个加法运算然后返回，这样，仅使用 <code>%rax</code> 寄存器就可以完成这个操作。因此，<code>-0x4(%rbp)</code> 这个四字节栈空间只用来临时存储一下 <code>%edi</code>里的值。编译器优化了指令.</p>
<p>接着两条指令将刚才存入到偏移位置的值存入 <code>%rax</code> 寄存器，加上 <code>0x5</code> 之后再赋值给 <code>%rax</code> 作为结果返回。</p>
<p>到目前为止，栈指针和帧指针的值指向同一位置：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i registers <span class="built_in">rbp</span> <span class="built_in">rsp</span><span class="built_in">rbp</span>            <span class="number">0x7fffffffd9b8</span>	<span class="number">0x7fffffffd9b8</span><span class="built_in">rsp</span>            <span class="number">0x7fffffffd9b8</span>	<span class="number">0x7fffffffd9b8</span>(gdb)</span><br></pre></td></tr></table></figure>
<p>调用栈：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B4.png" alt=""></p>
<p>这时，用 <code>x</code> 指令查看内存信息：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/16x $<span class="built_in">rsp</span><span class="number">0x7fffffffd9b8</span>:	<span class="number">0xffffd9d0</span>	<span class="number">0x00007fff</span>	<span class="number">0x00400511</span>	<span class="number">0x00000000</span><span class="number">0x7fffffffd9c8</span>:	<span class="number">0x00400400</span>	<span class="number">0x0000000a</span>	<span class="number">0xffffd9e0</span>	<span class="number">0x00007fff</span><span class="number">0x7fffffffd9d8</span>:	<span class="number">0x00400521</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span><span class="number">0x7fffffffd9e8</span>:	<span class="number">0xf7a35ec5</span>	<span class="number">0x00007fff</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>(gdb)</span><br></pre></td></tr></table></figure>
<p>以上显示的 16 个 4 bytes 内存地址指示的值，以十六进制显示。比较下，是否和上面的调用栈信息一致？</p>
<h3 id="函数返回过程"><a href="#函数返回过程" class="headerlink" title="函数返回过程"></a>函数返回过程</h3><p>函数调用对应着调用栈的建立，而函数返回则是进行调用栈的销毁，返回比调用过程简单多了。继续上面 g 函数的执行，g 函数还剩两条语句：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000000004004fa</span> &lt;+<span class="number">13</span>&gt;:	<span class="number">5d</span>		<span class="keyword">pop</span>    %rbp<span class="number">0x00000000004004fb</span> &lt;+<span class="number">14</span>&gt;:	c3		retq</span><br></pre></td></tr></table></figure>
<p>可以看出，g 函数的返回过程中，第一条指令 <code>pop %rbp</code> 先把当前栈顶 <code>%rsp</code> 的值出栈并赋给 <code>%rbp</code>，这时候栈顶指针指向的是 f 函数的栈帧顶 <code>0x7fffffffd9c0</code>，里面存的就是继续执行 f 函数接下来执行语句的地址 <code>0x400511</code>。 </p>
<p>第二条指令 <code>retq</code>，它是 <code>call</code> 指令的逆操作，它将改变 ip 寄存器的值，值就是当前 <code>%rsp</code> 里存的值 <code>0x400511</code>，同时将 %rsp 的值加 8。</p>
<p>两条指令执行完之后的调用栈：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7g%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E.png" alt=""></p>
<p>这时候程序就已经从 g 函数中返回，返回到 f 函数继续执行了。接下来的返回流程就比较类似了，不过注意到 f 函数有一个 <code>leave</code> 指令，那么这个指令有什么作用呢？</p>
<p><code>leave</code> 指令相当于是每个函数开头两条指令的逆操作，等价于以下两条指令：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span> %rbp, %rsp</span><br><span class="line">popq %rbp</span><br></pre></td></tr></table></figure>
<p>这两条指令将 bp 和 sp 寄存器中的值还原为函数调用前的值。接着就是 ret 指令，与 g 函数过程一样的，就不再赘述了。然后返回到 main 函数，main 函数再返回，调用栈被销毁。</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>由于 C 语言学艺不精，欲从基础学起，查资料，看书，看博客，从计算机底层基础学起，逐步了解 C 语言，学习 gdb 单步调试和反汇编工具，梳理了对函数调用的底层实现过程。</p>
<p>1、%rsp 保存的是栈顶的地址，栈顶所代表的就是当前栈，就是当前正在调用的函数。<br>2、%rbp 被称为基址指针寄存器（base pointer）或者帧指针（frame pointer），它保存着当前栈帧的基地址。<br>3、%rip 被称为指令地址寄存器(instruction pointer)，用来记录 CPU 指令的位置。每次 CPU 执行都要先读取 %rip 寄存器的值，然后定位到 %rip 指向的内存地址，并且读取汇编指令，最后执行。读完之后，相应的 %rip 寄存器的值就会增加，增加大小就是读取指令的字节大小。<br>3、函数的调用地址的方向从高地址向低地址扩展的。<br>4、函数调用最多可以传送 6 个整数值（指针和整数）。<br>5、函数调用前如果需要传递参数，参数的压栈顺序是从右向左的。<br>6、栈中的「被保存的%rbp」保存的是调用者的栈帧首地址。<br>7、圧栈和出栈、call、leave、ret等指令完成的实际工作。<br>8、gdb 工具的学习使用。<br>9、函数的调用与返回过程。</p>
<p>栈这种简单的数据结构优雅地完成了支撑计算机程序执行的任务。引用自<a href="http://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html#%E5%B0%8F%E7%BB%93" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="http://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html#%E5%B0%8F%E7%BB%93" target="_blank" rel="noopener">函数调用过程探究</a><br><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch19s01.html" target="_blank" rel="noopener">函数调用</a><br><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch19s02.html" target="_blank" rel="noopener">main函数和启动例程</a><br><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch10.html" target="_blank" rel="noopener">gdb 使用</a><br><a href="https://blog.csdn.net/xungjhj/article/details/70946057" target="_blank" rel="noopener">栈指针和帧指针</a><br><a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">call stack</a><br><a href="https://blog.csdn.net/djbtestingsky/article/details/1884678" target="_blank" rel="noopener">堆栈中的EIP EBP ESP</a><br><a href="http://www.pchou.info/c-cpp/2015/03/03/c-and-asm.html" target="_blank" rel="noopener">一段C语言和汇编的对应分析，揭示函数调用的本质</a></p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <h3> 文档信息 </h3>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://www.iweeek.com">毁于随</a>
    </p>
    <!-- <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://www.iweeek.com/2018/05/26/c/deep-in-c-proccess/">http://www.iweeek.com/2018/05/26/c/deep-in-c-proccess/</a>
    </p> -->
    <p class="copyright-item">
      <span>发表日期: </span>
      <a href=""> 2018年05月26日</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags"> 分类：
            
              <a href="/tags/C/">C</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/05/27/c/learn-to-use-gdb/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">GDB 用法总结（转载）</span>
        <span class="prev-text nav-mobile">上一篇</span>
        ：上一篇
      </a>
    
    
      <a class="next" href="/2018/05/16/linux/5-ways-to-empty-or-delete-a-large-file-content-in-linux/">
        下一篇：
        <span class="next-text nav-default">Linux清空文件内容最便捷的5种方法</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      
  
  

  



      

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

  
    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  






  
    <script type="text/javascript" src="/js/src/nijun/nijun.js"></script>
  


<script src="/js/src/fold.js"></script>
<script src="/js/src/post-detail.js"></script>
<script src="/js/src/tags.js"></script>

<!-- TODO 2018年05月28日12:35:38 解决了 photoswipe 找不到的问题  -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css" rel="stylesheet">


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

    
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

  </body>
</html>