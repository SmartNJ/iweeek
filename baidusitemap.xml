<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">


    
  <url>
    <loc>http://www.iweeek.com/2018/06/23/daily-command-curl/</loc>
    <lastmod>2018-06-23T14:31:46.308Z</lastmod>
    <data>
        <display>
        <title>Linux curl用法详解</title>
        <pubTime>2018-06-23T00:35:29.000Z</pubTime>
      
         <content><p>curl命令是一个利用URL规则在命令行下工作的文件传输工具。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>curl命令是一个利用URL规则在命令行下工作的文件传输工具。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/kill/kill-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：查看网页源码</strong><br>描述：查看网页源码。<br>命令：<code>curl www.sina.com</code><br>输出：</p>
<p><img src="http://p9xqnn501.bkt.clouddn.com/df/df.png" alt=""></p>
<p>curl -o [文件名] <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a> -o参数把这个网页保存下来，相当于使用wget命令。<br><strong>实例：自动跳转</strong><br>curl -L <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a> 有的网址会自动跳转的，-L参数会跳转新的网址。<br><strong>实例：显示头信息</strong><br>curl -i <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a> -i参数可以显示http response的头信息，连同网页代码一起。-I参数则只显示http response头信息。<br><strong>实例：显示通信过程</strong><br>curl -v <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a> -v参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。<br>curl –trace output.txt <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a> 查看更详细的通信过程<br>curl –trace-ascii output.txt <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a><br><strong>实例：发送表单信息</strong><br>curl example.com/form.cgi?data=xxx 发送表单信息有GET和POST两种方法，GET相对简单，把数据附在网址后面。<br>curl -X POST –data “data=xxx” example.com/form.cgi POST方法必须把数据和网址分开，curl要用到–data参数。<br>curl -X POST–data-urlencode “date=April 1” example.com/form.cgi curl的–data-urlencode参数可以为表单编码。<br><strong>实例：HTTP动词</strong><br>curl默认的HTTP动词是GET，使用-X可以支持其他动词。<br>curl -X POST <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a><br>curl -X DELETE ww.example.com<br><strong>实例：文件上传</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">'multipart/form-data'</span> <span class="attr">action</span>=<span class="string">"upload.cgi"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">upload</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">name</span>=<span class="string">press</span> <span class="attr">value</span>=<span class="string">"OK"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>curl –form upload=@localfilename –form press=OK [URL]<br><strong>实例：Referer字段</strong><br>curl –referer <a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> <a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> 在http request头信息中，提供一个referer字段，表示从哪里跳转过来的。<br><strong>实例：User Agent字段</strong><br>curl –user-agent “[User Agent]” [URL]<br><strong>实例：cookie</strong><br>curl –cookie “name=xxx” <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 让curl发送cookie<br>curl -c cookies <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 保存服务器返回的cookie到文件<br>curl -b cookies <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 使这个文件作为cookie信息，作为后续的请求。<br><strong>实例：增加头信息</strong><br>curl –header “Content-Type:application/json” <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a><br><strong>实例：HTTP认证</strong><br>curl –user name:password example.com 有些网域需要HTTP认证，这时curl需要用到–user参数。</p>
</content>

         
        </display>
    </data>
    </url>

    
    
    
    
  <url>
    <loc>http://www.iweeek.com/2018/06/04/linux/daily-command-ps/</loc>
    <lastmod>2018-06-23T04:26:12.807Z</lastmod>
    <data>
        <display>
        <title>Linux ps命令用法详解</title>
        <pubTime>2018-06-04T02:09:39.000Z</pubTime>
      
         <content><p>ps命令用来列出系统中当前运行进程的快照。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>ps命令（Process Status）用来列出系统中当前运行的那些进程的快照。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。如果想要动态地显示进程信息，就可以使用top命令</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>ps [options]</code></p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><p>表: ps命令选项</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-A</td>
<td style="text-align:left">所有的不同process均显示出来，与-e具有同样的效果</td>
</tr>
<tr>
<td style="text-align:left">-a</td>
<td style="text-align:left">不与terminal有关的所有process</td>
</tr>
<tr>
<td style="text-align:left">-u</td>
<td style="text-align:left">有效使用者（effectiveuser）相关的process</td>
</tr>
<tr>
<td style="text-align:left">-e</td>
<td style="text-align:left">列出所有程序，与-A效果相同</td>
</tr>
<tr>
<td style="text-align:left">-x</td>
<td style="text-align:left">通常与a这个参数一起使用，可列出完整的信息</td>
</tr>
<tr>
<td style="text-align:left">-l</td>
<td style="text-align:left">较长、较详细的输出该该PID的信息</td>
</tr>
<tr>
<td style="text-align:left">-j</td>
<td style="text-align:left">工作的格式(jobsformat)</td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td style="text-align:left">做一个更为完整的输出</td>
</tr>
</tbody>
</table>
<p>ps命令支持三种使用的语法格式:</p>
<ol>
<li>UNIX 风格，选项可以组合在一起，并且选项前必须有“-”连字符</li>
<li>BSD 风格，选项可以组合在一起，但是选项前不能有“-”连字符</li>
<li>GNU 风格的长选项，选项前有两个“-”连字符</li>
</ol>
<h2 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h2><h3 id="不加参数执行ps命令"><a href="#不加参数执行ps命令" class="headerlink" title="不加参数执行ps命令"></a><strong>不加参数执行ps命令</strong></h3><p>描述：结果显示4列信息，这些信息并未排序。<br>命令：<code>ps</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps.png" alt=""><br>表: ps命令默认的列表所代表的含义</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PID</td>
<td style="text-align:left">运行着的命令(CMD)的进程编号</td>
</tr>
<tr>
<td style="text-align:left">TTY</td>
<td style="text-align:left">命令所运行的位置（终端）</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">运行着的该命令所占用的CPU处理时间</td>
</tr>
<tr>
<td style="text-align:left">CMD</td>
<td style="text-align:left">该进程所运行的命令</td>
</tr>
</tbody>
</table>
<h3 id="显示更多信息"><a href="#显示更多信息" class="headerlink" title="显示更多信息"></a><strong>显示更多信息</strong></h3><p>描述：ps默认只显示属于当前用户这次登录的PID与相关信息，-l参数显示更详细的信息。<br>命令：<code>ps -l</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-l.png" alt=""></p>
<p>-l显示信息的每个字段具体含义如下：</p>
<ul>
<li>F：代表这个程序的旗标（process flags），说明这个程序的总结权限，常见的有：<ul>
<li>若为4表示此程序的权限为root。</li>
<li>若为1表示此子程序仅进行复制（fork）而没有实际执行（exec）。</li>
</ul>
</li>
<li>S：代表这个程序的状态（STAT)，主要的状态有：<ul>
<li>R（Running)：该程序正在运行中。</li>
<li>S（Sleep）：该程序目前正在睡眠状态（idle），但可以被唤醒（signal）。</li>
<li>D：不可被唤醒的睡眠状态，例如，程序可能在等待I/O的情况。</li>
<li>T：停止状态（stop），可能是在工作控制（背景暂停）或出错（traced）状态。</li>
<li>Z：僵尸（Zombie）状态，程序已经终止但却无法被移除到内存外。</li>
</ul>
</li>
<li>UID/PID/PPID：代表程序被该UID所拥有/程序的PID号码/程序的父程序PID号码。</li>
<li>C：代表CPU使用率，单位为百分比。</li>
<li>PRI/NI：Priority/Nice的缩写，代表程序被CPU所执行的优先顺序，数值越小代表程序越快被CPU执行。</li>
<li>ADDR/SZ/WCHAN：都与内存有关，ADDR是kernel function，指出该程序在内存的哪个部分，如果是个running的程序，一般就会显示“-”，SZ代表程序用掉多少内存，WCHAN表示目前程序是否运行中，同样的，若为-表示正在运行中。</li>
<li>TTY：登陆者的终端机位置，若为远端登陆则使用动态终端接口（pts/n）。</li>
<li>TIME：使用掉的CPU时间，此程序实际花费CPU运行的时间，而不是系统时间。</li>
<li>CMD：command的缩写，造成此程序的出发程序是什么。</li>
</ul>
<h3 id="显示所有进程"><a href="#显示所有进程" class="headerlink" title="显示所有进程"></a><strong>显示所有进程</strong></h3><p>描述：使用-a参数，-a代表all，加上x参数会显示没有控制终端的进程。可以结合less命令和管道来使用。<br>命令：<br><code>ps -ax</code><br><code>ps -ax | less</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-ax.png" alt=""><br>说明：如果用户名的长度大于8个字符，那么ps只会显示UID。</p>
<h3 id="显示所有进程信息，连同命令行"><a href="#显示所有进程信息，连同命令行" class="headerlink" title="显示所有进程信息，连同命令行"></a><strong>显示所有进程信息，连同命令行</strong></h3><p>描述：-e参数与-A参数一样显示所有进程信息，-a将不显示命令行。-f和u选项可以显示进程的具体信息。<br>命令：<code>ps efu</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-efu.png" alt=""></p>
<h3 id="显示用户进程"><a href="#显示用户进程" class="headerlink" title="显示用户进程"></a><strong>显示用户进程</strong></h3><p>描述：查看root用户的进程信息。-u选项后跟用户名过滤所属用户的进程，多个用户名用逗号分隔。<br>命令：<code>ps -u root</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-u.png" alt=""></p>
<h3 id="通过进程名和PID过滤进程"><a href="#通过进程名和PID过滤进程" class="headerlink" title="通过进程名和PID过滤进程"></a><strong>通过进程名和PID过滤进程</strong></h3><p>描述：-C选项可以显示指定进程名的进程信息。<br>命令：<code>ps -C agetty</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-C.png" alt=""></p>
<p>描述：-p选项通过进程ID显示进程，通过逗号分隔来指定多个进程ID。<br>命令：<code>ps -f -p 423,32535,2087</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-f-p.png" alt=""></p>
<p>描述：使用grep查找，因为-C选项必须提供精确的进程名，它并不能通过部分名字或者通配符查找。<br>命令：<code>ps -ef | grep ssh</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-grep.png" alt=""></p>
<p>描述：只列出指定进程名的进程ID。<br>命令：<code>ps -C agetty -o pid=</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-C-o.png" alt=""></p>
<p>描述：-f选项查看格式化的信息列表。<br>命令：<code>ps -f -C agetty</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-f-C.png" alt=""></p>
<p>描述：只打印进程ID为27815的进程名字。<br>命令：<code>ps -q 27815 -o comm=</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-f-C.png" alt=""></p>
<h3 id="通过cpu和内存使用来过滤进程"><a href="#通过cpu和内存使用来过滤进程" class="headerlink" title="通过cpu和内存使用来过滤进程"></a><strong>通过cpu和内存使用来过滤进程</strong></h3><p>描述：列出目前所有的正在内存当中的程序。ps aux会依照PID的顺序来排序显示，只显示排在前面的一部分数据。</p>
<p>命令：<code>ps aux | less</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-aux-less.png" alt=""></p>
<p>描述：根据CPU使用来排序。默认的结果集是依照PID的顺序来排序显示的，可以通过–sort命令来排序。<br>命令：<code>ps -aux --sort -pcpu | less</code></p>
<p>描述：根据内存使用来排序。默认的结果集是依照PID的顺序来排序显示的，可以通过–sort命令来排序。<br>命令：<code>ps -aux --sort -pmem | less</code></p>
<p>描述：将前两个命令合并，通过管道显示前10个结果。<br>命令：<br><code>ps -aux --sort -pcpu,+pmem | head -n 10</code><br><code>ps -aux --sort=-pcpu,+pmem | head -n 10</code></p>
<p>描述：ps aux会依照PID的顺序来排序显示，只显示排在前面的一部分数据。<br>命令：<code>ps -aux &gt; out.txt</code></p>
<p>表: ps命令显示字段的意义</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">User</td>
<td style="text-align:left">该process属于哪个使用者账号</td>
</tr>
<tr>
<td style="text-align:left">PID</td>
<td style="text-align:left">该process使用掉的CPU资源百分比</td>
</tr>
<tr>
<td style="text-align:left">%CPU</td>
<td style="text-align:left">该process所占用的实体内存百分比</td>
</tr>
<tr>
<td style="text-align:left">%MEM</td>
<td style="text-align:left">该process所占用的实体内存百分比</td>
</tr>
<tr>
<td style="text-align:left">VSZ</td>
<td style="text-align:left">该process使用掉的虚拟内存量（KBytes）</td>
</tr>
<tr>
<td style="text-align:left">RSS</td>
<td style="text-align:left">该process占用的固定的内存量（KBytes）</td>
</tr>
<tr>
<td style="text-align:left">TTY</td>
<td style="text-align:left">该process是在哪个终端机上面运行，若与终端机无关则显示？另外，tty1-tty6是本机上面的登陆者程序，如果是pts/0等等的，则表示为网络连接的主机程序</td>
</tr>
<tr>
<td style="text-align:left">STAT</td>
<td style="text-align:left">该process目前的状态，状态显示与ps -l的S旗标相同（R/S/T/Z）</td>
</tr>
<tr>
<td style="text-align:left">START</td>
<td style="text-align:left">该process被触发启动的时间</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">该process实际使用CPU运行的时间</td>
</tr>
<tr>
<td style="text-align:left">COMMAND</td>
<td style="text-align:left">该process的实际指令是什么</td>
</tr>
</tbody>
</table>
<h3 id="格式化输出root用户（真实的或有效的UID）创建的进程"><a href="#格式化输出root用户（真实的或有效的UID）创建的进程" class="headerlink" title="格式化输出root用户（真实的或有效的UID）创建的进程"></a><strong>格式化输出root用户（真实的或有效的UID）创建的进程</strong></h3><p>描述：查看由root用户运行的进程以及其他相关信息。<br>命令：<code>ps -U root -u root u</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-U-u.png" alt=""><br>说明：<br>-U参数按真实用户ID(RUID)筛选进程，它会从用户列表中选择真实用户名或 ID。真实用户即实际创建该进程的用户。<br>-u参数用来筛选有效用户ID（EUID）。<br>最后的u参数用来决定以针对用户的格式输出，由User，PID，%CPU，%MEM，VSZ，RSS，TTY，STAT，START，TIME和COMMAND这几列组成。</p>
<h3 id="指定显示的格式"><a href="#指定显示的格式" class="headerlink" title="指定显示的格式"></a><strong>指定显示的格式</strong></h3><p>描述：-o显示指定的格式输出，–sort=-%mem指定以内存倒序的方式显示程序。<br>命令：<code>ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head</code><br>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head</span><br><span class="line">  PID  PPID CMD                         %MEM %CPU</span><br><span class="line"> 1248  1029 /usr/local/cloudmonitor/jre  3.6  0.4</span><br><span class="line">  690     1 /usr/bin/python -Es /usr/sb  0.8  0.0</span><br><span class="line">  976     1 /usr/local/aegis/aegis_clie  0.6  0.1</span><br><span class="line">  423     1 /usr/lib/polkit-1/polkitd -  0.6  0.0</span><br><span class="line">16409  2099 sshd: root@pts/0             0.3  0.0</span><br><span class="line">15920  2099 sshd: root@pts/2             0.3  0.0</span><br><span class="line">16213  2099 sshd: root@pts/1             0.3  0.0</span><br><span class="line">16451  2099 sshd: root@pts/3             0.3  0.0</span><br><span class="line">  687     1 /usr/sbin/rsyslogd -n        0.2  0.0</span><br></pre></td></tr></table></figure>
<p>描述：显示安全信息，查看谁登录了服务器。能够与-e参数一起使用的关键字是args，cmd，comm，command，fname，ucmd，ucomm，lstart，bsdstart和start。<br>命令：<code>ps -eo pid,user,args</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-o.png" alt=""></p>
<h3 id="通过线程过滤进程"><a href="#通过线程过滤进程" class="headerlink" title="通过线程过滤进程"></a><strong>通过线程过滤进程</strong></h3><p>描述：-L选项可以过滤特定进程的线程。<br>命令：<code>ps -L 456</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-thread-L.png" alt=""></p>
<h3 id="实时监控进程状态"><a href="#实时监控进程状态" class="headerlink" title="实时监控进程状态"></a>实时监控进程状态</h3><p>描述：每秒刷新一次ps命令，使之动态显示CPU和内存的使用率。<br>命令：<code>watch -n 1 &#39;ps -aux --sort -pmem,-pcpu&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-watch.png" alt=""></p>
<p>描述：每秒刷新一次ps命令，使之动态显示CPU和内存的使用率，显示前20条内容。<br>命令：<code>watch -n 1 &#39;ps -aux --sort -pmem,-pcpu | head -20&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-watch-head.png" alt=""></p>
<p>描述：与top不同的是，ps可以选择想查看的字段。<br>命令：<code>watch -n 1 &#39;ps -U nijun u --sort -pmem,-pcpu | head -20&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-watch-head-user.png" alt=""></p>
<h3 id="树形显示进程"><a href="#树形显示进程" class="headerlink" title="树形显示进程"></a><strong>树形显示进程</strong></h3><p>描述：显示类似程序树的进程信息。<br>命令：<code>ps -axjf</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-axjf.png" alt=""></p>
<p>命令：<code>ps -ejH</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-ejH.png" alt=""></p>
<p>描述：forest选项会构造一个树形进程层次视图。<br>命令：<code>ps -f --forest -C sshd</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-forest.png" alt=""></p>
<p>描述：另一个显示树形结构的命令。<br>命令：<code>pstree</code><br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-pstree.png" alt=""></p>
<h3 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a><strong>杀掉进程</strong></h3><p>描述：用ps -A命令列出所有进程，然后通过管道输入到grep来查找进程/服务，例如ssh。<br>命令：<code>ps -A | grep -i ssh</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-A-grep.png" alt=""></p>
<p>描述：使用pgrep和pkill工具更简单。<br>命令：<br><code>pgrep ssh</code><br><code>pgrep -l ssh</code><br>输出：</p>
<p>要找和ssh相关的进程信息:<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-pgrep.png" alt=""><br>为了避免kill掉错误的进程，也可以通过下面命令来匹配进程名称:<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-pgrep-l.png" alt=""><br>然后用pkill杀掉进程，只需要输入想要杀死的资源名称。</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/23/daily-command-kill/</loc>
    <lastmod>2018-06-23T00:34:42.809Z</lastmod>
    <data>
        <display>
        <title>Linux kill命令用法详解</title>
        <pubTime>2018-06-22T23:33:18.000Z</pubTime>
      
         <content><p>kill命令用来删除执行中的程序或工作。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或job指令查看。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/kill/kill-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>kill [signal or option] PID(s)</code></p>
<p>表: kill命令的信号名</p>
<table>
<thead>
<tr>
<th style="text-align:left">信号</th>
<th style="text-align:left">信号值</th>
<th style="text-align:left">行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SIGHUP</td>
<td style="text-align:left">1</td>
<td style="text-align:left">挂起</td>
</tr>
<tr>
<td style="text-align:left">SIGKILL</td>
<td style="text-align:left">9</td>
<td style="text-align:left">杀死信号</td>
</tr>
<tr>
<td style="text-align:left">SIGTERM</td>
<td style="text-align:left">15</td>
<td style="text-align:left">终止</td>
</tr>
</tbody>
</table>
<p>SIGTERM是杀死进程默认和最安全的方式，SIGHUP次之。SIGKILL是最不安全的方式，它将杀死一个没有完全保存的进程。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-a：当处理当前进程时，不限制命令名和进程号的对应关系。</li>
<li>-l &lt;信号编号&gt;：若不加&lt;信号编号&gt;选项，则-l参数会列出全部的信号名称。</li>
<li>-p：指定kill 命令只打印相关进程的进程号，而不发送任何信号。</li>
<li>-s &lt;信号名称或编号&gt;：指定要送出的信息。</li>
<li>-i：交互式的终止进程。</li>
<li>-I：忽略大小写。</li>
<li>-u：指定用户。</li>
</ul>
<h2 id="kill的执行范围"><a href="#kill的执行范围" class="headerlink" title="kill的执行范围"></a>kill的执行范围</h2><ul>
<li>用户可以杀死他的所有进程。</li>
<li>用户不能杀死另一个用户的进程。</li>
<li>用户无法终止系统正在使用的进程。</li>
<li>root用户可以终止系统级进程和任何用户的进程。</li>
</ul>
<h3 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a><strong>杀死进程</strong></h3><p>描述：用pgrep找出进程PID，并用kill终止PID为2807的进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># pgrep mysql</span><br><span class="line">2807</span><br><span class="line"># kill -9 2807</span><br></pre></td></tr></table></figure></p>
<p>说明：使用<code>kill -9 PID</code>与<code>kill -SIGKILL PID</code>类似。</p>
<h3 id="使用进程名称杀死进程"><a href="#使用进程名称杀死进程" class="headerlink" title="使用进程名称杀死进程"></a><strong>使用进程名称杀死进程</strong></h3><p>描述：pkill命令后直接加上进程名即可杀死该进程，但在杀死之前，最好先确认进程名称是否正确。<br>命令：<br><code>pkill mysql</code></p>
<p>描述：为了避免kill掉错误的进程，也可以通过下面命令来匹配进程名称。<br>命令：<br><code>pgrep -l ssh</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ps/ps-pgrep-l.png" alt=""></p>
<h3 id="killall杀死多个进程"><a href="#killall杀死多个进程" class="headerlink" title="killall杀死多个进程"></a><strong>killall杀死多个进程</strong></h3><p>描述：一次杀死多个进程。<br>命令：<br><code>kill PID1 PID2 PID3</code><br><code>kill -9 PID1 PID2 PID3</code><br><code>kill -SIGKILL PID1 PID2 PID3</code></p>
<p>描述：killall用进程名替代PID，并且会kill掉所有的同名进程。<br>语法：<code>killall [signal or option] Process name</code><br>命令：<code>killall mysqld</code><br>检查：验证进程是否处于运行状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> service mysql status</span><br><span class="line"><span class="meta">#</span> pgrep mysql</span><br><span class="line"><span class="meta">#</span> ps -aux | grep mysql</span><br></pre></td></tr></table></figure>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/07/linux/daily-command-netstat/</loc>
    <lastmod>2018-06-23T00:21:47.158Z</lastmod>
    <data>
        <display>
        <title>Linux netstat总结</title>
        <pubTime>2018-06-07T01:32:47.000Z</pubTime>
      
         <content><p>netstat命令用来查看系统中所有的网络套接字连接情况。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>netstat [选项]</p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>netstat命令用来查看系统中所有的网络套接字连接情况，包括TCP、UDP和Unix套接字。也可以显示路由表，接口状态，masquerade 连接，多播成员（Multicast Memberships）等等。另外，它还可以列出处于监听状态（等待接入请求）的套接字，比如想确认系统中的web服务是否起来，就可以查看80端口有没有打开。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-a或–all：显示所有选项，默认不显示LISTEN相关。</li>
<li>-t或–tcp：(TCP)仅显示TCP相关选项。</li>
<li>-u或–udp：(UDP)仅显示UDP相关选项。</li>
<li>-x或–unix：此参数的效果和指定”-A unix”参数相同。</li>
<li>-n或–numeric：拒绝显示别名，能显示数字的全部转化成数字。</li>
<li>-l或–listening：仅列出有在Listen(监听)的服务状态。</li>
<li>-g或–groups：显示多重广播功能群组组员名单。</li>
<li>-p或–programs：显示建立相关链接的程序名和PID。</li>
<li>-r或–route：显示路由信息，路由表。</li>
<li>-e或–extend：显示扩展信息，例如UID等。</li>
<li>-s或–statistics：按各个协议进行统计。</li>
<li>-c或–continuous：每隔一个固定时间，执行该netstat命令。</li>
<li>-g或–groups：显示多重广播功能群组组员名单。</li>
</ul>
<p>提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到。</p>
<h2 id="输出信息含义"><a href="#输出信息含义" class="headerlink" title="输出信息含义"></a>输出信息含义</h2><p>执行netstat后，其输出结果为</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat.png" alt=""></p>
<p>netstat的输出结构可以分为两个部分：<br>一个是Active Internet connections，称为有源TCP连接。其中”Recv-Q”和”Send-Q”指的是接收队列和发送队列。<br>另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。Proto显示连接使用的协议，RefCnt表示连接到本套接口上的进程号，Types显示套接口的类型，State显示套接口当前的状态，Path表示连接到套接口的其它进程使用的路径名。</p>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><h3 id="一、列出所有连接（包括监听和未监听的）"><a href="#一、列出所有连接（包括监听和未监听的）" class="headerlink" title="一、列出所有连接（包括监听和未监听的）"></a>一、列出所有连接（包括监听和未监听的）</h3><p><strong>示例：1. 列出当前所有的连接</strong><br>命令：netstat -a<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-a.png" alt=""></p>
<p><strong>示例：2. 列出所有TCP端口</strong><br>命令：netstat -at<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-at.png" alt=""></p>
<p><strong>示例：3. 列出所有UDP端口</strong><br>描述：-u选项查看UDP端口，-x选项查看UNIX端口。<br>命令：netstat -au<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-au.png" alt=""></p>
<h3 id="二、列出所有处于监听状态的-Sockets"><a href="#二、列出所有处于监听状态的-Sockets" class="headerlink" title="二、列出所有处于监听状态的 Sockets"></a>二、列出所有处于监听状态的 Sockets</h3><p><strong>示例：4. 只列出所有监听TCP的端口</strong><br>描述：查看本机监听的（l）TCP连接（t）的IP地址（n）。<br>命令：netstat -tnl<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-tnl.png" alt=""></p>
<p><strong>示例：5. 在netstat的输出中不显示主机，端口和用户名（host，port，user）</strong><br>描述：-n选项禁用域名解析功能。例如，查看所有（a）TCP连接的（t）IP地址（n）等信息。<br>命令：netstat -ant<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-ant.png" alt=""></p>
<p><strong>示例：6. 获取进程名、进程号以及用户ID</strong><br>描述：<br>使用-p选项查看进程信息，-ep选项可以同时查看进程名和用户名。另外，-n和-e选项一起使用，User列的属性就是用户ID，而不是用户名。netstat运行在root权限之下才可以得到运行在root权限下的进程名。<br>输出：</p>
<p>查看本机监听的（l）TCP连接的（t）进程名（p）和IP地址（n）。<br><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-tnlp.png" alt=""></p>
<p>查看本机监听的（l）TCP连接的（t）进程名（p）和用户名（e）。<br><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-tlpe.png" alt=""></p>
<p>查看本机监听的（l）TCP连接的（t）进程名（p）和用户名ID（ne）。<br><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-tlpen.png" alt=""></p>
<p><strong>示例：7. 显示每个协议的统计信息</strong><br>描述：-s选项可以打印出网络统计数据，包括某个协议下的收发包数量。<br>命令：netstat -s<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-s.png" alt=""></p>
<p><strong>示例：8. 持续输出netstat信息</strong><br>描述：-c选项持续输出信息，默认时间间隔 1 秒。例如，下面这个命令可持续输出 TCP 协议信息。<br>命令：netstat -c 1<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-c.png" alt=""></p>
<p><strong>示例：9. 查看服务是否在运行</strong><br>描述：结合grep，查看ntp服务是否在运行。例如，查看本机所有的（a）监听连接（l）中与ntp服务有关的信息，包括进程信息（p）等额外的信息（e）。<br>命令：sudo netstat -aple | grep ntp<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-grep.png" alt=""></p>
<p><strong>示例：10. 查看端口被占用的情况</strong><br>描述：结合grep，查看端口被占用的情况。例如，查看本机所有的（a）连接中与端口80有关的信息，包括IP地址（n）以及进程信息（p）等额外的信息（e）。<br>命令：netstat -anpe | grep “80”<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-grep-port.png" alt=""></p>
<p><strong>示例：11. 显示核心路由信息</strong><br>描述：-r选项打印内核路由信息，打印出来的信息与route命令输出的信息一样。<br>命令：netstat -nr<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-rn.png" alt=""></p>
<p><strong>示例：12. 显示网络接口列表</strong><br>描述：-i选项打印网络接口信息。<br>命令：netstat -i<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-i.png" alt=""></p>
<p><strong>示例：13. 显示网络接口的详细信息</strong><br>描述：将-e选项和-i选项搭配使用，可以输出用户友好的信息。下面的输出信息与ifconfig输出的信息一样。<br>命令：netstat -ie<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-ie.png" alt=""></p>
<p><strong>示例：14. 显示多播组信息</strong><br>描述：选项-g输出IPv4和IPv6的多播组信息。<br>命令：netstat -g<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-g.png" alt=""></p>
<p><strong>示例：15. IP和TCP分析</strong><br>描述：查看连接某服务器端口最多的IP地址<br>命令：watch -d -n0 “netstat -nat | grep ‘172.16.14.151’ | awk ‘{print $5}’ | awk -F: ‘{print $1}’ | sort | uniq -c | sort -nr | head -20”</p>
<p>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/netstat/netstat-watch.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/22/linux/daily-command-mkdir/</loc>
    <lastmod>2018-06-22T06:32:02.985Z</lastmod>
    <data>
        <display>
        <title>Linux mkdir总结</title>
        <pubTime>2018-06-22T09:33:12.000Z</pubTime>
      
         <content><p>mkdir命令用来创建目录和子目录。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>mkdir命令用来创建目录和子目录，如果目录还不存在，则创建之。<br><img src="http://pabfn7ecx.bkt.clouddn.com/mkdir/mkdir-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>mkdir [OPTION]... DIRECTORY...</code></p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">m&lt;目标属性&gt;或–mode&lt;目标属性&gt;</td>
<td style="text-align:left">建立目录的同时设置目录的权限</td>
</tr>
<tr>
<td style="text-align:left">p或–parents</td>
<td style="text-align:left">若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录</td>
</tr>
<tr>
<td style="text-align:left">v</td>
<td style="text-align:left">列出已经被创建的目录</td>
</tr>
</tbody>
</table>
<h2 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h2><h3 id="运行mkdir命令"><a href="#运行mkdir命令" class="headerlink" title="运行mkdir命令"></a><strong>运行mkdir命令</strong></h3><p>描述：在~下创建mk目录，如果目录已存在，会提示无法创建它。<br>命令：<code>mkdir mk</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/mkdir/mkdir.png" alt=""></p>
<p>描述：创建目录的首要条件是，在创建目录的目标路径下你必须具有访问权限。<br>命令：<code>mkdir mk</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/mkdir/mkdir-permission.png" alt=""></p>
<h3 id="创建多个目录"><a href="#创建多个目录" class="headerlink" title="创建多个目录"></a><strong>创建多个目录</strong></h3><p>描述：同时创建foo、bar、baz三个目录。<br>命令：<code>mkdir foo bar baz</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/mkdir/mkdir-multiple-file.png" alt=""></p>
<h3 id="递归创建目录"><a href="#递归创建目录" class="headerlink" title="递归创建目录"></a><strong>递归创建目录</strong></h3><p>描述：创建具有子目录层级的目录，如果父目录找不到，使用-p选项可以递归创建目录，包括父目录。<br>命令：<br><code>mkdir -p word/more</code><br><code>ls -R</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/mkdir/mkdir-R.png" alt=""></p>
<h3 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a><strong>设置访问权限</strong></h3><p>描述：创建一个名为foo的目录，同时为目录所有者、用户组和其他用户针对该目录赋予只读权限。-m选项可以设置新目录的权限。<br>命令：<code>mkdir -m=r-- foo</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/mkdir/mkdir-m.png" alt=""></p>
<h3 id="打印创建目录的过程信息"><a href="#打印创建目录的过程信息" class="headerlink" title="打印创建目录的过程信息"></a><strong>打印创建目录的过程信息</strong></h3><p>描述：-v选项可以查看创建目录的过程。<br>命令：<code>mkdir -v foo bar baz</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/mkdir/mkdir-v.png" alt=""></p>
<h3 id="创建复杂的目录树"><a href="#创建复杂的目录树" class="headerlink" title="创建复杂的目录树"></a><strong>创建复杂的目录树</strong></h3><p>描述：实现下面的目录树结构，用{}来创建层级目录，只要一行命令来实现。然后使用apt或yum安装tree软件包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># cd /home/#USER/Desktop</span><br><span class="line"># mkdir tecmint</span><br><span class="line"># mkdir tecmint/etc</span><br><span class="line"># mkdir tecmint/lib</span><br><span class="line"># mkdir tecmint/usr</span><br><span class="line"># mkdir tecmint/bin</span><br><span class="line"># mkdir tecmint/tmp</span><br><span class="line"># mkdir tecmint/opt</span><br><span class="line"># mkdir tecmint/var</span><br><span class="line"># mkdir tecmint/etc/x1</span><br><span class="line"># mkdir tecmint/usr/x2</span><br><span class="line"># mkdir tecmint/usr/x3</span><br><span class="line"># mkdir tecmint/tmp/Y1</span><br><span class="line"># mkdir tecmint/tmp/Y2</span><br><span class="line"># mkdir tecmint/tmp/Y3</span><br><span class="line"># mkdir tecmint/tmp/Y3/z</span><br></pre></td></tr></table></figure>
<p>命令：<code>mkdir -p /home/$USER/iweeek/{etc/x1,lib,usr/{x2,x3},bin,tmp/{Y1,Y2,Y3/z},opt,var}</code><br><code>tree /home/$USER/iweeek</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/mkdir/mkdir-tree.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/08/linux/daily-command-xargs/</loc>
    <lastmod>2018-06-22T01:57:28.853Z</lastmod>
    <data>
        <display>
        <title>Linux xargs总结</title>
        <pubTime>2018-06-08T06:36:56.000Z</pubTime>
      
         <content><p>xargs命令是给其他命令传递参数的一个过滤器，可以直接将一个程序的输出作为另一个程序的输入（例如文本过滤或模式搜索工具，如grep，sed，awk等）。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>xargs [选项] [命令]</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>xargs是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。它擅长将标准输入数据转换成命令行参数。xargs能够处理管道或者标准输入，并将其转换成特定命令的命令参数。xargs也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs的默认命令是echo，空格是默认分隔符。这意味着通过管道传递给xargs的输入将会包含换行和空白，不过通过xargs的处理，换行和空白将被空格取代。xargs是构建单行命令的重要组件之一。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-0：表示以\0作为分隔符，一般与find结合使用。</li>
<li>-a或–arg-file=&lt;文件&gt;：从文件中读入。</li>
<li>-d或–delimiter=&lt;分隔符&gt;：自定义一个分隔符。</li>
<li>-E：结束符，遇到-e指定的命令行参数，则只会将-e指定的命令行参数之前的参数传递给xargs后面的命令。</li>
<li>-i或–replace=&lt;替换的字符串&gt;：将xargs接收到的每个名称赋给{}，用{}代替。</li>
<li>-I：与-i选项相同，可以用其他字符代替{}，例如[]。</li>
<li>-n或–max-args=&lt;最大的参数数&gt;：每次传递几个参数给后面的命令执行。</li>
<li>-p：并不马上执行命令，而是先输出将要执行的完整的命令（包括命令以及传递给命令的命令行参数），询问是否执行。</li>
<li>-r或–no-run-if-empty：当xargs的输入为空的时候则停止xargs，不再去执行。</li>
<li>-s或–max-chars=&lt;最大的字符数&gt;：xargs后面那个命令的最大命令行字符数。</li>
<li>-t或–verbose：表示先打印命令，然后再执行。</li>
<li>-x或–exit：配合-s使用，退出。</li>
<li>–help：显示帮助信息。</li>
<li>–version：显示版本。</li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 多行变单行</strong><br>描述：将alpha.txt内多行数据处理成单行。<br>命令：<code>cat alpha.txt | xargs</code><br>输出：<br>alpha.txt内容：<br><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-multiple-file.png" alt=""><br>经过xargs处理之后：<br><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-multiple-to-single.png" alt=""></p>
<p><strong>实例：2. 传递字符串给xargs</strong><br>描述：执行cat命令。echo命令将”–help”字符串作为输出重定向给xargs作为输入，并将”–help”做成一个命令参数来运行cat命令。<br>命令：<code>echo &#39;--help&#39; | xargs cat</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-echo.png" alt=""></p>
<p><strong>实例：3. 显示执行的命令</strong><br>描述：-t选项在执行前先打印即将执行的命令。<br>命令：<code>echo &#39;--help&#39; | xargs -t cat</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-t.png" alt=""></p>
<p><strong>实例：4. 指定分隔符</strong><br>描述：将echo的输出重定向给xargs命令作为输入，xargs将以#为分隔符分隔输入的内容，最后将分隔好的参数全部一次性传给echo命令将其打印出来。-d选项可以自定义一个分隔符。<br>命令：<code>echo &#39;12#34#56#78&#39; | xargs -d &#39;#&#39; echo</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-d.png" alt=""></p>
<p>下面多出的一行空白，是因为xargs默认是以空白作为分隔符，换行符也是默认空白符的一种，所以每一条字符串后面实际上是加了换行符。</p>
<p><strong>实例：5. 指定命令行参数个数</strong><br>描述：在上面例子的基础上，-n2表示xargs每次只传递2个参数给后面的echo命令。<br>命令：<code>echo &#39;12#34#56#78&#39; | xargs -n2 -d &#39;#&#39; echo</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-n.png" alt=""></p>
<p><strong>实例：6. 执行命令前先提示</strong><br>描述：-p选项使xargs在执行其后面的命令之前先输出即将要执行的完整的命令（包括命令的命令行参数），询问是否执行，输入y才继续执行，否则不执行。<br>命令：<code>echo &#39;12#34#56#78&#39; | xargs -n2 -d &#39;#&#39; -p echo</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-p.png" alt=""></p>
<p><strong>实例：7. 指定终止字符串</strong><br>描述：将字符串”56”作为终止字符串。注意-E只有在xargs不指定-d的时候有效。<br>命令：<code>echo &#39;12 34 56 78&#39; | xargs -E &#39;56&#39; echo</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-E.png" alt=""></p>
<p><strong>实例：8. 结合find使用</strong><br>描述：find的结果是使用’\0’来分隔的。-0选项使用’\0’来分隔。当尝试用rm删除太多的文件的时候，可能会得到/bin/rm Argument list too long的错误，将下面命令中的echo替换为rm -f即可避免这个问题。<br>命令：<code>find . -name &#39;*.txt&#39; -print0 | xargs -d &#39;\0&#39; echo</code><br>或者：<code>find . -name &#39;*.txt&#39; -print0 | xargs -0 echo</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-d-0.png" alt=""></p>
<p><strong>实例：9. 结合wc使用</strong><br>描述：统计当前目录下所有txt文件的行数。<br>命令：<code>find . -type f -name &quot;*.txt&quot; -print0 | xargs -0 wc -l</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-wc.png" alt=""></p>
<p><strong>实例：10. 测试属于哪类文件</strong><br>描述：查找当前目录下的每一个普通文件，并测试它们分别属于哪类文件。<br>命令：<code>find . -type f -print | xargs file</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-file.png" alt=""></p>
<p><strong>实例：11. 结合IO重定向使用</strong><br>描述：查找当前目录下以.txt结尾的文件，将名字重定向给xargs处理，并传给echo，echo将其作为输出流，写入到/tmp/txt.log文件中。<br>命令：<code>find . -name &quot;*.txt&quot; -print | xargs echo &quot;&quot; &gt; /tmp/txt.log</code></p>
<p><strong>实例：12. 结合chmod使用</strong><br>描述：在当前目录下找到所有用户具有读、写和执行权限的文件，并收回相应的写权限。<br>命令：<code>find . -perm -7 -print | xargs chmod o-w</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-chmod.png" alt=""></p>
<p><strong>实例：13. 结合grep使用</strong><br>描述：在当前目录的所有文件中搜索hello这个词。<br>命令：<code>find . -type f -print | xargs grep &quot;hello&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-grep.png" alt=""></p>
<p><strong>实例：14. 结合wget使用</strong><br>描述：一次性下载文件中的所有URL链接资源，每行一个URL链接。<br>命令：<code>cat url-list.txt | xargs wget -c</code></p>
<p><strong>实例：15. 结合tar使用</strong><br>描述：查找所有的jpg文件，并且压缩它们。<br>命令：<code>find . -name &quot;*.jpg&quot; | xargs tar -czvf images.tar.gz</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-tar.png" alt=""></p>
<p><strong>实例：16. 结合cp使用</strong><br>描述：在当前目录中拷贝所有的图片文件至move目录中。<br>命令：<code>ls *.jpg | xargs -n1 -i cp {} move/</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-cp.png" alt=""></p>
<p><strong>实例：17. 指定命令最多的字符数</strong><br>描述：将xyz.txt文件的内容重定向给xargs，xargs限制echo命令的字符数最多为25个（s），如果超过则退出（x），-i选项表示将{}替换成xargs处理得到后的每一项参数，在这里是xyz.txt文件的中的每一行。<br>命令：<code>cat xyz.txt | xargs -i -x -s 25 echo &quot;{}&quot;</code><br>输出：</p>
<p>xyz.txt文件内容：<br><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-s-file.png" alt=""></p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-s.png" alt=""></p>
<p><strong>实例：18. 替换{}指定其他代替字符</strong><br>描述：将当前目录下以.jpg结尾的文件移动到move目录中。-i选项默认的前面输出用{}代替，-I选项可以指定其他代替字符，如例子中的[]。<br>命令：<code>find . -name &quot;*.jpg&quot; | xargs -I [] mv [] move/</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/xargs/xargs-I.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/13/linux/daily-command-type/</loc>
    <lastmod>2018-06-22T01:56:40.559Z</lastmod>
    <data>
        <display>
        <title>Linux type总结</title>
        <pubTime>2018-06-13T00:56:25.000Z</pubTime>
      
         <content><p>type命令用于查找Linux命令的信息。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>type命令用来显示指定命令的类型，可以轻松找出给定的命令是否是别名、shell内置命令、文件、函数或关键字。另外，也可以找到命令的实际路径。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>type [选项] 命令</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-t：仅找出 Linux 命令的类型，输出“file”、“alias”或者“builtin”，分别表示给定的指令为“外部指令”、“命令别名”或者“内部指令”。</li>
<li>-p：如果给出的指令为外部指令，则显示其绝对路径。</li>
<li>-a：在环境变量“PATH”指定的路径中，显示给定指令的信息，包括命令别名。</li>
</ul>
<h2 id="命令类型"><a href="#命令类型" class="headerlink" title="命令类型"></a>命令类型</h2><ul>
<li>alias：别名。</li>
<li>keyword：函数，Shell保留字。</li>
<li>function：函数，Shell函数。</li>
<li>builtin：内建命令，Shell内建命令。</li>
<li>file：文件，磁盘文件，外部命令。</li>
<li>unfound：没有找到。</li>
</ul>
<h2 id="实用示例"><a href="#实用示例" class="headerlink" title="实用示例"></a>实用示例</h2><p><strong>实例：1. 仅找出Linux命令的类型</strong><br>描述：-t选项仅找出Linux命令的类型。例如别名，它不显示被别名的内容。如果该命令找不到，你将在终端中看不到任何内容。<br>命令：<br><code>type -t ls</code><br><code>type -t mkdir</code><br><code>type -t pwd</code><br><code>type -t if</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/type/type-t.png" alt=""></p>
<p><strong>实例：2. 找出命令的绝对路径</strong><br>描述：-p选项可以找出给定Linux命令的绝对路径，这与which命令很像。如果给定的命令是别名、内建命令或是函数，则不会打印任何内容。在这种情况下，-P选项将强制查找路径查找。<br>命令：<br><code>type -p date</code><br><code>type -p cat</code><br><code>type -p pwd</code><br><code>type -P pwd</code><br><code>which pwd</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/type/type-p-P.png" alt=""></p>
<p><strong>实例：3. 显示命令的所有信息</strong><br>描述：-a选项显示命令的所有信息，包括给定命令的类型及其绝度路径。<br>命令：<br><code>type -a ls</code><br><code>type -a echo</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/type/type-a.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/14/linux/daily-command-touch/</loc>
    <lastmod>2018-06-22T01:56:05.845Z</lastmod>
    <data>
        <display>
        <title>Linux touch总结</title>
        <pubTime>2018-06-14T05:12:08.000Z</pubTime>
      
         <content><p>touch命令用来创建文件，也可以更改和修改一个文件的时间戳。<br><a id="more"></a></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>touch命令用来创建文件，也可以更改和修改一个文件的时间戳。Linux中的每个文件都与时间戳相关联，而且每个文件都存储上次访问时间，上次修改时间，上次更改时间的信息。因为，无论何时创建一个新文件，访问或者修改现有文件，时间戳都会被自动更新。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/touch/touch-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>touch [选项] [参数]</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><p>Linux中的文件有三个时间：</p>
<ul>
<li>access time（atime）：访问时间，对一次文件的内容就会更新。例如cat，vi/vim，cp，touch命令。</li>
<li>modification time（mtime）：修改时间，对文件内容修改一次就会更新。例如touch，vi/vim命令。</li>
<li>status time（ctime）：状态改动时间。通过chmod/chown/chgrp等命令更改一次文件属性，通过touch准确地修改时间等，这个时间就会更新。例如mv，touch，chmod/chown/chgrp，vi/vim等命令。</li>
</ul>
<p>touch命令选项：</p>
<ul>
<li>-a，只改变访问时间。</li>
<li>-c，如果文件不存在，那就不创建。</li>
<li>-d，更新访问时间和修改时间。</li>
<li>-m，只改变修改时间。</li>
<li>-r，将参照文件ref_file相应的时间戳作为指定文件file时间戳的新值。</li>
<li>-t，用指定的时间创建文件，格式是[[CC]YY]MMDDhhmm[.SS]。CCYY的范围在1969~2068之内。SS为秒数，范围在0~61之间，这样可以处理闰秒。由于系统的限制，早于1970年1月1日的时间是错误的。</li>
</ul>
<h3 id="示例：1-创建空文件"><a href="#示例：1-创建空文件" class="headerlink" title="示例：1. 创建空文件"></a>示例：1. 创建空文件</h3><p>描述：若文件不存在，使用touch命令可以轻松地创建一个空文件，或是创建多个。如果文件已存在，那么文件的3个时间：修改时间（mtime）、状态改动时间（ctime）和访问时间（atime）都会被更新为当前时间。stat命令可以查看文件时间。<br>命令：<br><code>touch my_one</code><br><code>stat my_one</code><br><code>touch my_one my_two my_three</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/touch/touch.png" alt=""></p>
<h3 id="示例：2-只改变文件的修改时间（mtime）和状态改动时间（ctime）"><a href="#示例：2-只改变文件的修改时间（mtime）和状态改动时间（ctime）" class="headerlink" title="示例：2. 只改变文件的修改时间（mtime）和状态改动时间（ctime）"></a>示例：2. 只改变文件的修改时间（mtime）和状态改动时间（ctime）</h3><p>描述：只改变my_three文件的修改时间为当前时间，同时状态改动时间会在命令执行后更新为当前时间。这个操作并不需要修改文件内容。-m选项只更改文件的修改时间。<br>命令：<code>touch -m my_three</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/touch/touch-m.png" alt=""></p>
<h3 id="示例：3-只改变文件访问时间（atime）和状态改动时间（ctime）"><a href="#示例：3-只改变文件访问时间（atime）和状态改动时间（ctime）" class="headerlink" title="示例：3. 只改变文件访问时间（atime）和状态改动时间（ctime）"></a>示例：3. 只改变文件访问时间（atime）和状态改动时间（ctime）</h3><p>描述：只改变my_three文件的访问时间为当前时间，同时状态改动时间会在命令执行后更新为当前时间。如果文件不存在，会创建新的空文件。-a选项只更改文件的访问时间。<br>命令：<code>touch -a my_three</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/touch/touch-a.png" alt=""></p>
<h3 id="示例：4-指定文件的访问时间和修改时间"><a href="#示例：4-指定文件的访问时间和修改时间" class="headerlink" title="示例：4. 指定文件的访问时间和修改时间"></a>示例：4. 指定文件的访问时间和修改时间</h3><p>描述：同时设置文件的访问时间和修改时间为指定时间，同时会更新状态改变时间为当前命令执行后的时间。如果文件不存在，会创建新的空文件。-d选项同时改变文件的访问时间和修改时间。<br>命令：<code>touch -d &quot;2018-06-14 14:00:00&quot; my_three</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/touch/touch-d.png" alt=""></p>
<p>描述：将my_three文件的访问时间和修改时间修改成两天前。touch还支持像date命令那样修改文件的时间。<br>命令：<code>touch -d &quot;2 days ago&quot; my_three</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/touch/touch-d-date.png" alt=""></p>
<h3 id="示例：5-避免创建新文件"><a href="#示例：5-避免创建新文件" class="headerlink" title="示例：5. 避免创建新文件"></a>示例：5. 避免创建新文件</h3><p>描述：更新atime、ctime、mtime，如果文件不存在，-c选项不会创建新的文件。<br>命令：<code>touch -c leena</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/touch/touch-a.png" alt=""></p>
<h3 id="示例：6-使用另一个文件的时间戳"><a href="#示例：6-使用另一个文件的时间戳" class="headerlink" title="示例：6. 使用另一个文件的时间戳"></a>示例：6. 使用另一个文件的时间戳</h3><p>描述：-r选项将my_three的时间戳作为my_two文件的时间戳的新值，这两个文件有相同的时间戳。<br>命令：<code>touch -r my_three my_two</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/touch/touch-r.png" alt=""></p>
<h3 id="示例：7-使用指定的时间戳创建一个文件"><a href="#示例：7-使用指定的时间戳创建一个文件" class="headerlink" title="示例：7. 使用指定的时间戳创建一个文件"></a>示例：7. 使用指定的时间戳创建一个文件</h3><p>描述：将my_four文件的时间戳指定为1997年6月14日17点00分55秒。时间格式是[[CC]YY]MMDDhhmm[.SS]。<br>命令：<code>touch -t 199706141700.55 my_four</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/touch/touch-t.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/11/linux/daily-command-top/</loc>
    <lastmod>2018-06-22T01:55:28.666Z</lastmod>
    <data>
        <display>
        <title>Linux top总结</title>
        <pubTime>2018-06-11T04:20:23.000Z</pubTime>
      
         <content><p>top命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统西能和运行信息的使用工具。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>top [选项]</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>top命令用来显示Linux的处理器活动和内核实时管理的任务。它会显示正在使用的处理器和内存以及运行进程等其他信息。</p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-b：以批处理模式操作。</li>
<li>-c：显示完整的命令。</li>
<li>-d：屏幕刷新间隔时间。</li>
<li>-I：忽略失效过程。</li>
<li>-s：保密模式。</li>
<li>-S：累积模式。</li>
<li>-i&lt;时间&gt;：设置间隔时间。</li>
<li>-u&lt;用户名&gt;：指定用户名。</li>
<li>-p&lt;进程号&gt;：指定进程。</li>
<li>-n&lt;次数&gt;：循环显示的次数。</li>
</ul>
<h2 id="top交互命令"><a href="#top交互命令" class="headerlink" title="top交互命令"></a>top交互命令</h2><p>在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。</p>
<ul>
<li>h：显示帮助画面，给出一些简短的命令总结说明。</li>
<li>k：终止一个进程。</li>
<li>i：忽略闲置和僵死进程，这是一个开关式命令。</li>
<li>q：退出程序。</li>
<li>r：重新安排一个进程的优先级别。</li>
<li>S：切换到累计模式。</li>
<li>s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s。</li>
<li>f或者F：从当前显示中添加或者删除项目。</li>
<li>o或者O：改变显示项目的顺序。</li>
<li>l：切换显示平均负载和启动时间信息。</li>
<li>m：切换显示内存信息。</li>
<li>t：切换显示进程和CPU状态信息。</li>
<li>c：显示进程启动时的完整路径和程序名。</li>
<li>M：根据驻留内存大小进行排序。</li>
<li>P：根据CPU使用百分比大小进行排序。</li>
<li>T：根据时间/累计时间进行排序。</li>
<li>w：将当前设置写入~/.toprc文件中。</li>
</ul>
<h2 id="界面解释"><a href="#界面解释" class="headerlink" title="界面解释"></a>界面解释</h2><p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-field.png" alt=""></p>
<p>统计信息区前五行是系统整体的统计信息。<br><strong>系统运行时间和平均负载</strong><br>第一行是任务队列信息，同uptime命令的执行结果，可以使用l命令切换uptime的显示。其内容如下：</p>
<ul>
<li>08:42:05：当前时间。</li>
<li>up 8 days, 11:56：系统运行时间。</li>
<li>1 users：当前登录用户数。</li>
<li>load average: 0.10, 0.04, 0.05：系统负载，即任务队列平均长度。分别为1、5、15min前到现在平均值。</li>
</ul>
<p><strong>进程</strong><br>第二行为进程信息。内容如下：</p>
<ul>
<li>62 total：进程总数[键入H可查看线程数]。</li>
<li>2 running：正在运行的进程。</li>
<li>60 sleeping：睡眠进程。</li>
<li>0 stopped：停止的进程。</li>
<li>0 zombie：僵尸进程数。</li>
</ul>
<p><strong>CPU状态</strong><br>第三行为CPU状态信息，当有多个CPU时，这些内容可能会超过两行。内容如下：</p>
<ul>
<li>us, user：运行(未调整优先级的) 用户进程的CPU百分比。</li>
<li>sy，system：运行内核进程的CPU百分比。</li>
<li>ni，niced：运行已调整优先级的用户进程的CPU百分比。</li>
<li>wa，IO wait：用于等待IO完成的CPU百分比。</li>
<li>hi：处理硬件中断的CPU百分比。</li>
<li>si：处理软件中断的CPU百分比。</li>
<li>st：这个虚拟机被hypervisor偷去的CPU百分比。（译注：如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）。</li>
</ul>
<p><strong>内存使用</strong><br>倒数第2、3行为内存相关信息，内存显示可以用m命令切换：</p>
<ul>
<li>KiB Mem: 1883724 total, 187736 free：分别是物理内存总量、空闲内存总量。</li>
<li>120536 used, 1575452 buffers：使用物理内存总量、用作内核缓存内存量。</li>
<li>KiB Swap: 1044476 total, 713552 used：分别是交换分区量、使用交换分区总量。</li>
<li>330924 free, 10052032 cached：空闲交换区总量、缓存交换区总量。</li>
</ul>
<p><strong>字段/列</strong><br>最后一行则是进程相关的资源占用信息：</p>
<ul>
<li>PID：进程的ID，进程的唯一标识符。</li>
<li>USER：进程所有者的实际用户名。</li>
<li>PR：进程的优先级别，范围0-39，越小越优先被执行。</li>
<li>NI：nice值。范围-20-19，负值表示高优先级，正值表示低优先级。在top里，PR-NI=20，默认启动一个进程，nice是0。</li>
<li>VIRT：进程占用的虚拟内存。</li>
<li>RES：进程占用的物理内存。</li>
<li>SHR：进程使用的共享内存。</li>
<li>S：进程的状态。<ul>
<li>D：表示不可终端的睡眠状态。</li>
<li>R：表示正在运行。</li>
<li>S：表示休眠。</li>
<li>T：表示作业控制信号下已停止。</li>
<li>t：表示在调试状态的停止。</li>
<li>Z：表示僵死状态。</li>
</ul>
</li>
<li>%CPU：自从上一次更新到现在任务所使用的CPU使用率。</li>
<li>%MEM：进程使用的物理内存和总内存的百分比。</li>
<li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值，精确到百分之一秒。</li>
<li>COMMAND：进程启动命令名称。</li>
</ul>
<h2 id="交互命令实例"><a href="#交互命令实例" class="headerlink" title="交互命令实例"></a>交互命令实例</h2><p><strong>实例：1. h：帮助</strong><br>描述：在top状态下，按h键或者?键显示交互命令的帮助菜单。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-h.png" alt=""></p>
<p><strong>实例：2. 手动刷新</strong><br>描述：在top状态下，按空格或者回车进行手动刷新。top命令默认在一个特定间隔（3秒）后刷新显示。</p>
<p><strong>实例：3. A：切换交替显示模式</strong></p>
<p>描述：在top状态下，按A键，可以在全屏和交替模式间切换。在交替模式下会显示4个窗口。</p>
<ul>
<li>Def（默认字段组）</li>
<li>Job（任务字段组）</li>
<li>Mem（内存字段组）</li>
<li>Usr（用户字段组）</li>
</ul>
<p>这四组字段共有一个独立的可配置的概括区域和它自己的可配置任务区域。4个窗口中只有一个窗口是当前窗口。当前窗口的名称显示在左上方。只有当前窗口才会接受你键盘交互命令。<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-A.png" alt=""><br>可以用a和w在4个窗口间切换，a移到后一个窗口，w移到前一个窗口。用g命令可以输入一个数字来选择当前窗口。<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-switch.png" alt=""></p>
<p><strong>实例：4. B：粗体显示</strong><br>描述：在top状态下，按B键，会将一些重要信息会以加粗字体显示。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-B.png" alt=""></p>
<p><strong>实例：5. d或s：设置显示的刷新间隔</strong><br>描述：在top状态下，按d键或者s键，设置显示的刷新间隔为1秒。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-d-s.png" alt=""></p>
<p><strong>实例：6. l、t、m：切换负载、任务、内存信息的显示</strong><br>描述：相应地切换顶部的平均负载、任务/CPU状态和内存信息的概况显示。<br>输出：<br>不显示平均负载：<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-l.png" alt=""><br>不显示CPU概况：<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-t.png" alt=""><br>不显示内存和交换内存概况：<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-m-noword.png" alt=""><br>可以切换图形显示：<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-m-graph.png" alt=""><br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-m-graph-bold.png" alt=""><br>均不显示：<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-l-t-m-none.png" alt=""></p>
<p><strong>实例：7. f：字段管理</strong><br>描述：在top状态下，按f键进入字段管理界面。d键选择要显示的字段，用*标记的是已选择的。上下光标键在字段内导航，左光标键可以选择字段，右光标键进入排序状态，此时按上下光标键可以进行上下移动，回车确认。s键设置当前排序的字段，q或Esc键退出。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-f.png" alt=""></p>
<p><strong>实例：8. R：反向排序</strong><br>描述：在top状态下，按R键切换反向/常规排序。</p>
<p><strong>实例：9. c：切换显示命令名称和完整命令行</strong><br>描述：在top状态下，按c键，切换是否显示进程启动时的完整路径和程序名。也可以使用如下命令行。<br>命令：<code>top -c</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-c.png" alt=""></p>
<p><strong>实例：10. i：空闲任务</strong><br>描述：在top状态下，按i键，切换显示空闲任务。<br>输出：<br>不显示空闲任务：<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-i.png" alt=""></p>
<p><strong>实例：11. V：树视图</strong><br>描述：在top状态下，按V键，切换树视图。<br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-V.png" alt=""></p>
<p><strong>实例：12. z：切换彩色显示</strong><br>描述：在top状态下，按z键，切换彩色，即打开或关闭彩色显示。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-z-normal.png" alt=""></p>
<p><strong>实例：13. Z：改变配色</strong><br>描述：在top状态下，按Z键，显示一个改变top命令的输出颜色的屏幕。可以为8个任务区域选择8种颜色。<br>输出：<br>设置修改：<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-Z.png" alt=""><br>显示效果：<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-Z-show.png" alt=""></p>
<p><strong>实例：14. 按照内存使用大小排序</strong><br>描述：在top状态下，按shift+m，可以按照内存使用大小排序进程。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-M.png" alt=""></p>
<p><strong>实例：15. x、y：切换高亮信息</strong><br>描述：在top状态下，按x键将排序字段高亮显示（纵列）；按y键将运行进程高亮显示（横行）。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-x-y.png" alt=""></p>
<p><strong>实例：16. u：特定用户的进程</strong><br>描述：在top状态下，按u键将会提示输入用户名，输入首显示特定用户的进程。空白将会显示全部用户。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-u.png" alt=""></p>
<p><strong>实例：17. n或#：任务的数量</strong><br>描述：在top状态下，按n键或者#键可以设置最大显示的任务数量。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-n-#.png" alt=""></p>
<p><strong>实例：18. k：结束任务</strong><br>描述：在top状态下，按k键输入PID后，发送信号给任务（通常是结束任务）。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-k.png" alt=""></p>
<p><strong>实例：19. r：重新设置优先级</strong><br>描述：在top状态下，按r键输入-20~19范围中的数字后，重新设置一个任务的调度优先级（nice值）。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-k.png" alt=""></p>
<h2 id="命令行实例"><a href="#命令行实例" class="headerlink" title="命令行实例"></a>命令行实例</h2><p><strong>实例：1. -b：批处理模式</strong><br>描述：-b选项以批处理模式启动top命令，在文件中保存输出时是很有用的。</p>
<p><strong>实例：2. -c：命令/程序名 触发:</strong><br>描述：显示进程启动时的完整路径和程序名。</p>
<p><strong>实例：3. -d：设置延迟间隔</strong><br>描述：设置top的显示间隔(以秒计)。<br>命令：<code>top -d 1</code></p>
<p><strong>实例：4. -i：切换显示空闲进程</strong><br>命令：<code>top -i</code></p>
<p><strong>实例：5. -n：特定重复次数后退出</strong><br>描述：top输出保持刷新，直到按q键或者到达指定次数。下面的命令将在10次重复之后自动退出。<br>命令：<code>top -n 10</code></p>
<p><strong>实例：6. -p：监控特定的PID</strong><br>描述：-p选项监控指定的PID。PID的值为0将被作为top命令自身的PID。<br>命令：<code>top -p 0</code></p>
<p><strong>实例：7. -u或-U: 用户名或者UID</strong><br>描述：可以用这些选项浏览特定用户的进程。用户名或者UID可以在选项中指定。-p、-u和-U选项是互斥的，同时只可以使用这其中一个选项。试图组合使用这些选项时，会得到一个错误:<br>命令：<code>top -p 1248 -u root</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/top/top-U-p-u-error.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/09/linux/daily-command-tee/</loc>
    <lastmod>2018-06-22T01:55:13.908Z</lastmod>
    <data>
        <display>
        <title>Linux tee总结</title>
        <pubTime>2018-06-09T10:15:07.000Z</pubTime>
      
         <content><p>tee命令把输出的一个副本输送到标准输出，另一个副本拷贝到相应的文件中。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>tee [选项] [文件]</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>tee命令把输出的一个副本输送到标准输出，另一个副本拷贝到相应的文件中。<br>tee命令从标准输入中复制到每一个文件，并输出到标准输出。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-a或–append：向文件中重定向时使用追加模式。</li>
<li>-i或–ignore-interrupts：忽略中断（interrupt）信号。</li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 输出的标准输出的同时输出到文件</strong><br>描述：将ping的内容输出到标准输出，同时也输出到output.txt文件中。<br>命令：<code>ping yahoo.com | tee output.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/tee/tee.png" alt=""></p>
<p><strong>实例：2. 向输出文件追加内容</strong><br>描述：将ping的内容输出到标准输出，同时也以追加的方式输出到output.txt文件中。<br>命令：<code>ping baidu.com | tee -a output.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/tee/tee-a.png" alt=""></p>
<p><strong>实例：3. 输出到标准输出两次</strong><br>描述：输出到标准输出两次，-表示标准输出。<br>命令：<code>ls | tee -</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/tee/tee--.png" alt=""></p>
<p><strong>实例：4. 同时写入多个文件</strong><br>描述：将ping的内容输出到标准输出两次，同时也以追加的方式输出到output.txt文件中。<br>命令：<code>ping yahoo.com | tee output.txt log.txt -</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/tee/tee-multiple--.png" alt=""></p>
<p><strong>实例：5. tee命令的输出内容直接作为另一个命令的输入内容</strong><br>描述：列出当前目录下的文件，同时写入到output.txt文件中，然后再将内容通过管道重定向给wc命令统计行数。<br>命令：<code>ls -ilh | tee output.txt | wc -l</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/tee/tee-other.png" alt=""></p>
<p><strong>实例：6. 提升文件写入权限</strong><br>描述：使用Vim编辑器打开文件，并且做了跟多更改，然后当尝试保存修改会得到一个报错，那是一个root所拥有的文件，意味着你需要使用sudo权限保存修改。在Vim内使用tee命令来提高权限。<br>命令：<code>:w !sudo tee %</code><br>上述命令需要输入root密码，然后就可以保存修改了。</p>
<p><strong>实例：7. 忽视中断</strong><br>描述：-i命令行选项使tee命令忽视通常由ctrl+c组合键发起的中断信号（SIGINT）。tee命令可以优雅的退出。<br>命令：<code>ping yahoo.com | tee -i output.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/tee/tee-i.png" alt=""></p>
<p><strong>实例：8. 把标准错误输出也保存到文件</strong><br>描述：使用tee命令把标准错误输出也保存到文件。<br>命令：<code>ls &quot;*&quot; 2&gt;&amp;1 | tee ls.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/tee/tee-error.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/13/linux/daily-command-tail/</loc>
    <lastmod>2018-06-22T01:54:41.175Z</lastmod>
    <data>
        <display>
        <title>Linux tail总结</title>
        <pubTime>2018-06-13T03:31:58.000Z</pubTime>
      
         <content><p>tail命令用于显示来自文件或者管道结尾（最新实时）的内容。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>tail命令用于显示来自文件或者管道结尾（最新实时）的内容。默认情况下，tail命令显示文件的最后10行内容。支持多文件处理，在输出每个文件之前都有一个标识文件名的标题。如果未指定文件，或者文件被指定为破折号「-」，则tail命令从标准输入中读取。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/tail/tail-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>tail [选项] [文件(s)]</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>–retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；</li>
<li>-c<n>或——bytes=<n>：输出文件尾部的N（N为整数）个字节内容；</n></n></li>
<li>-f&lt;name/descriptor&gt;或；–follow<nameldescript>：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；</nameldescript></li>
<li>-F：与选项“-follow=name”和“–retry”连用时功能相同；</li>
<li>-n<n>或——line=<n>：输出文件的尾部N（N位数字）行内容。</n></n></li>
<li>–pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；</li>
<li>-q或——quiet或——silent：当有多个文件参数时，不输出各个文件名；</li>
<li>-s&lt;秒数&gt;或——sleep-interal=&lt;秒数&gt;：与“-f”选项连用，指定监视文件变化时间隔的秒数；</li>
<li>-v或——verbose：当有多个文件参数时，总是输出各个文件名；</li>
<li>–help：显示指令的帮助信息；</li>
<li>–version：显示指令的版本信息。tail -f  /usr/local/webserver/tomcat/logs/catalina.out</li>
</ul>
<h2 id="实用示例"><a href="#实用示例" class="headerlink" title="实用示例"></a>实用示例</h2><p><strong>实例：1. 查看文件的后十行</strong><br>描述：查看words文件的后10行。默认情况下，tail命令显示文件的最后10行内容。<br>命令：<code>tail letter</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/tail/tail.png" alt=""></p>
<p><strong>实例：2. 限制要显示的行数</strong><br>描述：显示words文件的最后3行。-n选项限制要显示的行数。<br>命令：<br><code>tail -n 3 letter</code><br><code>tail -3 letter</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/tail/tail-n.png" alt=""></p>
<p>描述：显示words文件的最后1000行。可以在num后加上后缀，例如：b，KB，K等等。<br>命令：<code>tail -n 1K /usr/share/dict/words</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/tail/tail-n-1K.png" alt=""></p>
<p><strong>实例：3. 监视日志文件</strong><br>描述：显示words文件（日志文件）的最后10行，并且一直监视它，一旦有新的内容加入，就立即打印出来。-f选项将监视文件的更新。<br>命令：<code>tail -f /usr/share/dict/words</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/tail/tail-f-CTRL-C.png" alt=""><br>注意：tail -f将一直监视着文件，要停止它，按CTRL+C。</p>
<p><strong>实例：4. 监视日志文件并只输出指定内容</strong><br>描述：tail将监视access.log文件，它将通过管道传送access.log的最后十行和任何新加入到文件中的行给grep。grep读取从tail传送过来的输出，只打印出包含IP地址10.10.10.10的那些行。<br>命令：<code>tail -f access.log | grep 10.10.10.10</code></p>
<p><strong>实例：5. 监视日志文件并指定刷新间隔</strong><br>描述：tail将监视access.log文件，其监视的时间间隔为5秒。<br>命令：<code>tail -f -s 5 access.log</code></p>
<p><strong>实例：6. tail -f的代替命令</strong><br>描述：与tail -f效果相同的命令是less。使用下面命令打开文件后，按下shift+f，就与tail -f的效果相同了。<br>命令：<br><code>less /usr/share/dict/words</code><br>press<code>SHIFT+F</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/tail/tail-less.png" alt=""></p>
<p><strong>实例：7. 限制要显示的字节数</strong><br>描述：显示words文件的最后32个字节。-c选项限制显示的字节数。<br>命令：<code>tail -c 32 /usr/share/dict/words</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/tail/tail-c.png" alt=""></p>
<p><strong>实例：8. 显示多个文件</strong><br>描述：显示多个文件的前十行，同时标题会显示哪个文件正在显示。<br>命令：<code>tail /usr/share/dict/words /usr/share/dict/propernames</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/tail/tail-multi-file.png" alt=""></p>
<p><strong>实例：9. 多个文件不显示标题</strong><br>描述：显示多个文件的前3行，不显示正在显示文件的标题。<br>命令：<code>tail -n 3 -q /usr/share/dict/words /usr/share/dict/propernames</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/tail/tail-q.png" alt=""></p>
<p><strong>实例：10. 与管道配合使用</strong><br>描述：显示/etc/目录下的最近修改的前5个文件或文件夹。tail命令可以接受其他命令通过管道传送过来的信息。<br>命令：<code>cat letter | tail -n 5</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/tail/tail-pipe.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/11/linux/daily-command-sort/</loc>
    <lastmod>2018-06-22T01:53:57.512Z</lastmod>
    <data>
        <display>
        <title>Linux sort总结</title>
        <pubTime>2018-06-11T10:40:13.000Z</pubTime>
      
         <content><p>sort命令用于对单个或多个文本文件内容进行排序。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>sort命令将许多不同的域按不同的列顺序分类。sort命令以空格作为字段分隔符，将一行分割为多个关键字对文件进行排序。需要注意的是sort命令并不对文件内容进行实际的排序(即文件内容没有修改)，只是将文件内容按有序输出。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>sort -cmu -o output_file [other_options] +pos1 +pos2 input_files</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-c：检查文件是否已经按照顺序排序。</li>
<li>-m：将几个排序号的文件进行合并。</li>
<li>-u：删除所有重复行。</li>
<li>-o&lt;输出文件&gt;：将排序后的结果存入指定的文件。</li>
<li>-b：忽略每行前面开始出的空格字符。</li>
<li>-h：人类可阅读的格式。</li>
<li>-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</li>
<li>-f：排序时，将小写字母视为大写字母。</li>
<li>-i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</li>
<li>-M：将前面3个字母依照月份的缩写进行排序。</li>
<li>-n：按照数值的大小排序。</li>
<li>-r：以相反的顺序来排序。</li>
<li>-t&lt;分隔字符&gt;：指定排序时所用的栏位分隔字符。</li>
<li>+&lt;起始栏位&gt;-&lt;结束栏位&gt;：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：0. 测试文件</strong><br>描述：下面是device_sort的清单，包含了用户设备登录次数情况，各域为：（1）用户ID，（2）手机系统版本，（3）登录访问次数。域分隔符为冒号。域号从0开始，第1列用户ID为域0，即分类键0，以此类推。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-origin-file.png" alt=""></p>
<p><strong>实例：1. 文件是否已分类</strong><br>描述：检查device文件的域用户ID是否已经有序。sort不加任何参数默认以域0（也就是第一列）进行排序，-c选项检查文件是否已按某种顺序排序。<br>命令：<code>sort -c device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-origin-file.png" alt=""></p>
<p><strong>实例：2. 使用分隔符</strong><br>描述：将device用:作为域分隔符分类，然后按第一列进行排序。实际上读文件时sort操作将行中各域进行比较，这里只返回基于第一域sort的结果。<br>命令：<code>sort -t : device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-t.png" alt=""></p>
<p><strong>实例：3. 排序求逆</strong><br>描述：反转实例2中的排序结果。这里先按照第一列进行排序，然后反转其结果。<br>命令：<code>sort -t: -r device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-r.png" alt=""></p>
<p><strong>实例：4.  使用选项k按指定列排序</strong><br>描述：使用选项k指定第1列进行排序。<br>命令：<code>sort -k1 -t: device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-k.png" alt=""></p>
<p><strong>实例：5. 数值域排序</strong></p>
<p>描述：使用n选项指明对数值内容进行排序，否则会按字符串从第一个字符开始进行比较。<br>命令：<code>sort -nk3 -t: device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-n.png" alt=""></p>
<p><strong>实例：6. 唯一性排序</strong></p>
<p>描述：使用u选项过滤所有重复的行，每个重复的行只显示一次。<br>命令：<code>sort -u -t: device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-u.png" alt=""></p>
<p><strong>实例：7. 两个文件进行排序、合并，并且删除重复行</strong></p>
<p>描述：两个文件进行排序、合并，并且删除重复行。<br>命令：<code>sort -u device device2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-u-merge.png" alt=""></p>
<p><strong>实例：8. pos用法</strong></p>
<p>格式：<code>F[.C][OPTS][,F[.C][OPTS]]</code><br>解释：指定排序域开始和结束的位置，F是字段的序号，C是字符的序号，两者初始都是1，结束位置可以不指定，默认是到行结束位置。如果-t和-b选项都没有指定，那么字段中的字符从前面的空白开始计数。OPTS由一个或多个单个字母排序的选项[bdfgiMhnRrV]，它们将重写全局排序选项，如果没有排序键被指定，sort就会以一整行作为键。-b选项去除每个键的前导空白。</p>
<p>假设有五列字段。<br>-k 2：表示从第二列开始到最后一列作为排序的关键字。<br>-k 2,5：表示从第二列开始到第五列作为排序的关键字。<br>-k 2,2：表示仅以第二列作为排序的关键字。<br>-k 4 -k 5：-k5是多余的。<br>-k 2,2 -k 1,1：先以第二列进行排序，再以第一列排序。<br>-k 2.2,2.5 -k 4.3,4.5：先以第二列的第二个字符开始到第五个字符进行排序，然后先以第四列的第三个字符开始到第五个字符进行排序。</p>
<p>格式：<code>sort +field_number .characters_in</code><br>描述：从第三列的第二个字符开始排序。<br>命令：<code>sort -k3.2 -t: device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-pos.png" alt=""></p>
<p>描述：对/root目录执行ls -l的命令，其结果通过管道传递给sort进行排序，先以第二列排序，然后第五列，最后是第九列倒序。<br>命令：<code>ls -l /root | sort -k 2,2n -k 5,5n -r -k 9,9</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-k-pos.png" alt=""></p>
<p><strong>实例：9. head和tail与sort配合使用</strong></p>
<p>格式：<code>sort +field_number .characters_in</code><br>描述：以第三列的数值形式进行排序，从结果中抽取前3条和倒数3条记录。<br>命令：<br><code>sort -nk3 -t: device | head -3</code><br><code>sort -nk3 -t: device | tail -3</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-head-tail.png" alt=""></p>
<p><strong>实例：10. awk与sort配合使用</strong></p>
<p>描述：将sort结果用awk进行加一点附加信息。<br>命令：<code>sort -nk3 -t: device | tail -1 | awk -F: &#39;{print $1&quot;--&quot;$2&quot;--&quot;$3}&#39;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-awk.png" alt=""></p>
<p><strong>实例：11. 两个输入文件进行sort，然后把它们连接成一行</strong><br>描述：创建两个文件，并用数据填充，然后对这两个文件排序并连接。<br>命令：<br><code>echo -e &quot;5 Reliable\n2 Fast\n3 Secure\n1 open-source\n4 customizable&quot; &gt; file1.txt</code><br><code>echo -e &quot;3 RedHat\n1 Debian\n5 Ubuntu\n2 Kali\n4 Fedora&quot; &gt; file2.txt</code><br><code>join &lt;(sort -n file1.txt) &lt;(sort file2.txt)
1 open-source Debian</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-join.png" alt=""></p>
<p><strong>实例：12. 将两个分类文件合并</strong></p>
<p>描述：device_sorted和device_sorted2是两个已排好序的文件，文件合并前，它们必须以被分类。<br>命令：<code>sort -t: -m -k1 device_sorted device_sorted2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-merge.png" alt=""></p>
<p><strong>实例：13. 按照月份顺序进行排序</strong></p>
<p>描述：M选项对month.txt文件按照月份顺序进行排序。sort命令需要至少3个字符来确认月份名称。<br>命令：<code>sort -M month.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-M.png" alt=""></p>
<p><strong>实例：14. 把数据整理成方便人们阅读的形式</strong></p>
<p>描述：-h选项将把数据整理成方便人们阅读的形式，比如1K、2M、3G、2T，这里面的K、G、M、T代表千、兆、吉、梯。<br>命令：<code>ls -lh /root | sort -h -k5</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-h.png" alt=""></p>
<p><strong>实例：15. 随机化结果</strong><br>描述：-R选项将结果进行hash随机化排序。<br>命令：<code>ls -lh /root | sort -k5 -R</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sort/sort-Random.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/23/linux/daily-command-sed/</loc>
    <lastmod>2018-06-22T01:53:42.734Z</lastmod>
    <data>
        <display>
        <title>Linux sed总结</title>
        <pubTime>2018-06-23T08:54:10.000Z</pubTime>
      
         <content><p>sed命令一个流式编辑器，它可以对文本流、指定文件集或标准输入进行文本编辑。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>sed [选项] &#39;命令&#39; 文本</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>sed命令是stream editor（流式编辑器）的缩写，它可以对文本流、指定文件集或标准输入进行文本编辑。sed编辑器默认情况下没有破坏性，所有的输出都被打印到屏幕上。并且它不会修改文件，除非使用shell重定向来保存输出结果。<br>sed是一个强大的文本过滤工具。使用sed可以从文件或字符串中抽取所需信息。<br>sed命令总是以单个字母开头。<br>sed多数命令允许在前面加个地址。该地址用于指定输入流的哪一行被编辑，如果省略，默认是对所有行都进行编辑。</p>
<h2 id="sed正则表达式"><a href="#sed正则表达式" class="headerlink" title="sed正则表达式"></a>sed正则表达式</h2><p>表1：sed的正则表达式元字符</p>
<table>
<thead>
<tr>
<th style="text-align:left">元字符</th>
<th style="text-align:left">功 能</th>
<th style="text-align:left">示 例</th>
<th style="text-align:left">示例的匹配对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">行首定位符</td>
<td style="text-align:left">/^iweeek/</td>
<td style="text-align:left">匹配所有以iweeek开头的行</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">行尾定位符</td>
<td style="text-align:left">/iweeek$/</td>
<td style="text-align:left">匹配所有以iweeek结尾的行</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">匹配除换行外的单个字符</td>
<td style="text-align:left">/i…k/</td>
<td style="text-align:left">匹配包含字符i、后跟三个任意字符、再跟字母k的行</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">匹配零个或多个前导字符</td>
<td style="text-align:left">/*iweeek/</td>
<td style="text-align:left">匹配在零个或多个空格紧跟着模式iweeek的行</td>
</tr>
<tr>
<td style="text-align:left">[]</td>
<td style="text-align:left">匹配指定字符组内任一字符</td>
<td style="text-align:left">/i[Ww]eeek/</td>
<td style="text-align:left">匹配包含iweeek或iWeeek的行</td>
</tr>
<tr>
<td style="text-align:left">[^]</td>
<td style="text-align:left">匹配不在指定字符组内任一字符</td>
<td style="text-align:left">/[^A-HJ-Z]weeek/</td>
<td style="text-align:left">匹配包含weeek，但weeek之前的那个字符不在A至H或J至Z间的行</td>
</tr>
<tr>
<td style="text-align:left">(..)</td>
<td style="text-align:left">保存已匹配的字符</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">保存查找串以便在替换串中引用</td>
<td style="text-align:left">s/iweeek/**&amp;**/</td>
<td style="text-align:left">符号&amp;代表查找串。字符串iweeek将替换前后各加了两个**的引用，即iweeek变成**iweeek**</td>
</tr>
<tr>
<td style="text-align:left">\&lt;</td>
<td style="text-align:left">词首定位符</td>
<td style="text-align:left">/\&lt;iweeek/</td>
<td style="text-align:left">匹配包含以iweeek开头的单词的行</td>
</tr>
<tr>
<td style="text-align:left">\&gt;</td>
<td style="text-align:left">词尾定位符</td>
<td style="text-align:left">/iweeek\&gt;/</td>
<td style="text-align:left">匹配包含iweeek结尾的单词的行</td>
</tr>
<tr>
<td style="text-align:left">x\{m\}</td>
<td style="text-align:left">连续m个x</td>
<td style="text-align:left">/o\{5\}/</td>
<td style="text-align:left">分别匹配出现连续5个字母o的行</td>
</tr>
<tr>
<td style="text-align:left">x\{m,\}</td>
<td style="text-align:left">至少m个x</td>
<td style="text-align:left">/o\{5,\}/</td>
<td style="text-align:left">匹配至少5个连续的o的行</td>
</tr>
<tr>
<td style="text-align:left">x\{m,n\}</td>
<td style="text-align:left">至少m个x，但不超过n个x</td>
<td style="text-align:left">/o\{5,10\}/</td>
<td style="text-align:left">匹配5~10个连续的o的行</td>
</tr>
</tbody>
</table>
<h2 id="sed常用选项"><a href="#sed常用选项" class="headerlink" title="sed常用选项"></a>sed常用选项</h2><p>表2：sed的常用选项</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-n</td>
<td style="text-align:left">不产生命令输出，使用print命令来完成输出</td>
</tr>
<tr>
<td style="text-align:left">-e</td>
<td style="text-align:left">执行多个命令。在处理输入时，将script中指定的命令添加到已有的命令中，且命令顺序会影响结果</td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td style="text-align:left">执行多个命令。在处理输入时，将file中指定的命令添加到已有的命令中</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">使用扩展正则</td>
</tr>
<tr>
<td style="text-align:left">-i</td>
<td style="text-align:left">直接修改文档读取的内容，不在屏幕上输出</td>
</tr>
</tbody>
</table>
<h2 id="sed使用地址定位"><a href="#sed使用地址定位" class="headerlink" title="sed使用地址定位"></a>sed使用地址定位</h2><p>sed命令在没有给定位置时，默认会处理所有行。<br>sed支持行寻址模式，在sed编辑器中有两种形式的行寻址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[address]command</span><br><span class="line">也可以将特定地址的多个命令</span><br><span class="line">address &#123;</span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">	command3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sed编辑器会将指定的每条命令作用到匹配指定地址的行上。具体有以下几种地址类型：</p>
<ol>
<li>以数字方式的行寻址<ul>
<li>first~step<ul>
<li>first指其实匹配行，step指步长。例如：sed -n 2~5p。含义：从第二行开始匹配，每隔5行匹配一次，即2,7,12……。</li>
</ul>
</li>
<li>$<ul>
<li>表示匹配最后一行。</li>
</ul>
</li>
<li>addr1, addr2<ul>
<li>定址addr1，addr2决定用于对哪些行进行编辑。地址的形式可以是数字、正则表达式或二者的结合。如果没有指定地址，sed将处理输入文件中的所有行。如果定址是一个数字，则这个数字代表行号，如果是逗号分隔的两个行号，那么代表着两行之间的范围（包括两行在内）。范围可以是数字，正则或二者结合。</li>
</ul>
</li>
<li>addr1, +N<ul>
<li>从addr1这行到往下N行匹配，总共匹配N+1行。</li>
</ul>
</li>
<li>addr1, ~N<br>  -</li>
</ul>
</li>
<li>使用模式过滤器的行寻址<ul>
<li>/REGEXP/<ul>
<li>表示匹配正则的那一行，通过//之间的正则表达式来匹配。</li>
</ul>
</li>
<li>\cREGEXPc<ul>
<li>表示匹配正则的那一行，通过\c和c之间的正则表达式来匹配，c可以是任意字符。</li>
</ul>
</li>
</ul>
</li>
<li>组合行寻址<ul>
<li>数字行寻址和模式行寻址组合起来。例如’3,${s/first/First/ s/second/Second/}’</li>
</ul>
</li>
</ol>
<h2 id="sed操作命令"><a href="#sed操作命令" class="headerlink" title="sed操作命令"></a>sed操作命令</h2><p>sed操作命令告诉sed如何处理由地址指定的各输入行。如果没有指定地址，sed就会处理输入的所有的行。</p>
<p>表3：sed命令</p>
<table>
<thead>
<tr>
<th style="text-align:left">命 令</th>
<th style="text-align:left">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a\</td>
<td style="text-align:left">在当前行后添加一行或多行</td>
</tr>
<tr>
<td style="text-align:left">c\</td>
<td style="text-align:left">用新文本修改（替换）当前行中的文本</td>
</tr>
<tr>
<td style="text-align:left">d</td>
<td style="text-align:left">删除行</td>
</tr>
<tr>
<td style="text-align:left">i\</td>
<td style="text-align:left">在当前行之前插入文本</td>
</tr>
<tr>
<td style="text-align:left">h</td>
<td style="text-align:left">把模式空间里的内容复制到暂存缓存区</td>
</tr>
<tr>
<td style="text-align:left">H</td>
<td style="text-align:left">把模式空间里的内容追加到暂存缓存区</td>
</tr>
<tr>
<td style="text-align:left">g</td>
<td style="text-align:left">取出暂存缓冲区里的内容，将其复制到模式空间，覆盖该处原有内容</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td style="text-align:left">取出暂存缓冲区里的内容，将其复制到模式空间，追加在原有内容后面</td>
</tr>
<tr>
<td style="text-align:left">l</td>
<td style="text-align:left">列出非打印字符</td>
</tr>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">打印行</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left">读入下一输入行，并从下一条命令而不是第一条命令开始处理</td>
</tr>
<tr>
<td style="text-align:left">q</td>
<td style="text-align:left">结束或退出 sed</td>
</tr>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">从文件中读取输入行</td>
</tr>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">对所选行以外的所有行应用命令</td>
</tr>
<tr>
<td style="text-align:left">s</td>
<td style="text-align:left">用一个字符串替换另一个</td>
</tr>
<tr>
<td style="text-align:left">N</td>
<td style="text-align:left">将数据流的下一行加进来创建一个多行组来处理</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:left">删除多行组中的一行</td>
</tr>
<tr>
<td style="text-align:left">P</td>
<td style="text-align:left">打印多行组中的一行</td>
</tr>
</tbody>
</table>
<h2 id="sed工作过程"><a href="#sed工作过程" class="headerlink" title="sed工作过程"></a>sed工作过程</h2><p>sed编辑器逐行处理文件或标准输入，并将输出结果发送到屏幕。sed把当前正在处理的行保存在一个临时缓存区中，这个缓存区称为模式空间或临时缓存。sed处理完模式空间中的行后（即在该行上执行sed命令后），就把该行发送到屏幕上（除非之前有命令删除这一行或取消打印操作）。sed每处理完输入文件的最后一行后，sed便结束运行。sed把每一行都存在称作保持空间的临时缓存区中，对这个副本进行编辑，不会修改或破坏源文件。</p>
<h2 id="报错信息和退出信息"><a href="#报错信息和退出信息" class="headerlink" title="报错信息和退出信息"></a>报错信息和退出信息</h2><p>sed通过返回一个状态值来说明执行的结果。如果执行成功，则返回0，如果不成功，则返回非0整数。</p>
<h2 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h2><h3 id="p命令打印"><a href="#p命令打印" class="headerlink" title="p命令打印"></a><strong>p命令打印</strong></h3><p>描述：第一个命令显示mydata中所有的内容，sed默认读取所有行。第二个命令匹配行内出现first的行，使用p命令打印出来，可见加上默认的输出，出现了重复的两行。第三个例子中-n选项使默认的输出失效，与p命令搭配实现了只输出匹配的行。<br>命令：<br><code>sed &#39;&#39; mydata</code><br><code>sed &#39;/first/p&#39; mydata</code><br><code>sed -n &#39;/first/p&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-p.png" alt=""></p>
<h3 id="d命令删除"><a href="#d命令删除" class="headerlink" title="d命令删除"></a><strong>d命令删除</strong></h3><p>描述：删掉mydata文件中的第3行。<br>命令：<code>sed &#39;3d&#39; mydata</code></p>
<p>描述：删掉mydata文件中包含first的行。使用正则表达式匹配，第二个命令中反斜线后面的字符可以任意。<br>命令：<br><code>sed &#39;/first/d&#39; mydata</code><br>OR<br><code>sed &#39;\?north?d&#39; ceshi</code></p>
<p>描述：删掉mydata文件中的第2~3行。<br>命令：<code>sed &#39;2~3d&#39; mydata</code></p>
<p>描述：删掉mydata文件中的第1和第3行。<br>命令：<code>sed &#39;1,3d&#39; mydata</code></p>
<p>描述：删掉mydata文件中的第1行，之后删除每次间隔两行的行。<br>命令：<code>sed &#39;1,+2d&#39; mydata</code></p>
<p>描述：删掉mydata文件中从第3行开始，直到最后一行。<br>命令：<code>sed &#39;1,$d&#39; mydata</code></p>
<p>描述：删掉mydata文件中从第3行开始，直到最后一行。<br>命令：<code>sed &#39;1,$d&#39; mydata</code></p>
<p>输出：</p>
<h3 id="s替换命令"><a href="#s替换命令" class="headerlink" title="s替换命令"></a><strong>s替换命令</strong></h3><p>替换命令在默认情况下只替换每行中出现的第一处，要让替换命令能够替换一行中不同地方出现的文本，需要使用替换标记：<br>表4：替换标志</p>
<table>
<thead>
<tr>
<th style="text-align:left">标 志</th>
<th style="text-align:left">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数字</td>
<td style="text-align:left">表示替换第几处模式匹配的地方</td>
</tr>
<tr>
<td style="text-align:left">g</td>
<td style="text-align:left">表示在行内进行全局替换</td>
</tr>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">表示将模式空间里的内容打印出来</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:left">表示将替换的结果写入文件</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">表示交换暂存缓冲区与模式空间的内容</td>
</tr>
<tr>
<td style="text-align:left">y</td>
<td style="text-align:left">表示将字符转换为另一字符（不能对正则表达式使用 y 命令）</td>
</tr>
</tbody>
</table>
<p>描述：替换每一行中第2次出现的first变为last。<br>命令：<br><code>echo &quot;first come, first served.&quot; | sed &#39;s/first/last/2&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-number.png" alt=""></p>
<p>描述：替换第一次出现的first变为last。使用g标志可以替换所有匹配的内容。<br>命令：<br><code>echo &quot;first come, first served.&quot; | sed &#39;s/first/last/&#39;</code><br><code>echo &quot;first come, first served.&quot; | sed &#39;s/first/last/g&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-s-g.png" alt=""></p>
<p>描述：替换所有的单词a变为A，正则表达式中的\b仅匹配单词。<br>命令：<code>echo &quot;Fire is a good servant but a bad master.&quot; | sed &#39;s/\ba\b/A/g&#39;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-s-b.png" alt=""></p>
<p>描述：替换fairy文件中所有出现的you变为You，并且打印出这些行。-n选项与标志p结合，告诉sed只打印发生替换的那些行。<br>命令：<code>sed -n &#39;s/you/You/gp&#39; fairy</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-n-s-p.png" alt=""></p>
<p>描述：紧跟在s命令后的字符就是查找串和替换串之间的分隔符。分隔符默认是正斜杠，可以改变为其他字符（换行符，反斜线除外）。这个特点在查找包含字符串中含有正斜杠的例子中很管用，例如查找路径名或生日。<br>命令：<code>echo &quot;Content is better than riches?&quot; | sed &#39;s/\?/./&#39;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-s-any-separator.png" alt=""></p>
<h3 id="模式替代"><a href="#模式替代" class="headerlink" title="模式替代"></a><strong>模式替代</strong></h3><p>描述：使用&amp;来代表替换命令中匹配的模式。这个例子的单词中，以at结尾并且前一个字母任意，所有匹配的单词都将用双引号括起来。<br>命令：<code>echo &quot;The cat sleeps in his hat.&quot; | sed &#39;s/\b.at\b/&quot;&amp;&quot;/g&#39;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-ampersand.png" alt=""></p>
<p>描述：将一个单词来替换一个短语，该单词正好是该短语的子字符串，这个字符串使用了正好使用了通配符。sed用圆括号来定义替换模式中的子模式，在替代模式中使用特殊字符来引用每个子模式。替代字符由反斜线和数字组成，第一个子模式分配字符\1。<br>在替换命令中使用子模式的圆括号时，必须用转义字符将其标记为分组字符而不是普通的圆括号。<br>命令：<br><code>echo &quot;That funny cat is pretty&quot; | sed &#39;s/funny \(.at\)/\1/&#39;</code><br><code>echo &quot;That funny hat is pretty&quot; | sed &#39;s/funny \(.at\)/\1/&#39;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-s-subpattern-substitution.png" alt=""></p>
<p>描述：在大数字中插入逗号。<br>命令：<br><code>echo &quot;12345678&quot; | sed &#39;{
:start
s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/
t start
}&#39;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-split-big-number.png" alt=""></p>
<h3 id="逗号-指定行的范围"><a href="#逗号-指定行的范围" class="headerlink" title="逗号,指定行的范围"></a><strong>逗号,指定行的范围</strong></h3><p>行的范围从文件中的一个地址开始，在另一个地址结束。地址范围可以是行号（例如5,10），正则表达式（例如/cat/,/hat/），或者两者的结合(例如/first/,$)，范围是闭合的，包含开始条件的行和结束条件的行，以及两者之间的行。如果结束条件无法满足，就会一直操作到文件结尾。如果结束条件满足，则继续查找满足开始条件的位置，范围重新开始。$观察下面mydata2文件：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-mydata2.png" alt=""></p>
<p>描述：打印模式2和3之间所有的行。<br>命令：<code>sed -n &#39;/2/,/3/p&#39; mydata2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-2-3.png" alt=""></p>
<p>描述：打印模式1和3之间所有的行。如果1出现在3之后的某一行，则打印的范围从1所在行开始，都下一个3的行货文件的末尾（如果3未出现）。图中第4行到文件结尾都没有再出现过3，因此打印到了文件结尾，在使用d删除的时候尤为要注意这点。<br>命令：<code>sed -n &#39;/1/,/3/p&#39; mydata2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-1-3.png" alt=""></p>
<p>描述：打印第3行开始，到第一个匹配1的行之间的所有行。这里数字行寻址和模式行寻址结合起来用。<br>命令：<code>sed -n &#39;3,/1/p&#39; mydata2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-range-number-pattern.png" alt=""></p>
<p>描述：从第3行开始，到第一个匹配1的行之间的所有行，将各行的行尾（$）替换为字符<em>$。换行符被移到了新的字符串的后面。最后将结果打印出来。<br>命令：`sed -n ‘3,/1/s/$/</em>/p’ mydata2`<br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-range-number-pattern-s.png" alt=""></p>
<h3 id="e命令多重编辑"><a href="#e命令多重编辑" class="headerlink" title="e命令多重编辑"></a><strong>e命令多重编辑</strong></h3><p>-e选项是编辑命令，用于sed执行多个编辑任务的情况下。在下一行开始编辑前，所有的编辑动作将应用到模式缓存区（模式空间）的行上。每个命令可以用单独的-e选项指定，也可以使用连起来写，命令之间用分号隔开。<br>描述：-e选项用于多重编辑，第一重编辑是第2行到第4行被删除，第二重编辑将1替换为one。因为是逐行进行这两行编辑（这两个命令都在模式空间的当前行上执行），所有编辑命令的顺序会影响结果。例如，如果两条命令都执行的是替换，前一次替换会影响后一次替换。<br>命令：<code>sed -e &#39;2,4d&#39; -e &#39;s/1/one/&#39; mydata2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-e.png" alt=""></p>
<h3 id="r从文件中读取编辑器命令"><a href="#r从文件中读取编辑器命令" class="headerlink" title="r从文件中读取编辑器命令"></a><strong>r从文件中读取编辑器命令</strong></h3><p>描述：将大量要处理的sed命令放进一个单独的文件中，使用-f选项来指定文件。在这种情况下，不用在每条命令后放一个分号，sed编辑器知道每行都是一条单独的命令。<br>命令：<code>sed -f script.sed mydata2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-script.png" alt=""></p>
<h3 id="a命令追加"><a href="#a命令追加" class="headerlink" title="a命令追加"></a><strong>a命令追加</strong></h3><p>a命令是追加命令，会将新文本追到到文件中当前行（模式空间中的当前行）的后面。<br>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;[address] command \</span><br><span class="line">new line 1\</span><br><span class="line">new line 2&apos;</span><br><span class="line">file</span><br></pre></td></tr></table></figure>
<p>描述：向含有字符串first行的下一行加入Hello world。<br>命令：<code>sed &#39;/first/a\Hello world&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-a.png" alt=""></p>
<p>描述：向含有模式first行的下一行加入两行，分别是Hello world和Welcome!。如果追加的内容超过一行，则除最后一行外，其他各行都必须以反斜杠结尾。<br>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;/first/a Hello world\</span><br><span class="line">Welcome!</span><br><span class="line">&apos; mydata</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-a-more-line.png" alt=""></p>
<h3 id="i命令插入"><a href="#i命令插入" class="headerlink" title="i命令插入"></a><strong>i命令插入</strong></h3><p>i命令是插入命令，类似于a命令，但不是在当前行后增加文本，而是在当前行前面插入新的文本，即刚读入模式空间的行。</p>
<p>描述：命令i是插入命令。如果在某一行匹配到模式first，就会在该行的上方插入Hello world和反斜杠后面的内容。<br>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;/first/i Hello world\</span><br><span class="line">-------------------</span><br><span class="line">&apos; mydata</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-i.png" alt=""></p>
<h3 id="c命令修改"><a href="#c命令修改" class="headerlink" title="c命令修改"></a><strong>c命令修改</strong></h3><p>c命令是修改命令，它允许修改数据流中整行文本的内容，旧文本被覆盖。<br>描述：将匹配模式first的行修改为新的内容。<br>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;/first/c \</span><br><span class="line">This line is changed.&apos; mydata</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-c.png" alt=""></p>
<h3 id="多行命令"><a href="#多行命令" class="headerlink" title="多行命令"></a><strong>多行命令</strong></h3><p>sed包含三个可用来处理多行文本的特殊命令。</p>
<ul>
<li>N：将数据流中的下一行加进来创建一个多行组。</li>
<li>D：删除多行组中的一行。</li>
<li>P：打印多行组中的一行。</li>
</ul>
<p>单行版n命令（next）表示获取下一行到模式空间内，后续的sed命令都将应用到这新获取的行上。记住，通常sed编辑器在移动到数据流中的下一文本行之前，会在当前行上执行完所有定义好的命令。n命令改变了这个流程。</p>
<p>描述：删掉除最后一个空白行之外的所有空白行。<br>命令：<code>sed &#39;/^$/d&#39; mydata3</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-n.png" alt=""></p>
<p>描述：合并文本行，N命令是n命令的多行版，读取匹配模式之后的下一行之后，替换其中的换行符为空格，将两行文本连成一行。<br>命令：<code>sed &#39;/first/{ N; s/\n/ /}&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-N-append.png" alt=""></p>
<p>描述：查找句中分散在两行中的短语。源文件如下：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-separator-cat.png" alt=""><br>命令：<code>sed &#39; 2N; s/The.ideals/The nature/g&#39; longtext</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-separator.png" alt=""></p>
<p>描述：注意到上面例子中使用了通配符（.）来匹配空格和换行符这两种情况。但当匹配换行符时，sed从字符串中删掉了换行符，导致两行合并成了一行。下面的例子用了两个替换命令来解决这个问题，一个用来匹配短语出现在多行中的情况，一个用来匹配短语出现在单行中的情况。<br>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;2N</span><br><span class="line">s/The ideals/The nature/</span><br><span class="line">s/The\nideals/The\nnature/</span><br><span class="line">&apos; longtext</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-separator-two-way.png" alt=""></p>
<p>// TODO<br>描述：上面的脚本还是有点问题，如果<br>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;2N</span><br><span class="line">s/The ideals/The nature/</span><br><span class="line">s/The\nideals/The\nnature/</span><br><span class="line">&apos; longtext</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-separator-two-way.png" alt=""></p>
<h3 id="y命令转换"><a href="#y命令转换" class="headerlink" title="y命令转换"></a><strong>y命令转换</strong></h3><p>y命令是转换命令，它是唯一可以处理单个字符的sed编辑器命令。字符按照一对一的方式从左到右进行转换。例如y/abc/ABC/，会把小写字母转换成大写字母。</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]y/inchars/ouchars/</span><br></pre></td></tr></table></figure>
<p>描述：将第2和第3行中所有的小写字母转换成大写字母。<br>命令：<code>sed &#39;2,3y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-y.png" alt=""></p>
<p>描述：转换命令是一个全局命令，它会从文本中找到所有指定字符自动进行替换，而不考虑它们出现的位置。<br>命令：<code>echo &quot;This 1 is a test of 1 try.&quot; | sed &#39;y/123/789/&#39;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-y-more-place.png" alt=""></p>
<h3 id="q命令退出"><a href="#q命令退出" class="headerlink" title="q命令退出"></a><strong>q命令退出</strong></h3><p>q命令是退出命令，该命令导致sed程序退出，且不再进行其他的处理。</p>
<p>描述：打印完第3行之后，程序退出。<br>命令：<code>sed &#39;3q&#39; mydata2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-q.png" alt=""></p>
<p>描述：打印到匹配模式again的行后，先用s命令替换again为begin，然后q命令让sed退出。<br>命令：<code>sed &#39;/again/{s/again/begin/; q; }&#39; mydata2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-q-more.png" alt=""></p>
<h3 id="命令打印行号"><a href="#命令打印行号" class="headerlink" title="=命令打印行号"></a><strong>=命令打印行号</strong></h3><p>等号命令会打印行在数据流中的当前行号，行号由数据流中的换行符决定。每出现一个换行符，sed编辑器就认为一行文本结束了。<br>描述：给mydata文件的每行加上行号，行号在当前行的上面一行。<br>命令：<code>sed &#39;=&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-line-number.png" alt=""></p>
<h3 id="l命令打印不可打印的ACSII字符"><a href="#l命令打印不可打印的ACSII字符" class="headerlink" title="l命令打印不可打印的ACSII字符"></a><strong>l命令打印不可打印的ACSII字符</strong></h3><p>l命令（list）可以打印数据流中的文本和不可打印的ASCII字符，任何不可打印的字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命令法，比如\t，开代表制表符。<br>描述：打印制表符。<br>命令：<code>sed -n &#39;l&#39; tab</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-l.png" alt=""></p>
<h3 id="w写入文件"><a href="#w写入文件" class="headerlink" title="w写入文件"></a><strong>w写入文件</strong></h3><p>w命令用来向文件写入行，该命令格式如下：</p>
<p><code>[address]w filename</code></p>
<p>描述：替换所有的单词a变为A，w标志可以将sed执行结果输出到文件中。<br>命令：<code>echo &quot;Fire is a good servant but a bad master.&quot; | sed &#39;s/\ba\b/A/gw sed.out&#39;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-s-w.png" alt=""></p>
<h3 id="r从文件读取数据"><a href="#r从文件读取数据" class="headerlink" title="r从文件读取数据"></a><strong>r从文件读取数据</strong></h3><p>r命令用来将一个独立文件中的数据插入到数据流中，该命令格式如下：<br><code>[address]r filename</code><br>filename参数指定了数据文件的绝对路径或相对路径。读取命令中使用的地址区间只能指定单独一个行号或文本模式地址。sed编辑器会将文件中的文本插入到指定地址后。</p>
<p>描述：将tab文件的内容插入到mydata文件中，具体插入在匹配模式first的行的后面。<br>命令：<code>sed &#39;/first/r tab&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-r.png" alt=""></p>
<p>描述：将tab文件的内容插入到mydata文件中，具体插入在匹配模式first的行的后面。<br>命令：<br><code>sed &#39;/LIST/ {
r detail.txt
d
}</code><br><code>sed -f placehold.sed placehold</code><br>源文件：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-placehold.png" alt=""><br>sed脚本文件：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-placehold-script.png" alt=""><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-placehold-f.png" alt=""></p>
<h3 id="保持空间"><a href="#保持空间" class="headerlink" title="保持空间"></a><strong>保持空间</strong></h3><p>模式空间（pattern space）是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查文本。保持空间（hold space）是sed编辑器的另一块缓冲区域，在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。</p>
<table>
<thead>
<tr>
<th style="text-align:left">命 令</th>
<th style="text-align:left">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">h</td>
<td style="text-align:left">将模式空间复制到保持空间</td>
</tr>
<tr>
<td style="text-align:left">H</td>
<td style="text-align:left">将模式空间追加到保持空间</td>
</tr>
<tr>
<td style="text-align:left">g</td>
<td style="text-align:left">将保持空间复制到模式空间</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td style="text-align:left">将保持空间追加到模式空间</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">交换保持空间与模式空间的内容</td>
</tr>
</tbody>
</table>
<p>描述：用h和g目录将数据在sed编辑器缓冲空间之间移动。<br>命令：<code>sed -n &#39;/first/ { h; p; n; p; g; p }&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-hold-space.png" alt=""></p>
<p>描述：将第一个数据行输出到第二个数据行的后面。<br>命令：<code>sed -n &#39;/first/ { h; n; p; g; p }&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-hold-space-switch.png" alt=""></p>
<h3 id="命令排除"><a href="#命令排除" class="headerlink" title="!命令排除"></a><strong>!命令排除</strong></h3><p>描述：排除匹配模式header的行，感叹号（!)命令用来排除，让原本会起作用的命令不起作用，原本不起作用反而其作用。<br>命令：<code>sed -n &#39;/header/!p&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-exclude.png" alt=""></p>
<p>描述：将文件的内容反转。<br>命令：<code></code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-exclude.png" alt=""></p>
<h3 id="b改变流"><a href="#b改变流" class="headerlink" title="b改变流"></a><strong>b改变流</strong></h3><p>分支（branch）命令b可以基于地址、地址模式或地址区间排除一整块命令。这样就可以对数据流中的特定行执行一组命令。分支（branch）命令b的格式如下：</p>
<p><code>[address]b [label]</code><br>address参数决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置。如果没有加label参数，跳转命令会跳转到脚本的结尾。</p>
<p>描述：分支命令在数据流中的第2行和第3行处跳过了两个替换命令。<br>命令：<code>sed &#39;{2,3b; s/This is/Is this/; s/line./test?/}&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-b.png" alt=""></p>
<p>如果不行直接跳到脚本的结尾，可以为分支命令定义一个要跳转的标签，定义跳转的标签以冒号开始，最多是7个字符长度。要指定标签，加到b命令后即可。标签可以跳过地址匹配出的命令，但任然执行脚本中的其他命令。</p>
<p>描述：如果出现匹配模式first的行，程序应该跳到标签为jump1的脚本行。如果分支命令的模式没有匹配，sed编辑器会继续执行脚本中的命令，包括分支标签后的命令。（所有的s替换命令都会在不匹配分支模式的行上执行）。<br>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;&#123;/first/b jump1; s/This is the/No jump on/</span><br><span class="line">:jump1</span><br><span class="line">s/This is the/Jump here on/&#125;&apos; mydata</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-label.png" alt=""></p>
<p>描述：使用分支标签达到循环的效果。<br>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &apos;&#123;</span><br><span class="line">:start</span><br><span class="line">s/,//1p</span><br><span class="line">b start</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-infinite-loop.png" alt=""></p>
<p>描述：上面的脚本永远不会结束，在分支命令之前指定一个/,/地址模式，如果没有找到匹配，跳转就应该结束。<br>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &apos;&#123;</span><br><span class="line">:start</span><br><span class="line">s/,//1p</span><br><span class="line">/,/b start</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-limit-loop.png" alt=""></p>
<h3 id="t测试命令"><a href="#t测试命令" class="headerlink" title="t测试命令"></a><strong>t测试命令</strong></h3><p>描述：匹配模式first的行，如果匹配上则不会执行第二个替换命令。反之，则执行之。<br>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;&#123;</span><br><span class="line">s/first/matched/</span><br><span class="line">t</span><br><span class="line">s/This is the/No match on/</span><br><span class="line">&#125;&apos; mydata</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-t.png" alt=""></p>
<p>描述：匹配模式first的行，如果匹配上则不会执行第二个替换命令。反之，则执行之。<br>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;&#123;</span><br><span class="line">s/first/matched/</span><br><span class="line">t</span><br><span class="line">s/This is the/No match on/</span><br><span class="line">&#125;&apos; mydata</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-t-limit-loop.png" alt=""></p>
<h3 id="使用包装脚本"><a href="#使用包装脚本" class="headerlink" title="使用包装脚本"></a><strong>使用包装脚本</strong></h3><p>描述：将脚本封装进shell包装脚本（wrapper），执行之前需要赋予执行权限。$1代表从命令行提取第一个参数，在这里就是需要进行反转的文件名。<br>命令：<code>sed -n &#39;{ 1!G; h; $p}&#39; $1</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-reverse-sh.png" alt=""><br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-run-reverse.png" alt=""></p>
<h3 id="重定向sed的输出"><a href="#重定向sed的输出" class="headerlink" title="重定向sed的输出"></a><strong>重定向sed的输出</strong></h3><p>描述：使用$()将sed编辑器命令的输出重定向到一个变量中，以备后用。<br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-script-fact.png" alt=""></p>
<h3 id="加倍行间距"><a href="#加倍行间距" class="headerlink" title="加倍行间距"></a><strong>加倍行间距</strong></h3><p>描述：G命令会简单将保持空间内容附加到模式空间内容后，当启动sed编辑器时，保持空间只有一个空行。将它附加到已有行后面，就在已有行后面创建了一个空白行。<br>命令：<code>sed &#39;G&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-G.png" alt=""></p>
<p>描述：去掉上例中最后一行的空格。$和!结合表示一旦达到文件最后一行，就不执行G命令操作。<br>命令：<code>sed &#39;$!G&#39; mydata</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-G-clean-end.png" alt=""></p>
<h3 id="对可能含有空白行的文件加倍行间距"><a href="#对可能含有空白行的文件加倍行间距" class="headerlink" title="对可能含有空白行的文件加倍行间距"></a><strong>对可能含有空白行的文件加倍行间距</strong></h3><p>描述：去掉上例中最后一行的空格。<br>命令：<code>sed &#39;{ /^$/d; $!G}&#39; mydata4</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/sed/sed-clear-multiple-lines.png" alt=""></p>
<h2 id="生产环境案例"><a href="#生产环境案例" class="headerlink" title="生产环境案例"></a>生产环境案例</h2><h3 id="替换指定目录所有文件中匹配的字符串"><a href="#替换指定目录所有文件中匹配的字符串" class="headerlink" title="替换指定目录所有文件中匹配的字符串"></a><strong>替换指定目录所有文件中匹配的字符串</strong></h3><p>描述：将当前目录下所有文件中出现字符串p9xqnn501的地方，全部替换为pabfn7ecx，并直接修改原始文件。<br>命令：<code>sed -i &#39;&#39; &#39;s/p9xqnn501/pabfn7ecx/g&#39; *</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo.png" alt=""></p>
<h3 id="删除空格"><a href="#删除空格" class="headerlink" title="删除空格"></a><strong>删除空格</strong></h3><p>描述：删除每行开头的空格。<br>命令：<br><code>sed &#39;s/^[ ]*//&#39; mydata</code><br><code>sed &#39;s/^[[:space:]]*//&#39; mydata</code></p>
<h3 id="删除空行和开头的-注释"><a href="#删除空行和开头的-注释" class="headerlink" title="删除空行和开头的#注释"></a><strong>删除空行和开头的#注释</strong></h3><p>描述：删除空行和开头的#注释<br>命令：<br><code>sed -e &#39;s/^#//; s/^$//&#39; mydataΩ</code></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/11/linux/daily-command-scp/</loc>
    <lastmod>2018-06-22T01:52:16.820Z</lastmod>
    <data>
        <display>
        <title>Linux scp总结</title>
        <pubTime>2018-06-11T06:16:41.000Z</pubTime>
      
         <content><p>scp命令用来在服务器之间安全传输文件，scp传输是加密的。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>top source_file_name username@destination_host:destination_folder</code></p>
<p>一句话解释：以username用户拷贝source_file到destination_host上的destination_folder里。</p>
<h2 id="命令作用"><a href="#命令作用" class="headerlink" title="命令作用"></a>命令作用</h2><p>scp命令是安全拷贝协议Secure Copy Protocol的缩写，和众多Linux/Unix使用者所熟知的拷贝（cp）命令一样。scp的使用方式类似于cp命令，cp命令将一个文件或文件夹从本地操作系统的一个位置（源）拷贝到目标位置（目的），而scp用来将文件或文件夹从网络上的一个主机拷贝到另一个主机当中去。</p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-1：强制scp命令使用协议ssh1。</li>
<li>-2：强制scp命令使用协议ssh2。</li>
<li>-4：强行使用IPV4地址。</li>
<li>-6：强行使用IPV6地址。</li>
<li>-B：采取批量模式（避免询问密码或口令）。</li>
<li>-C：启用压缩。通过指明-C参数来开启压缩模式。</li>
<li>-c：加密方式<ul>
<li>选择在传输过程中用来加密的加密方式 这个选项会被直接传递到ssh。</li>
</ul>
</li>
<li>-F：ssh配置<ul>
<li>给ssh指定一个用来替代默认配置的配置文件。这个选项会被直接传递到ssh。</li>
</ul>
</li>
<li>-i：identity_file从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。  </li>
<li>-l：限速<ul>
<li>限制命令使用的带宽，默认单位是Kbit/s。</li>
</ul>
</li>
<li>-P：端口<ul>
<li>指定需要的连接的远程主机的端口。  </li>
<li>注意，这个选项使用的是一个大写的“P”，因为小写的“-p”已经用来保留目标文件的时间和模式相关信息。</li>
</ul>
</li>
<li>-p：保留文件原来的修改时间，访问时间以及权限模式。</li>
<li>-q：静默模式：不显示来自ssh命令的进度信息，警告和诊断信息。</li>
<li>-r：递归拷贝整个目录。<ul>
<li>注意，scp命令在树形遍历的时候同样会跟随符号连接，复制所连接的文件。</li>
</ul>
</li>
<li>-v：详细模式。scp和ssh将会打印出处理过程中的调试信息。这可以帮助你调试连接、认证和配置方面的问题。</li>
</ul>
<h2 id="实用示例"><a href="#实用示例" class="headerlink" title="实用示例"></a>实用示例</h2><p><strong>实例：1. 从远程服务器复制文件到本地目录</strong><br>描述：从远程39.106.99.114机器上的/root/develop/目录中下载scp.tar.gz文件到本地/root/目录中。<br>命令：<code>scp root@39.106.99.114:/root/develop/scp.tar.gz /root/</code></p>
<p><strong>实例：2. 从远程服务器复制目录到本地</strong><br>描述：从远程39.106.99.114机器上的/root/develop/目录中下载所有文件到本地/root/目录中。<br>命令：<code>scp -r root@39.106.99.114:/root/develop/ /root/</code></p>
<p><strong>实例：3. 上传本地目录文件到远程服务器</strong><br>描述：将本地当前目录中的scp.tar.gz文件上传到39.106.99.114机器上的/root/develpop/目录中。<br>命令：<code>scp scp.tar.gz root@39.106.99.114:/root/develop/</code></p>
<p><strong>实例：4. 上传本地目录到远程服务器</strong><br>描述：将本地root/dev/目录中所有文件上传到39.106.99.114机器上的/root/develop/目录中。<br>命令：<code>scp -r /root/dev/ root@39.106.99.114:/root/develop/</code></p>
<h2 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h2><p><strong>实例：1. v：得到认证、调试等相关细节信息</strong><br>描述：-v选项，可以得到认证、调试等相关细节信息。<br>命令：<code>scp -v index.html root@39.106.99.114:/root/scp/</code></p>
<p><strong>实例：2. r：递归拷贝整个目录</strong><br>描述：-r选项，递归拷贝整个目录。<br>命令：<code>scp -r ./iweeek root@39.106.99.114:/root/scp/</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/scp/scp-r.png" alt=""></p>
<p><strong>实例：3. q：静默模式</strong><br>描述：-q选项，可以关闭进度信息以及警告和诊断信息。<br>命令：<code>scp -r -q ./iweeek root@39.106.99.114:/root/scp/</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/scp/scp-q.png" alt=""></p>
<p><strong>实例：4. l：限制命令使用的带宽</strong><br>描述：-l选项来指定命令使用的带宽，在此我们将速度限制为512Kbit/s，也就是64KB/s。因为带宽是以千比特/秒（kbps）表示的，而8比特等于1字节。<br>命令：<code>scp -l 512 index.html root@39.106.99.114:/root/scp/</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/scp/scp-l.png" alt=""></p>
<p><strong>实例：5. p：保留原始信息</strong><br>描述：-p选项，可以保留目标文件的更新时间，访问时间和权限模式。<br>命令：<code>scp -c blowfish index.html root@39.106.99.114:/root/</code></p>
<p><strong>实例：6. P：指定端口</strong><br>描述：ssh默认使用22端口，-p选项可以指定所需的端口号。<br>命令：<code>scp -P 2222 index.html root@39.106.99.114:/root/</code></p>
<p><strong>实例：7. C：开启压缩模式</strong><br>描述：-C选项开启压缩模式，scp会不停压缩所传输的文件来节省传输过程中的带宽和时间。它特别之处在于压缩是在网络传输中进行，当文件传到目标服务器时，它会变回压缩之前的原始大小。<br>压缩的方法不是适用于所有文件。当源文件已经被压缩过了，那就没办法再压缩很多了。诸如那些像.zip，.rar，pictures和.iso的文件，用-C参数就没什么意义。<br>命令：<code>scp -C index.html root@39.106.99.114:/root/</code></p>
<p><strong>实例：8. c：选择加密数据的加密方式</strong><br>描述：scp默认使用AES-128的加密方式，可以通过-c参数来指定其他的加密方式。<br>命令：<code>scp -c blowfish index.html root@39.106.99.114:/root/</code></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/12/linux/daily-command-route/</loc>
    <lastmod>2018-06-22T01:21:36.133Z</lastmod>
    <data>
        <display>
        <title>Linux route总结</title>
        <pubTime>2018-06-12T07:23:32.000Z</pubTime>
      
         <content><p>route命令用来显示并设置Linux内核中的网络路由表。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>显示并设置Linux内核中的网络路由表，它设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>route [选项] [参数]</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-A：设置地址类型；</li>
<li>-C：打印将Linux核心的路由缓存；</li>
<li>-v：详细信息模式；</li>
<li>-n：不执行DNS反向查找，直接显示数字形式的IP地址；</li>
<li>-e：netstat格式显示路由表；</li>
<li>-net：到一个网络的路由表；</li>
<li>-host：到一个主机的路由表。</li>
</ul>
<h2 id="命令选项-1"><a href="#命令选项-1" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>Add：增加指定的路由记录；</li>
<li>Del：删除指定的路由记录；</li>
<li>Target：目的网络或目的主机；</li>
<li>gw：设置默认网关；</li>
<li>mss：设置TCP的最大区块长度（MSS），单位MB；</li>
<li>window：指定通过路由表的TCP连接的TCP窗口大小；</li>
<li>dev：路由记录所表示的网络接口。</li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 显示当前路由</strong><br>描述：在显示当前路由。-n选项不执行DNS反向查找，直接显示数字形式的IP地址。<br>命令：<br><code>route</code><br><code>route -n</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/route/route-n.png" alt=""></p>
<p>其中Flags为路由标志，标记当前网络节点的状态，Flags标志说明：</p>
<ul>
<li>U Up表示此路由当前为启动状态。</li>
<li>H Host，表示此网关为一主机。</li>
<li>G Gateway，表示此网关为一路由器。</li>
<li>R Reinstate Route，使用动态路由重新初始化的路由。</li>
<li>D Dynamically,此路由是动态性地写入。</li>
<li>M Modified，此路由是由路由守护程序或导向器动态修改。</li>
<li>! 表示此路由当前为关闭状态。</li>
</ul>
<p><strong>实例：2. 添加网关/设置网关</strong><br>描述：增加一条到达244.0.0.0的路由。<br>命令：<code>route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/route/route-add.png" alt=""></p>
<p><strong>实例：3. 屏蔽一条路由</strong><br>描述：增加一条屏蔽的路由，目的地址为224.x.x.x将被拒绝。<br>命令：<code>route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/route/route-reject.png" alt=""></p>
<p><strong>实例：4. 删除路由记录</strong><br>描述：删除刚才创建的两条记录。<br>命令：<br><code>route del -net 224.0.0.0 netmask 240.0.0.0</code><br><code>route del -net 224.0.0.0 netmask 240.0.0.0 reject</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/route/route-del.png" alt=""></p>
<p><strong>实例：5. 删除和添加设置默认网关</strong><br>描述：不建议在连接到远程主机的时候删除默认网关，会导致断开远程主机的连接。不过在命令行下命令不会永久保存，当网卡重启或者机器重启之后，该路由就失效了。<br>命令：<br><code>route del default gw 172.16.63.253</code><br><code>route add default gw 172.16.63.253</code></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/12/linux/daily-command-ping/</loc>
    <lastmod>2018-06-22T01:20:45.532Z</lastmod>
    <data>
        <display>
        <title>Linux ping总结</title>
        <pubTime>2018-06-12T03:18:24.000Z</pubTime>
      
         <content><p>ping命令用来测试主机之间网络的连通性。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>ping通过发送ICMP ECHO_REQUEST数据包到网络主机，并显示响应情况，可以根据远程主机输出的信息来确定其是否可访问（不是绝对的），有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否处于开启状态。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>ping [选项] [主机名或IP地址]</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-d：使用Socket的SO_DEBUG功能；</li>
<li>-c&lt;完成次数&gt;：设置完成要求回应的次数；</li>
<li>-f：极限检测；</li>
<li>-i&lt;间隔秒数&gt;：指定收发信息的间隔时间；</li>
<li>-I&lt;网络界面&gt;：使用指定的网络界面送出数据包；</li>
<li>-l&lt;前置载入&gt;：设置在送出要求信息之前，先行发出的数据包；</li>
<li>-n：只输出数值；</li>
<li>-p&lt;范本样式&gt;：设置填满数据包的范本样式；</li>
<li>-q：不显示指令执行过程，开头和结尾的相关信息除外；</li>
<li>-r：忽略普通的Routing Table，直接将数据包送到远端主机上；</li>
<li>-R：记录路由过程；</li>
<li>-s&lt;数据包大小&gt;：设置数据包的大小；</li>
<li>-t&lt;存活数值&gt;：设置存活数值TTL的大小；</li>
<li>-v：详细显示指令的执行过程。</li>
</ul>
<h2 id="实用实例"><a href="#实用实例" class="headerlink" title="实用实例"></a>实用实例</h2><p><strong>实例：1. 使用ping命令</strong><br>ping命令不断向网络发送请求，当收到响应时，将收到包含如下信息的输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping.png" alt=""></p>
<p>第一行表示每次向域名/IP地址发送指定大小的数据包。接下来的数行是响应信息，具体包含以下字段：</p>
<ul>
<li>接收的字节数</li>
<li>IP地址</li>
<li>序列号</li>
<li>响应的时间</li>
</ul>
<p>最后一行是此次ping命令执行的统计信息：发送6个数据包，其中6个目标主机已收到，丢包率为0，总耗时5000毫秒。</p>
<p><strong>实例：2. 更改ping数据包之间的时间间隔</strong><br>描述：每隔3秒发送一个数据包。-i选项指定包之间的时间间隔。<br>命令：<code>ping -i 3 iweeek.com</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping-i.png" alt=""></p>
<p><strong>实例：3. 更改ping数据包大小</strong><br>描述：默认情况下，ping数据包中的字节数为56（如果包含8个字节的ICMP头，则为64）。可以使用-s选项更改此值。例如，发送一个1024字节的数据包（1032包括ICMP头）：<br>命令：<code>ping -s 1024 iweeek.com</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping-s.png" alt=""></p>
<p><strong>实例：4. 发送指定数量的ping数据包</strong><br>描述：ping的默认行为是保持发送数据包知道用户中断为止。使用-c选项可以在发送一定数量的数据包之后强制ping停止执行。例如，在发送3个数据包之后，停止执行：<br>命令：<code>ping -c 3 iweeek.com</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping-host.png" alt=""></p>
<p><strong>实例：5. 指定时间间隔和发送次数</strong><br>描述：总共花费20秒发出10个数据包，数据包的时间间隔为2秒。<br>命令：<code>ping -i 2 -c 10 127.0.0.1</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping-i-c.png" alt=""></p>
<p><strong>实例：6. 设置ping的硬超时（最长运行时间）</strong><br>描述：每隔3秒发送一个数据包，最长运行10秒。可见，最多输出发送4个数据包。-w选项指定ping的退出时间，单位是秒。以下是官方解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-w deadline</span><br><span class="line">       Specify a timeout, in seconds, before ping exits regardless of how many packets have</span><br><span class="line">       been  sent or received. In this case ping does not stop after count packet are sent,</span><br><span class="line">       it waits either for deadline expire or until count probes are answered or  for  some</span><br><span class="line">       error notification from network.</span><br></pre></td></tr></table></figure>
<p>命令：<code>ping -w 10 -i 3 iweeek.com</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping-w.png" alt=""></p>
<p><strong>实例：7. 设置ping的软超时</strong><br>描述：-w选项确保ping在截止日期过期后停止，-W选项也可以使ping停止，但仅限于目标端没有响应时。以下是官方解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-W timeout</span><br><span class="line">       Time to wait for a response, in seconds. The option affects only</span><br><span class="line">       timeout  in  absence  of any responses, otherwise ping waits for</span><br><span class="line">       two RTTs.</span><br></pre></td></tr></table></figure>
<p>命令：<code>ping -W 3 iweeek.com</code> </p>
<p><strong>实例：8. 使用ping启动大量数据包</strong><br>描述：-f选项可以启动大量数据包。下面是官方的解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-f     Flood  ping. For every ECHO_REQUEST sent a period ``.&apos;&apos; is printed,</span><br><span class="line">       while for ever ECHO_REPLY received a backspace  is  printed.   This</span><br><span class="line">       provides a rapid display of how many packets are being dropped.  If</span><br><span class="line">       interval is not given, it sets interval to zero and outputs packets</span><br><span class="line">       as  fast  as they come back or one hundred times per second, which‐</span><br><span class="line">       ever is more.  Only the super-user may use this  option  with  zero</span><br><span class="line">       interval.</span><br></pre></td></tr></table></figure>
<p>命令：<code>ping -f iweeek.com</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping-f.png" alt=""></p>
<p><strong>实例：9. 在每行之前打印ping时间戳</strong><br>描述：-D选项可以打印unix时间和微妙的组合。<br>命令：<code>ping -D iweeek.com</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping-D.png" alt=""></p>
<p><strong>实例：10. 不显示具体请求信息</strong><br>描述：-q不显示发送和接收的美和请求之间发生的所有事情，而只是开始和结束时的输出。<br>命令：<code>ping -q iweeek.com</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping-q.png" alt=""></p>
<p><strong>实例：11. 多参数使用</strong><br>描述：向域名iweeek.com发送5个数据包，每个间隔2秒，数据包大小为1024字节，TTL值为255，测试其连通性。<br>命令：<code>ping -c 5 -i 2 -s 1024 -t 255 iweeek.com</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ping/ping-mul-params.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/13/linux/daily-command-more/</loc>
    <lastmod>2018-06-22T01:19:00.688Z</lastmod>
    <data>
        <display>
        <title>Linux more总结</title>
        <pubTime>2018-06-13T06:23:45.000Z</pubTime>
      
         <content><p>more命令是一个基于vi编辑器文本过滤器，用于一次查看一个或多个文件的内容，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>more命令用于一次查看一个或多个文件的内容。它支持通过文件向前和向后导航，主要用于查看文件的内容。它还支持搜索字符串或正则表达式，并在文本编辑器中的当前位置打开文件。<br>more内置若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。<br><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>more [-dlfpcsu] [-num lines] [+/pattern] [+linenum] [file ...]</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-num <em>lines</em>：指定每屏显示的行数。</li>
<li>-d：显示“[press space to continue,’q’ to quit.]”和“[Press ‘h’ for instructions]”。当一个非法的按键按下时，会响铃。</li>
<li>-c：不进行滚屏操作。每次刷新这个屏幕。</li>
<li>-s：将多个空行压缩成一行显示。</li>
<li>-u：禁止下划线。</li>
<li>+<em>num</em>：从指定数字的行开始显示。</li>
<li><strong>+/</strong> <em>正则表达式</em>：指定搜索的正则表达式。</li>
</ul>
<p>该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–（XX%）可以用下列不同的方法对提示做出回答：</p>
<ul>
<li><strong>h</strong>, <strong>?</strong>：显示简短的命令汇总帮助信息。</li>
<li>[<em>k</em>]<strong>SPACE</strong>, [<em>k</em>]<strong>z</strong>：显示文本的下一屏内容。</li>
<li>[<em>k</em>]<strong>RETURN</strong>：只显示文本的下一行内容。</li>
<li>[<em>k</em>]<strong>d</strong>,[<em>k</em>]<strong>^D</strong>：滚动k行，初始滚动11行。</li>
<li><strong>q</strong>, <strong>Q</strong>, <strong>^C</strong>：退出more命令。</li>
<li>[<em>k</em>]<strong>s</strong>：跳过k行，默认是1行。</li>
<li>[<em>k</em>]<strong>f</strong>：跳出k个屏幕大小的行，默认是1行。</li>
<li><strong>b</strong>, <strong>^B</strong>：显示上一屏的内容，默认是1行，仅在浏览文件时起作用，通过管道传送过来的是无效的。</li>
<li><strong>‘</strong>：返回到上一次搜索开始的位置。</li>
<li><strong>=</strong>：显示当前行号。</li>
<li>[<em>k</em>]<strong>/</strong> <em>pattern</em>：进入搜索模式，搜索第k次出现匹配正则表达式的地方，默认是第一次出现的地方。按n键继续搜索下一个匹配项。</li>
<li>[<em>k</em>]<strong>n</strong>：搜索第k次出现上次匹配上一次正则表达式的地方，默认是1。</li>
<li><strong>!</strong> <em>command</em>, <strong>:!</strong> <em>command</em>：在子shell中执行命令。</li>
<li><strong>v</strong>：用$EDITOR指定的编辑器打开当前行。如果未指定，则默认用/usr/bin/vi打开。</li>
<li><strong>^L</strong>：与-c选项相同，重绘屏幕，不进行滚屏。</li>
<li>[<em>k</em>]<strong>:n</strong>：如果有多个文件，跳到下一个文件。</li>
<li>[<em>k</em>]<strong>:p</strong>：如果有多个文件，跳到上一个文件。</li>
<li><strong>:f</strong>：显示当前文件的名字和行号。</li>
<li><strong>.</strong>：重复上一次的命令。</li>
</ul>
<h2 id="实用示例"><a href="#实用示例" class="headerlink" title="实用示例"></a>实用示例</h2><p><strong>实例：1. 查看文件的内容</strong><br>描述：打开文件第一页放入可用的屏幕大小内。more移动文件的百分比值将在底部的实时显示。<br>命令：<code>more /usr/share/dict/words</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/more/more.png" alt=""></p>
<p>描述：-3表示每次仅显示3行。-c选项将不进行滚屏操作，而是每次刷新这个屏幕。<br>命令：<code>more -3 -c /usr/share/dict/words</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-editor.png" alt=""></p>
<p><strong>实例：2. 显示帮助</strong><br>描述：-d显示[press space to continue,’q’ to quit.]提示。按h键或?键可以显示帮助信息。<br>输出:<br><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-h.png" alt=""></p>
<p><strong>实例：3. 显示行号</strong><br>描述：按=键，可以显示当前的行号。<br>命令：<code>按=键显示行号</code><br>输出:<br><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-=.png" alt=""></p>
<p><strong>实例：4. 查看多个文件的内容</strong><br>描述：如果通过通配符传递给more多个文件的的内容，这将为每个文件打开一个缓冲区并显示第一个文件，并显示一个标题以指示正在显示的文件。<br>命令：<code>more /usr/share/dict/*</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-n-p.png" alt=""><br>按:n跳到下一个文件的开头。<br><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-next-file.png" alt=""><br>按:p要跳回上一个文件的开头。<br><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-previous-file.png" alt=""></p>
<p><strong>实例：5. 查看更多</strong><br>描述：<br>按Space键或者z键可以基于当前屏幕的大小向前移动一页。按回车键向前移动一行，或者在按回车键之前按一个数字n，再按回车键，可以直接向前移动n行。按b或者CTRL-B向后移动一页。</p>
<p><strong>实例：6. 打开文件并定位到指定的行</strong><br>描述：打开letter文件，并直接定位到第10行J字母位置。<br>命令：<code>more +10 letter</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-to-line-number.png" alt=""></p>
<p><strong>实例：7. 打开文件并定位到第一次匹配的位置</strong><br>描述：打开words文件，查找第一次出现以eat开头的单词，并定位到该位置。选项+后跟搜索模式，表示搜索字符串第一次出现的位置，搜索模式应该以/开头，可以是正则表达式。<br>命令：<code>more +/^eat /usr/share/dict/words</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-wildcard.png" alt=""></p>
<p><strong>实例：8. 如何在more界面下搜索内容</strong><br>描述：在more界面中，按/键后进入搜索模式，输入要搜索的短语，搜索模式接受正则表达式。例如，在words文件中搜索eat，将搜索短语的实例并滚动到页面第一次出现它的位置。<br>如果要继续查找下一个出现该模式的地方，按n键即可。<br>命令：<code>按/键进入搜索模式</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-search.png" alt=""></p>
<p><strong>实例：9. 编辑正在查看的文件</strong><br>在more界面中，按v键后将会打开文本编辑器，默认的文本编辑器是$EDITOR变量指定的。当修改完成保存后退出，将会回到more界面。如果$EDITOR没有指定编辑器，那么默认的vi将会被使用。</p>
<p>描述：先查看$EDITOR是否已设置，如果没有，在命令行输入export EDITOR=vim可以临时设置。如果要永久设置该变量，请将其添加到.bashrc文件或.zshrc文件中。<br>命令：<br><code>export EDITOR=vim</code><br><code>按v键进入编辑模式</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-editor.png" alt=""></p>
<p><strong>实例：9. 命令行搜索正则表达式</strong><br>模式：从words文件中搜索单词中含有eat的位置，每次显示3行，从第10行开始搜索，并加以提示。<br>命令：<code>more -d -3 +/eat +10 /usr/share/dict/words</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/more/more-editor.png" alt=""></p>
<p><strong>实例：10. 如何退出more</strong><br>描述：按q、Q键或CTRL-C（中断键）退出more界面，并返回到终端提示符。</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/15/linux/daily-command-ls/</loc>
    <lastmod>2018-06-22T01:17:53.910Z</lastmod>
    <data>
        <display>
        <title>Linux ls总结</title>
        <pubTime>2018-06-15T08:37:59.000Z</pubTime>
      
         <content><p>ls命令用来列出目标目录中所有子目录和文件。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>ls（list）命令用来列出目标目录（缺省为当前目录）中所有子目录和文件。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>ls [选项] [参数]</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">-a：列出任何以.开头的文件（常用）。</span><br><span class="line">-A：列出除.与..之外的任何文件。</span><br><span class="line">-c：显示的最后更改时间（ctime）。默认以创建时间（最后更改时间）排序，最新的排在前面；如果与-l搭配使用，那么会以文件名排序；如果与-lt搭配，会显示创建时间（最后更改时间），根据时间排序。</span><br><span class="line">-B：忽略备份文件，Linux中的备份文件以波浪号（~）结尾。</span><br><span class="line">-d：仅列出目录本身，而不是列出目录内的文件数据（常用）</span><br><span class="line">-f：不排序，与启用-aU，不启用-ls --color效果一样。</span><br><span class="line">-F：根据文件、目录等信息，给与附加数据结构，例如：</span><br><span class="line">	- @：代表一个符号链接。</span><br><span class="line">	- *：代表可执行文件。</span><br><span class="line">	- /：代表目录。</span><br><span class="line">	- =：代表socket文件。</span><br><span class="line">	- |：代表FIFO文件。</span><br><span class="line">-g：像-l，但不列出拥有者。</span><br><span class="line">-G：在-l下，不列出组名字。</span><br><span class="line">-h：以人类可读的形式，打印文件大小，例如1K、234M、2G等等。</span><br><span class="line">-i：打印inode信息。</span><br><span class="line">-l：使用长数据串格式。</span><br><span class="line">-r：排序时反转列表。</span><br><span class="line">-R：递归列出子目录。</span><br><span class="line">-s：列出每个文件分配的blocks大小。</span><br><span class="line">-S：根据文件大小排序，最大的列在前面。</span><br><span class="line">-t：根据最近修改时间排序，最新的列在前面。</span><br><span class="line">-u：与-l搭配显示访问时间（atime）。</span><br><span class="line">-U：不排序，按照目录顺序列出所有文件。</span><br><span class="line">--author：在-l下，打印出作者的信息。</span><br><span class="line">--color=never：不根据文件特性显示颜色。</span><br><span class="line">--color=always：显示颜色。</span><br><span class="line">--color=auto：系统自动判断是否显示颜色。</span><br><span class="line">--format：以各种格式输出目录的内容。下文将介绍。</span><br><span class="line">--full-time：以完整时间模式（包括年、月、日、时、分）输出。</span><br><span class="line">--sort：根据不同规则排序。下文将介绍。</span><br><span class="line">--time-style=[STYLE]：设置日期格式输出格式。</span><br><span class="line">--time=&#123;atime,ctime&#125;：将时间显示为atime、ctime和mtime其中一个，默认显示的是内容修改时间。</span><br><span class="line">	- atime：访问时间。</span><br><span class="line">	- ctime：权限改变属性时间。</span><br><span class="line">	- mtime：内容修改时间。</span><br></pre></td></tr></table></figure>
<h3 id="示例：1-查看文件和目录"><a href="#示例：1-查看文件和目录" class="headerlink" title="示例：1. 查看文件和目录"></a>示例：1. 查看文件和目录</h3><p>描述：ls命令最基本的形式会显示当前目录下的文件和目录。<br>命令：<code>ls</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls.png" alt=""></p>
<h3 id="示例：2-区分文件和目录"><a href="#示例：2-区分文件和目录" class="headerlink" title="示例：2. 区分文件和目录"></a>示例：2. 区分文件和目录</h3><p>描述：如果用户用的不是支持彩色的终端仿真器，可以用-F选项的ls命令轻松区分文件和目录。-F参数在目录名后加了正斜线（/），在可执行文件的后面加了星号。有关的指示符如下：</p>
<ul>
<li>@：代表一个符号链接。</li>
<li>*：代表可执行文件。</li>
<li>/：代表目录。</li>
<li>=：代表socket文件。</li>
<li>|：代表FIFO文件。<br>命令：<code>ls -F</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-F.png" alt=""></li>
</ul>
<h3 id="示例：3-显示隐藏文件和普通文件"><a href="#示例：3-显示隐藏文件和普通文件" class="headerlink" title="示例：3. 显示隐藏文件和普通文件"></a>示例：3. 显示隐藏文件和普通文件</h3><p>描述：显示当前目录下的所有以点号开头的隐藏文件和普通文件及目录。-a选项可以显示将隐藏文件显示出来。如果要跳过输出中的（.）和（..），使用-A选项。<br>命令：<br><code>ls -a</code><br><code>ls -A</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-a.png" alt=""></p>
<h3 id="示例：4-递归显示文件"><a href="#示例：4-递归显示文件" class="headerlink" title="示例：4. 递归显示文件"></a>示例：4. 递归显示文件</h3><p>描述：列出当前目录下包含的子目录中的文件。-R选项，它叫做递归选项，它先显示了当前目录下的内容，然后还显示了所有子目录及其内容，如果子目录有跟多的子目录，-R选项会继续进行遍历。-F -R可以合并起来，如-FR。<br>命令：<br><code>ls -F -R</code><br><code>ls -FR</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-R.png" alt=""></p>
<h3 id="示例：5-查看长（详细）列表"><a href="#示例：5-查看长（详细）列表" class="headerlink" title="示例：5. 查看长（详细）列表"></a>示例：5. 查看长（详细）列表</h3><p>描述：显示文件或目录的附加信息。-l显示文件或者目录的大小，修改日期和时间，文件或者文件夹的名字和拥有者，以及它的权限信息。<br>命令：<code>ls -l</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-l.png" alt=""></p>
<p>以.开头的文件是隐藏文件，（.）（..）分别代表当前目录和上一级目录，目录的颜色是以蓝色显示的。<br>每一行都包含了关于文件（或目录）的下述信息：</p>
<ul>
<li><p>第1字段：文件属性字段<br>文件属性字段总共有10个字母组成，第一个字符表示文件类型：<br>字符（-）：普通文件。<br>字母（d）：目录。<br>字母（l）：链接文件。<br>字母（c）：字符设备文件（character）。<br>字母（b）：块设备文件（block），一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，一类特殊文件。<br>字母（p）：命令管道文件。与shell编程有关的文件。<br>字母（s）：sock文件。与shell编程有关的文件。<br>第1个字符后面的9个字母表示该文件或目录的权限位。三个为一组，均为rwx三个参数的组合。[r]代表可读、[w]代表可写、[x]代表可执行。如果没有权限，则会出现减号[-]。第一组为文件拥有者可具备的权限，第二个为加入此群组之账号的权限，第三组为非本人且没有加入本群组之其他账号的权限。</p>
</li>
<li><p>第2字段：如果一个文件不是目录，此时这一字段表示文件所具有的硬链接数。</p>
</li>
<li>第3字段：文件属主的用户名</li>
<li>第4字段：文件属组的组名。</li>
<li>第5字段：文件的大小（以字节为单位）。</li>
<li>第6字段：文件的上次修改时间。</li>
<li>第7字段：文件名或目录名。</li>
</ul>
<h3 id="示例：6-列出每个文件分配的blocks大小"><a href="#示例：6-列出每个文件分配的blocks大小" class="headerlink" title="示例：6. 列出每个文件分配的blocks大小"></a>示例：6. 列出每个文件分配的blocks大小</h3><p>描述：-s列出每个文件分配的blocks大小。-s与-l搭配使用，第一列的数字就是该文件的blocks大小。<br>命令：<code>ls -ls</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-show-blocks.png" alt=""></p>
<p>注意到第一行的total后跟的数字，它是指当前目录下所有文件所占用的空间总和。文件系统在格式化时就规范好了块（block）的大小，每个block仅能容纳一个文件，如果块大小为4K，而文件只有1K，则会有3K的空间被浪费。第一列数字的总和就是total的值。</p>
<h3 id="示例：7-查看文件的author"><a href="#示例：7-查看文件的author" class="headerlink" title="示例：7. 查看文件的author"></a>示例：7. 查看文件的author</h3><p>描述：–author选项与-l相结合可以在第五列显示每个文件的作者。<br>命令：<code>ls -l --author</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-author.png" alt=""></p>
<p>注意到第一行的total后跟的数字，它是指当前目录下所有文件所占用的空间总和。文件系统在格式化时就规范好了块（block）的大小，每个block仅能容纳一个文件，如果块大小为4K，而文件只有1K，则会有3K的空间被浪费。第一列数字的总和就是total的值。</p>
<h3 id="示例：8-以字节为单位打印文件大小"><a href="#示例：8-以字节为单位打印文件大小" class="headerlink" title="示例：8. 以字节为单位打印文件大小"></a>示例：8. 以字节为单位打印文件大小</h3><p>描述：使用–block-size选项，以千字节或兆字节等为单词显示文件的大小。<br>命令：<code>ls -l --block-size=k [file-name]</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-block-size.png" alt=""></p>
<h3 id="示例：9-使ls在输出中仅显示文件名和文件大小"><a href="#示例：9-使ls在输出中仅显示文件名和文件大小" class="headerlink" title="示例：9. 使ls在输出中仅显示文件名和文件大小"></a>示例：9. 使ls在输出中仅显示文件名和文件大小</h3><p>描述：使-h选项和-s选项配合使用，让ls输出仅包含文件/目录名称及其各自的大小。<br>命令：<code>ls -s -h</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-s-h.png" alt=""></p>
<h3 id="示例：10-过滤输出列表"><a href="#示例：10-过滤输出列表" class="headerlink" title="示例：10. 过滤输出列表"></a>示例：10. 过滤输出列表</h3><p>描述：过滤器l?tter与目录中的两个文件匹配。问号可用于过滤器字符串中替代任意位置的单个字符。<br>命令：<code>ls -l l?tter</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-one-letter.png" alt=""></p>
<p>描述：使用星号找到了四个名字以l开头的文件。和问号一样，可以把星号放在过滤器中的任意位置。<br>命令：<code>ls -l l*</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-asterisk.png" alt=""></p>
<p>描述：中括号表示一个字符位置并给出多个可能的选择。例如列出文件名为latter或letter的文件。<br>命令：<code>ls -l l[ae]tter</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-metacharacter-wildcards.png" alt=""></p>
<p>描述：中括号[a-i]还可以表示从一个字母范围里匹配。<br>命令：<code>ls -l f[a-i]ll</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-range.png" alt=""></p>
<p>描述：感叹号（!）将不需要的内容排除在外。<br>命令：<code>ls -l f[!a]ll</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-exclamation.png" alt=""></p>
<h3 id="示例：11-以人类可阅读的格式列出文件信息"><a href="#示例：11-以人类可阅读的格式列出文件信息" class="headerlink" title="示例：11. 以人类可阅读的格式列出文件信息"></a>示例：11. 以人类可阅读的格式列出文件信息</h3><p>描述：-h选项会将文件大小变为K，M，G等人类可阅读的格式。<br>命令：<code>ls -lh</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-h.png" alt=""></p>
<h3 id="示例：12-反转显示结果"><a href="#示例：12-反转显示结果" class="headerlink" title="示例：12. 反转显示结果"></a>示例：12. 反转显示结果</h3><p>描述：-r参数将默认的显示结构进行倒序显示。<br>命令：<code>ls -r</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-reverse.png" alt=""></p>
<h3 id="示例：13-按照修改时间的从远到近顺序排列"><a href="#示例：13-按照修改时间的从远到近顺序排列" class="headerlink" title="示例：13. 按照修改时间的从远到近顺序排列"></a>示例：13. 按照修改时间的从远到近顺序排列</h3><p>描述：-t参数将按照时间从近到远进行排序。<br>命令：<code>ls -lt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-t.png" alt=""></p>
<h3 id="示例：14-按照文件的大小排列"><a href="#示例：14-按照文件的大小排列" class="headerlink" title="示例：14. 按照文件的大小排列"></a>示例：14. 按照文件的大小排列</h3><p>描述：-S参数按照文件的大小进行排序。<br>命令：<code>ls -lS</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-S.png" alt=""></p>
<h3 id="示例：15-自定义显示日期格式"><a href="#示例：15-自定义显示日期格式" class="headerlink" title="示例：15. 自定义显示日期格式"></a>示例：15. 自定义显示日期格式</h3><p>描述：–time-style=[STYLE]可以自定义的文件修改日期格式进行显示。也可以直接使用–full-time显示最全的时间信息。[STYLE]的选项如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- full-iso</span><br><span class="line">- long-iso</span><br><span class="line">- iso</span><br><span class="line">- locale</span><br><span class="line">- +%H:%M:%S:%D</span><br></pre></td></tr></table></figure>
<p>命令：<br><code>ls -l --time-style=iso</code><br><code>ls --full-time ~</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-time-style.png" alt=""></p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-full-time.png" alt=""></p>
<h3 id="示例：16-根据不同的规则进行排序"><a href="#示例：16-根据不同的规则进行排序" class="headerlink" title="示例：16. 根据不同的规则进行排序"></a>示例：16. 根据不同的规则进行排序</h3><p>描述：根据–sort不同的规则进行排序。可选值如下（括号里表示等效的命令行参数）：</p>
<ul>
<li>extension(-X)：根据文件扩展名排序。</li>
<li>size(-S)：根据文件大小排序。</li>
<li>time(-t)：根据时间先后排序。</li>
<li>version(-v)</li>
<li>none(-U)</li>
</ul>
<p>命令：<code>ls -l --sort=extension</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-sort-extension.png" alt=""></p>
<h3 id="示例：17-更改ls命令输出格式"><a href="#示例：17-更改ls命令输出格式" class="headerlink" title="示例：17.更改ls命令输出格式"></a>示例：17.更改ls命令输出格式</h3><p>描述：–-format可以以各种格式输出目录的内容，例如逗号，水平、垂直分隔等等。可选值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- comma：逗号。</span><br><span class="line">- horizontal或across：水平。</span><br><span class="line">- long或verbose：长列表，如-l选项。</span><br><span class="line">- single-column：单列。</span><br><span class="line">- vertical：垂直排列，根据屏幕宽度决定显示几列。</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-commas.png" alt=""></p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-single-column.png" alt=""></p>
<h3 id="示例：18-使ls隐藏特定类型的文件"><a href="#示例：18-使ls隐藏特定类型的文件" class="headerlink" title="示例：18.使ls隐藏特定类型的文件"></a>示例：18.使ls隐藏特定类型的文件</h3><p>描述：使用–hide可以强制ls命令在输出中隐藏特定类型的文件。例如，在输出中隐藏以.txt结尾的文件。<br>命令：<code>ls --hide=*.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/ls/ls-hide.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/12/linux/daily-command-join/</loc>
    <lastmod>2018-06-22T01:17:31.573Z</lastmod>
    <data>
        <display>
        <title>Linux join总结</title>
        <pubTime>2018-06-12T08:59:13.000Z</pubTime>
      
         <content><p>join命令用来将两个分类文本文件的行连在一起，与SQL语言中的join命令相似。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>join命令根据两个分类文本文件的两个相同字段，将两个文件连接起来，结果写入标准输出。默认连接字段是由空格分隔的第一个字段。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>join [选项] 文件1 文件2</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-a&lt;1或2&gt;：除了显示原来的输出内容之外，还显示指令文件中没有匹配的行。</li>
<li>-e&lt;字符串&gt;：若[文件1]与[文件2]中找不到指定的栏位，则在输出中填入选项中的字符串。</li>
<li>-i或–ignore-case：比较栏位内容时，忽略大小写的差异。</li>
<li>-o&lt;格式&gt;：按照指定的格式来显示结果。</li>
<li>-t&lt;字符&gt;：使用栏位的分割字符。</li>
<li>-v&lt;1或2&gt;：更-a相同，但是只显示文件中没有匹配的行。</li>
<li>-1&lt;栏位&gt;：连接[文件1]指定的栏位。</li>
<li>-2&lt;栏位&gt;：连接[文件2]指定的栏位。</li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 相同域连接</strong><br>描述：将foodtype.txt和foods.txt两个文件共享的第一个字段作为连接字段，将文件连接起来。<br>命令：<code>join foodtype.txt foods.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/join/join-two-file.png" alt=""></p>
<p><strong>实例：2. 不同域连接</strong><br>描述：将wine.txt的第二列和reviews.txt的第一列连接起来。也可以使用-j选项，即-j1 2 -j2 1。<br>命令：<code>join -1 2 -2 1 wine.txt reviews.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/join/join-1-2.png" alt=""></p>
<p><strong>实例：3. 先排序再连接</strong></p>
<p>描述：如果上述两个文件指定的文件未排序，那么在连接的时候会发生错误。<br>命令：<code>join -1 2 -2 1 wine.txt reviews.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/join/join-sort-file.png" alt=""></p>
<p>描述：先按wine.txt的第二列排好序，再按reviews的第一列排好序，最后将两个排好序的文件连接起来。<br>命令：<code>join -1 2 -2 1 &lt;(sort -k 2 wine.txt) &lt;(sort reviews.txt)</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/join/join-sort.png" alt=""></p>
<p><strong>实例：4. 指定字段分隔符</strong><br>描述：将names.csv和transactions.csv两个文件指定分隔符为，号进行连接，-t选项指定字段分隔符。<br>命令：<code>join -1 2 -2 3 -t , names.csv transactions.csv</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/join/join-t.png" alt=""></p>
<p><strong>实例：5. 指定显示的字段</strong><br>描述：-o选项指定连接的输出格式。<br>命令：<code>join -1 2 -2 3 -t , -o 1.1,1.2,1.3,2.2,2.1 names.csv transactions.csv</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/join/join-o.png" alt=""></p>
<p><strong>实例：6. 用默认字符串代替未匹配的字段</strong><br>描述：-e选项告诉join当找不到匹配项的时候应该用什么字符串来替换空位，-o选项告诉join哪些不匹配的字段应该被代替。-e只能与-o搭配使用。</p>
<ul>
<li>0,1.1,2.2：0表示匹配的关键字段。<ul>
<li>1.1：表示第一个文件中第一个字段。</li>
<li>2.2：表示第二个文件中第二个字段。</li>
</ul>
</li>
</ul>
<p>命令：<br><code>join -a 1 -a 2 -e &quot;NULL&quot; -o 1.1,1.2,2.2 foods.txt foodtype.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/join/join-e.png" alt=""></p>
<p><strong>实例：7. 显示匹配和不匹配的行</strong><br>描述：既显示成功匹配的行，也显示两个文件中不匹配的所有行。-a选项可选值为1或2，分别表示前后两个文件，意思是显示指定文件中不匹配的行。<br>命令：<br><code>join -a 1 foods.txt foodtype.txt</code><br><code>join -a 2 foods.txt foodtype.txt</code><br><code>join -a 1 -a 2 foods.txt foodtype.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/join/join-a.png" alt=""></p>
<p><strong>实例：8. 只显示不匹配的行</strong><br>描述：只两个文件中不匹配的所有行。-v选项可选值为1或2，分别表示前后两个文件，意思是只显示指定文件中不匹配的行，将忽略已匹配连接的行。<br>命令：<br><code>join -v 1 -v 2 foods.txt foodtype.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/join/join-v.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/09/linux/daily-command-io-redirection/</loc>
    <lastmod>2018-06-22T01:17:20.781Z</lastmod>
    <data>
        <display>
        <title>Linux IO Redirection总结</title>
        <pubTime>2018-06-09T12:40:05.000Z</pubTime>
      
         <content><p>一个文件描述符就是文件系统为了跟踪这个打开的文件而分配给它的一个数字，可以将其理解为文件指针的一个简单版本，与C语言中的文件句柄的概念类似。<br>Linux中默认情况下始终有3个「文件」处于打开状态，分别是stdin（键盘）、stdout（屏幕）和stderr（错误消息输出到屏幕上）。这3个文件和其他打开的文件都可以被重定向。重定向，就是捕捉一个文件、命令、程序、脚本，或者是脚本中的代码块的输出，然后将这些输出作为输入发送到另一个文件、命令、程序或脚本中。<br>每个打开的文件都会分配一个文件描述符。stdin、stdout和stderr的文件描述符分别是0、1和2。除了这3个文件，对于其他需要打开的文件，保留了文件描述符3到9。在某些情况下，将这些额外的文件描述符分配给 stdin、stdout 或 stderr 作为临时的副本链接是非常有用的。在经过复杂的重定向和刷新之后需要把它们恢复成正常状态。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>命令1|命令2</code></p>
<h2 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h2><p>command &gt; filename：把标准输出重定向到一个新文件中。<br>command &gt;&gt; filename：把标准输出重定向到一个文件中（追加）。<br>command 1 &gt; filename：把标准输出重定向到一个文件中。<br>command &gt; filename 2&gt;&amp;1：把标准输出和标准错误一起重定向到一个文件中。<br>command 2 &gt; filename：把标准错误重定向到一个文件中。<br>command 2 &gt;&gt; filename：把标准错误重定向到一个文件中（追加）。<br>command &gt;&gt; filename 2&gt;&amp;1：把标准输出和标准错误一起重定向到一个文件中（追加）。<br>command &lt; filename &gt; filename2：command命令以filename文件作为标准输入，以filename2文件作为标准输出。<br>command &lt; filename：command命令以filename文件作为标准输入。<br>command &lt;&lt; delimiter：从标准输入中读入，直至遇到delimiter分界符。<br>command &lt;&amp; m：把文件描述符m作为标准输入。<br>command &gt;&amp; m：把标准输出重定向到文件描述符m中。<br>command &lt;&amp;-：关闭标准输入。</p>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. &gt; file</strong><br>描述：将ls命令的stdout重定向到dir-tree.list文件。如果这个文件不存在，那就创建它，否则就覆盖。<br>命令：<code>ls -lR &gt; dir-tree.list</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/redirection/redirection-&gt;.png" alt=""></p>
<p>描述：清空文件。&gt;将会把文件dir-tree.list变为一个空文件（size为0）。如果文件不存在，那会创建一个0长度的文件（与touch的效果相同）。:是一个占位符，不产生任何输出。也可以省略:占位符。<br>命令：<code>: &gt; dir-tree.list</code><br>或者：<code>&gt; dir-tree.list</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/redirection/redirection-clear.png" alt=""></p>
<p><strong>实例：1. &gt;&gt; file</strong><br>描述：将stdout重定向到一个文件。如果文件不存在，那么就创建它，如果存在，那么就追加到文件后边。<br>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script.sh 1 &gt; filename</span><br><span class="line"># 重定向 stdout 到文件&quot;filename&quot;.</span><br><span class="line">script.sh 1 &gt;&gt; filename</span><br><span class="line"># 重定向并追加 stdout 到文件&quot;filename&quot;.</span><br><span class="line">script.sh 2 &gt; filename</span><br><span class="line"># 重定向 stderr 到文件&quot;filename&quot;.</span><br><span class="line">script.sh 2 &gt;&gt; filename</span><br><span class="line"># 重定向并追加 stderr 到文件&quot;filename&quot;.</span><br></pre></td></tr></table></figure></p>
<p><strong>实例：1. &amp;&gt; afile</strong><br>描述：将ls命令的stdout重定向到dir-tree.list文件。如果这个文件不存在，那就创建它，否则就覆盖。<br>命令：<code>ls -lR &gt; dir-tree.list</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/redirection/redirection-clear.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/09/linux/daily-command-grep/</loc>
    <lastmod>2018-06-22T01:16:28.230Z</lastmod>
    <data>
        <display>
        <title>Linux grep总结</title>
        <pubTime>2018-06-08T16:39:12.000Z</pubTime>
      
         <content><p>grep是一个强大的文本搜索工具，用于搜索与正则表达式匹配的行的纯文本数据。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>grep [选项] &#39;搜索字符串&#39;文件</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>grep命令用于搜索与正则表达式匹配的行的纯文本数据。如果将 grep 拆分为 <code>g/re/p</code>，其实代表全局搜索正则表达式并打印结果（globally search a regular expression and print），也就是从文件中搜索模式，然后打印匹配的行到屏幕。它在一个或多个文件中搜索字符串模板，如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响源文件内容。不过grep只能使用基本的正则表达式来搜索文本，并且在查找字符串时，是以整行为单位进行数据筛选的。<br>grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。<br>egrep命令等同于grep -E，可以使用扩展的正则表达式来对文本进行搜索。fgrep命令等同于grep -F，可以使用固定的字符串来对文本进行搜索，不支持正则表达式，执行速度很快。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>？：同时显示匹配行上下的？行，同-C选项。</li>
<li>-a或–text：不要忽略二进制的数据。   </li>
<li>-A&lt;显示行数&gt;或–after-context=&lt;显示行数&gt;：除了显示符合范本样式的那一列之外，并显示该行之后的内容。   </li>
<li>-b或–byte-offset：在显示符合样式的那一行之前，标示出该行第一个字符的编号。   </li>
<li>-B&lt;显示行数&gt;或–before-context=&lt;显示行数&gt;：除了显示符合样式的那一行之外，并显示该行之前的内容。   </li>
<li>-c或–count：只打印匹配的行数，不显示匹配的内容。   </li>
<li>-C&lt;显示行数&gt;或–context=&lt;显示行数&gt;或-&lt;显示行数&gt;：除了显示符合样式的那一行之外，并显示该行之前后的内容。   </li>
<li>-d&lt;动作&gt;或–directories=&lt;动作&gt;：当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。   </li>
<li>-e&lt;范本样式&gt;或–regexp=&lt;范本样式&gt;：指定字符串做为查找文件内容的样式。   </li>
<li>-E或–extended-regexp：将样式为延伸的普通表示法来使用。   </li>
<li>-f&lt;规则文件&gt;或–file=&lt;规则文件&gt;：指定规则文件，从文件中提取规则，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。空文件包含0个规则，什么都不匹配，</li>
<li>-F或–fixed-regexp：将样式视为固定字符串的列表。   </li>
<li>-G或–basic-regexp：将样式视为普通的表示法来使用。   </li>
<li>-h或–no-filename：在显示符合样式的那一行之前，不标示该行所属的文件名称前缀。   </li>
<li>-H或–with-filename：在显示符合样式的那一行之前，表示该行所属的文件名称。   </li>
<li>-i或–ignore-case：忽略字符大小写的差别。   </li>
<li>-l或–file-with-matches：列出文件内容符合指定的样式的文件名称。   </li>
<li>-L或–files-without-match：列出文件内容不符合指定的样式的文件名称。   </li>
<li>-n或–line-number：在显示符合样式的那一行之前，标示出该行的列数编号。   </li>
<li>-o：只输出文件中匹配到的部分。</li>
<li>-q或–quiet或–silent：不显示任何信息。   </li>
<li>-r或–recursive：此参数的效果和指定“-d recurse”参数相同。   </li>
<li>-s或–no-messages：不显示错误信息。   </li>
<li>-v或–revert-match：显示不包含匹配文本的所有行。   </li>
<li>-V或–version：显示版本信息。   </li>
<li>-w或–word-regexp：只显示全字符合的列。   </li>
<li>-x或–line-regexp：只显示全列符合的列。   </li>
<li>-y：此参数的效果和指定“-i”参数相同。</li>
</ul>
<h2 id="规则表达式"><a href="#规则表达式" class="headerlink" title="规则表达式"></a>规则表达式</h2><p>grep正则表达式元字符集（基本集）：</p>
<ul>
<li>^：锚定行的开始，如：’^grep’匹配所有以grep开头的行。</li>
<li>$：锚定行的结束，如：’grep$’匹配所有以grep结尾的行。</li>
<li>.：匹配一个非换行符的字符，如：’gr.p’匹配gr后接一个任意字符，然后是p。</li>
<li>*：匹配零个或多个先前字符，如：’*grep’匹配所有一个或多个空格后紧跟grep的行。</li>
<li>.* ：一起用代表任意字符。   </li>
<li>[] ：匹配一个指定范围内的字符，如’[Gg]rep’匹配Grep和grep。</li>
<li>[^]：匹配一个不在指定范围内的字符，如：’[^A-FH-Z]rep’匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。</li>
<li>(..)：标记匹配字符，如’(love)‘，love被标记为1。</li>
<li>\&lt;：锚定单词的开始，如:’\&lt;grep’匹配包含以grep开头的单词的行。</li>
<li>>：锚定单词的结束，如’grep>‘匹配包含以grep结尾的单词的行。</li>
<li>x{m}：重复字符x，m次，如：’o{5}‘匹配包含5个o的行。</li>
<li>x{m,}：重复字符x,至少m次，如：’o{5,}‘匹配至少有5个o的行。</li>
<li>x{m,n}：重复字符x，至少m次，不多于n次，如：’o{5,10}‘匹配5–10个o的行。   </li>
<li>\w：匹配文字和数字字符，也就是[A-Za-z0-9]，如：’G\w*p’匹配以G后跟零个或多个文字或数字字符，然后是p。   </li>
<li>\W：\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </li>
<li>\b：单词锁定符，如: ‘\bgrep\b’只匹配grep。  </li>
</ul>
<p>egrep和grep -E的元字符扩展集</p>
<ul>
<li>+：匹配一个或多个先前的字符。如’[a-z]+able’，匹配一个或多个小写字母后跟able的串，如loveable，enable，disable等。</li>
<li>？：匹配零个或多个先前的字符。如’gr?p’匹配gr后跟一个或没有字符，然后是p的行。</li>
<li>a|b|c：匹配a或b或c。如grep|sed匹配grep或sed。</li>
<li>()：分组符号，如love(able|rs)ov+匹配loveable或lovers，匹配一个或多个ov。</li>
<li>x{m},x{m,},x{m,n}：作用同x{m}，x{m,}，x{m,n}</li>
</ul>
<p>POSIX字符类</p>
<p>为了在不同国家的字符编码中保持一致，POSIX（The Portable Operating System Interface）增加了特殊的字符类。</p>
<ul>
<li>[[:alnum:]]：文字数字字符。</li>
<li>[[:alpha:]]：文字字符。</li>
<li>[[:digit:]]：数字字符。</li>
<li>[[:lower:]]：小写字符。</li>
<li>[[:cntrl:]]：控制字符。、</li>
<li>[[:print:]]：非空字符（包括空格）。</li>
<li>[[:punct:]]：标点符号。</li>
<li>[[:space:]]：所有空白字符（新行，空格，制表符）。</li>
<li>[[:upper:]]：大写字符。</li>
<li>[[:xdigit:]]：十六机制数字（0-9，a-f，A-F）。</li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 查找文件</strong><br>描述：-i表示忽略大小写。-y与-i的效果相同。<br>命令：<code>find . -name &quot;*.txt&quot; | grep -i find</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-i.png" alt=""></p>
<p><strong>实例：2. 搜索并过滤文件</strong><br>描述：-v选项告诉grep反转其匹配的输出，也就是打印所有不匹配的行。<br>命令：<code>find . -name &quot;*.txt&quot; | grep -v find</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-v.png" alt=""></p>
<p><strong>实例：3. 只查找特定的文件</strong><br>描述：以下命令表示搜索以.txt结尾的文件，然后通过重定向到grep，筛选文件名中含有字符串find的结果，再次重定向到grep，筛选结果中不存在users的结果。<br>命令：<code>find . -name &quot;*.txt&quot; | grep -i find | grep -vi users</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-grep.png" alt=""></p>
<p><strong>实例：4. 显示指定字符串位置向前或者向后的行</strong><br>描述：显示匹配到eth0的行以及后面的10行。-A和-B，显示匹配的行和行数，显示匹配的字符串行之前或之后。-A=after，-B=before。<br>命令：<code>ifconfig | grep -A 10 eth0</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-A.png" alt=""></p>
<p>描述：显示匹配到lo的行以及前面的10行。-b将显示该行第一个字符的编号。<br>命令：<code>ifconfig | grep -b -B 10 lo</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-B.png" alt=""></p>
<p><strong>实例：5. 只显示匹配到的部分</strong><br>描述：从ifconfig的输出中搜索net，显示每行的第一个字符的编号，并且只显示文件中匹配的部分。-o选项只输出文件中匹配到的部分。<br>命令：<code>ifconfig | grep -b -o net</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-o.png" alt=""></p>
<p><strong>实例：6. 打印匹配周围的行</strong><br>描述：显示匹配到字符串lo的行以及前后各1行。-C选项会打印出匹配字符串之前和之后出现的行。<br>命令：<code>ifconfig | grep -C 1 lo</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-C.png" alt=""></p>
<p><strong>实例：7. 为匹配的字符串计数</strong><br>描述：统计匹配到的字符串数量。-c与wc命令一样可以统计字符数。<br>命令：<code>ifconfig | grep -c lo</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-cc.png" alt=""></p>
<p><strong>实例：8. 按给定的字符串搜索文件并显示行号</strong><br>描述：在find.txt文件中查找hello字符串，并显示所在的行。在编辑错误时调试文件，-n选项可以为文件中的行显示行号。<br>命令：<code>grep -n -i &quot;hello&quot; find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-n.png" alt=""></p>
<p><strong>实例：9. 匹配多个模式</strong><br>描述：在find.txt中搜索匹配Hello或者as的行。-e选项指定字符串作为查找文件的模式，可以使用多个。<br>命令：<code>grep find.txt -e Hello -e as</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-e.png" alt=""></p>
<p><strong>实例：10. 在所有目录中递归搜索字符串</strong><br>描述：在find.txt文件中查找hello字符串，并显示所在的行。-r可以递归搜索当前目录及其所有子目录。<br>命令：<code>grep -r -i &quot;hello&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-r.png" alt=""></p>
<p>描述：-h参数将不显示该行所属的文件名称，默认-H是显示的。<br>命令：<code>grep -r -h -i &quot;hello&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-r-h.png" alt=""></p>
<p><strong>实例：11. 搜索整个模式</strong><br>描述：从ifconfig的输出中搜索RUNNING字符串出现的行。<br>命令：<code>ifconfig | grep -w &quot;RUNNING&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex.png" alt=""></p>
<p><strong>实例：12. 在gzip压缩文件中搜索</strong><br>描述：从find.tar.gz压缩包里查找hello字符串。<br>命令：<code>zgrep -i hello find.tar.gz</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-zgrep.png" alt=""></p>
<p><strong>实例：13. 搜索目录并列出内容含有指定字符串的文件名称</strong><br>描述：从/root目录下列出文件内容中含有Hello字样的文件名称，忽略大小写。-l列出的是符合指定字符串的文件名称，-L列出的是不符合指定字符串的文件名称。<br>命令：<code>grep -i -l Hello /root/*</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-l.png" alt=""></p>
<p><strong>实例：14. 只列出包含或者不包含的文件内容</strong><br>描述：在当前目录下所有以.txt结尾的文件中，列出文件内容中含有Hello字样的文件名称，忽略大小写。–include只搜索匹配正则表达式的文件。<br>命令：<code>grep -i -r hello . --include &quot;*.txt&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-include.png" alt=""></p>
<p>描述：在当前目录下所有不以.txt结尾的文件中，列出文件内容中含有Hello字样的文件名称，忽略大小写。–exclude搜索不匹配正则表达式的文件。<br>命令：<code>grep -i -r hello . --exclude &quot;*.txt&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-exclude.png" alt=""></p>
<h2 id="正则表达式用法"><a href="#正则表达式用法" class="headerlink" title="正则表达式用法"></a>正则表达式用法</h2><p><strong>实例：15. 显示所有以f开头的文件中包含hello的行</strong><br>描述：在当前目录下显示所有以f开头的文件中包含hello的行。<br>命令：<code>grep -i &#39;hello&#39; f*</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-*.png" alt=""></p>
<p><strong>实例：16. 显示在多个文件中匹配hello的行</strong><br>描述：在当前目录下显示所有以f开头的文件中包含hello的行。<br>命令：<code>grep -i &#39;hello&#39; find.txt xy12.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-multiple.png" alt=""></p>
<p><strong>实例：17. 模式出现几率</strong><br>描述：在当前目录下所有文件中，搜索所有包含两个字母a的行。<br>命令：<code>grep &quot;a\{2\}&quot; find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-probability.png" alt=""></p>
<p><strong>实例：18. 模式出现几率</strong><br>描述：在当前目录下所有文件中，搜索所有超过9个字母的单词的行。<br>命令：<code>grep -i &#39;[a-z]\{9\}&#39; find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-number.png" alt=""></p>
<p>描述：-b选项将锁定为单词。<br>命令：<code>grep -i &#39;\b[a-z]\{9\}\b&#39; find.txt</code></p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-number-b.png" alt=""></p>
<p>描述：搜索超过9个字母的单词的行。<br>命令：<code>grep -i &#39;\b[a-z]\{9,\}\b&#39; find.txt</code></p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-number-to-more.png" alt=""></p>
<p>描述：搜索9-11个字母的单词的行。<br>命令：<code>grep -i &#39;\b[a-z]\{9,11\}\b&#39; find.txt</code></p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-number-to-number.png" alt=""></p>
<p><strong>实例：19. 使用grep匹配「与」或者「或」模式</strong><br>描述：搜索see或者in字符串所在的行。-E选项使用扩展模式匹配。|表示两边之一或者全部，可以使用任意多的|。<br>命令：<code>grep -E &#39;see|in&#39; find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-or.png" alt=""></p>
<p><strong>实例：20. 空行</strong><br>描述：搜索文件中所有的空行。结合^和<code>$</code>可查询空行。<br>命令：<code>grep -n &#39;^$&#39; find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-blank-lines.png" alt=""></p>
<p><strong>实例：21. 匹配特殊字符</strong><br>描述：搜索含有特殊含义的字符，诸如<code>$.&#39;&quot;*[]^|\+?</code>，必须在特定字符前加\。<br>命令：<code>grep &quot;\^&quot; find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-punct.png" alt=""></p>
<p><strong>实例：22. 分组</strong><br>描述：如果Hello被匹配，则ell就被存储到内存中，并标记为1，然后搜索任意个字符（.*），这些字符后面紧跟着另外一个ell（\1），找到就显示该行。如果用egrep或grep -E，就不用”\”号进行转义，直接写成’H(ell)o.*\1’就可以了。<br>命令：<code>grep -i &#39;H\(ell\)o.*\1&#39; find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-group.png" alt=""></p>
<p><strong>实例：23. 复杂情况</strong><br>描述：搜索以tion，tions，come，comes结尾的单词。<br>命令：<code>egrep &quot;([a-z]*tion|come)(s)?&quot; find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-regex-complication.png" alt=""></p>
<!-- 使用 -f 用文件指定待查找的模式 https://linux.cn/article-5453-1.html -->
<h2 id="POSIX用法"><a href="#POSIX用法" class="headerlink" title="POSIX用法"></a>POSIX用法</h2><p><strong>实例：24. 搜索以字母或数字（Alphanumeric）开头的行</strong><br>描述：起始于[A-Z]，[a-z]，[0-9]。<br>命令：<code>grep &quot;^[[:alnum:]]&quot; iweeek</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-alphanumeric.png" alt=""></p>
<p><strong>实例：25. 搜索以字母（Alpha）开头的行</strong><br>描述：起始于[A-Z]，[a-z]。<br>命令：<code>grep &quot;^[[:alpha:]]&quot; iweeek</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-alpha.png" alt=""></p>
<p><strong>实例：26. 搜索以空白（Blank）字符串开头的行</strong><br>描述：起始于[Tab &amp; Space]。<br>命令：<code>grep &quot;^[[:blank:]]&quot; iweeek</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-blank.png" alt=""></p>
<p><strong>实例：27. 搜索以数字（Digit）字符串开头的行</strong><br>描述：起始于[0-9]。<br>命令：<code>grep &quot;^[[:digit:]]&quot; iweeek</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-digit.png" alt=""></p>
<p><strong>实例：28. 搜索以小写字母（Lower）字符串开头的行</strong><br>描述：起始于[a-z]。<br>命令：<code>grep &quot;^[[:lower:]]&quot; iweeek</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-lowercase.png" alt=""></p>
<p><strong>实例：29. 搜索以大写字母（Uppercase）字符串开头的行</strong><br>描述：起始于[A-Z]。<br>命令：<code>grep &quot;^[[:upper:]]&quot; iweeek</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-uppercase.png" alt=""></p>
<p><strong>实例：30. 搜索以标点符号（Punctuation）字符串开头的行</strong><br>描述：起始于[! ” # $ % &amp; ‘ ( ) * + , – . / : ; &lt; = &gt; ? @ [ \ ] ^ _ <code>{ | } ~. ]。
命令：</code>grep “^[[:puct:]]” iweeek`<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-punctuation.png" alt=""></p>
<p><strong>实例：31. 搜索图形符号</strong><br>描述：字母数字和标点符号统称为图形字符。<br>命令：<code>grep &quot;^[[:graph:]]&quot; iweeek</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-graphical.png" alt=""></p>
<p><strong>实例：32. 搜索可打印的字符（Printable Characters）</strong><br>描述：可打印的字符包括：字母数字，标点符号和空格字符。<br>命令：<code>grep &quot;^[[:print:]]&quot; iweeek</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-printable.png" alt=""></p>
<p><strong>实例：33. 搜索空格字符（Space Characters）</strong><br>描述：类似于[tab, newline, vertical tab, form feed, carriage return, and space]。<br>命令：<code>grep &quot;^[[:space:]]&quot; iweeek</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-space.png" alt=""></p>
<p><strong>实例：34. 搜索以十六进制（Hexadecimal）字符串开头的行</strong><br>描述：起始于[0-9, A-F and a-f]。<br>命令：<code>grep &quot;^[[:xdigit:]]&quot; iweeek</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/grep/grep-hexadecimal.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/08/linux/daily-command-find/</loc>
    <lastmod>2018-06-22T01:14:30.912Z</lastmod>
    <data>
        <display>
        <title>Linux find总结</title>
        <pubTime>2018-06-08T06:03:42.000Z</pubTime>
      
         <content><p>find命令根据指定的条件查找文件和目录。查找可用于多种条件，例如通过权限，用户，组，文件类型，日期，大小和其他可能的条件来查找文件。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>find pathname [options] [-print -exec -ok]</code></p>
<p>参数解释：<br>pathname：find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。<br>-print：find命令将匹配的文件输出到标准输出。<br>-exec：find命令将匹配的文件执行该参数所给出的shell命令。相应的命令的形式为’command’ {} \;，注意{}和\;之间的空格。<br>-ok：和-exec的作用相同，但会以一种更加安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>find命令可以在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- -amin&lt;分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；</span><br><span class="line">- -anewer&lt;参考文件或目录&gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；</span><br><span class="line">- -atime&lt;24小时数&gt;：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；</span><br><span class="line">- -cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录；</span><br><span class="line">- -cnewer&lt;参考文件或目录&gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</span><br><span class="line">- -ctime&lt;24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；</span><br><span class="line">- -daystart：从本日开始计算时间；</span><br><span class="line">- -depth：从指定目录下最深层的子目录开始查找；</span><br><span class="line">- -delete：删除文件，默认实现了depth选项。注意不要将delete放在find条件语句之前，不然有可能在执行查找之前，将该目录下的所有文件删除。</span><br><span class="line">- -expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；</span><br><span class="line">- -exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；执行指令将为每一个匹配的文件执行一次。</span><br><span class="line">- -false：将find指令的回传值皆设为False；</span><br><span class="line">- -fls&lt;列表文件&gt;：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；</span><br><span class="line">- -follow：排除符号连接；</span><br><span class="line">- -fprint&lt;列表文件&gt;：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；</span><br><span class="line">- -fprint0&lt;列表文件&gt;：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；</span><br><span class="line">- -fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；</span><br><span class="line">- -fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；</span><br><span class="line">- -gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录；</span><br><span class="line">- -group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录；</span><br><span class="line">- -help或——help：在线帮助；</span><br><span class="line">- -ilname&lt;范本样式&gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；</span><br><span class="line">- -iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；</span><br><span class="line">- -inum&lt;inode编号&gt;：查找符合指定的inode编号的文件或目录；</span><br><span class="line">- -ipath&lt;范本样式&gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；</span><br><span class="line">- -iregex&lt;范本样式&gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；</span><br><span class="line">- -links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录；</span><br><span class="line">- -iname&lt;范本样式&gt;：指定字符串作为寻找符号连接的范本样式；</span><br><span class="line">- -ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；</span><br><span class="line">- -maxdepth&lt;目录层级&gt;：设置最大目录层级；</span><br><span class="line">- -mindepth&lt;目录层级&gt;：设置最小目录层级；</span><br><span class="line">- -mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；</span><br><span class="line">- -mount：此参数的效果和指定“-xdev”相同；</span><br><span class="line">- -mtime&lt;24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；</span><br><span class="line">- -name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</span><br><span class="line">- -newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</span><br><span class="line">- -nogroup：找出不属于本地主机群组识别码的文件或目录；</span><br><span class="line">- -noleaf：不去考虑目录至少需拥有两个硬连接存在；</span><br><span class="line">- -nouser：找出不属于本地主机用户识别码的文件或目录；</span><br><span class="line">- -ok&lt;执行指令&gt;：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；</span><br><span class="line">- -path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；</span><br><span class="line">- -perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录；</span><br><span class="line">- -print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；</span><br><span class="line">- -print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；</span><br><span class="line">- -printf&lt;输出格式&gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；</span><br><span class="line">- -prune：不寻找字符串作为寻找文件或目录的范本样式;</span><br><span class="line">- -regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</span><br><span class="line">- -size&lt;文件大小&gt;：查找符合指定的文件大小的文件；</span><br><span class="line">- -true：将find指令的回传值皆设为True；</span><br><span class="line">- -typ&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；</span><br><span class="line">- -uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；</span><br><span class="line">- -used&lt;日数&gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；</span><br><span class="line">- -user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；</span><br><span class="line">- -version或——version：显示版本信息；</span><br><span class="line">- -xdev：将范围局限在先行的文件系统中；</span><br><span class="line">- -xtype&lt;文件类型&gt;：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。</span><br><span class="line">动作参数：</span><br></pre></td></tr></table></figure>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p>按照查找条件的不同，可以将 44 个查找命令示例分为五个部分。</p>
<ul>
<li><a href="#第一部分：根据名称查找文件"><em>第一部分：根据名称查找文件</em></a></li>
<li><a href="#第二部分：根据权限查找文件"><em>第二部分：根据权限查找文件</em></a></li>
<li><a href="#第三部分：根据所有者和组查找文件"><em>第三部分：根据所有者和组查找文件</em></a></li>
<li><a href="#第四部分：根据日期和时间查找"><em>第四部分：根据日期和时间查找</em></a></li>
<li><a href="#第五部分：根据大小查找文件和目录"><em>第五部分：根据大小查找文件和目录</em></a></li>
<li><a href="#第六部分：根据文件内容或路径查找"><em>第六部分：根据文件内容或路径查找</em></a></li>
<li><a href="#第七部分：借助exec或ok选项来执行shell命令"><em>第七部分：借助exec或ok选项来执行shell命令</em></a></li>
</ul>
<h2 id="第一部分：根据name或type查找文件"><a href="#第一部分：根据name或type查找文件" class="headerlink" title="第一部分：根据name或type查找文件"></a>第一部分：根据name或type查找文件</h2><p><strong>实例：1. 列出当前目录及子目录下所有文件和文件夹</strong><br>命令：<code>find . 等同于 find . -name &quot;*&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-all.png" alt=""></p>
<p><strong>实例：2. 指定目录下使用名称查找文件</strong><br>描述：在当前目录下查找名字（name）为find.txt的文件。<br>命令：<code>find . -name find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-name.png" alt=""></p>
<p><strong>实例：3. 使用名称查找文件并忽略大小写</strong><br>描述：在当前目录找到名称为find.txt的文件，忽略大小写(iname)。<br>命令：<code>find . -iname find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-iname.png" alt=""></p>
<p><strong>实例：4. 根据文件类型查找</strong></p>
<p>形式：find . -type 类型参数</p>
<p>类型参数列表：</p>
<ul>
<li>f：普通文件</li>
<li>l：符号连接</li>
<li>d：目录</li>
<li>c：字符设备</li>
<li>b：块设备</li>
<li>s：套接字</li>
<li>p: Fifo</li>
</ul>
<p>描述：在指定目录中找到名称为find（name find）的文件（type f）。<br>命令：<code>find / -type f -name find</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-type-f.png" alt=""></p>
<p>描述：在指定目录中找到名称为findd（name findd）的目录（type d）。<br>命令：<code>find / -type d -name findd</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-type-d.png" alt=""></p>
<p><strong>实例：5. 根据目录深度搜索</strong></p>
<p>描述：从文件系统的根目录开始，查找一个名为xyz.txt的文件，find将首先匹配所有的文件然后再进入子目录中查找。<br>命令：<code>find / -depth -name &quot;xyz.txt&quot;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-depth.png" alt=""></p>
<p>描述：搜索出深度距离当前目录最多3个子目录的所有文件。<br>命令：<code>find /home/nijun -maxdepth 3 -type f</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-maxdepth.png" alt=""></p>
<p>描述：搜索出深度距离当前目录至少2个子目录的所有文件。<br>命令：<code>find /home/nijun -mindepth 2 -type f</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-mindepth.png" alt=""></p>
<p><strong>实例：5. 使用通配符查找文件</strong><br>描述：在指定目录中找到所有以.txt或(-o).mp3结尾的文件。<br>命令：<code>find . -type f -name &quot;*.txt&quot; -o -name &quot;*.mp3&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-name-or.png" alt=""></p>
<p>描述：在当前目录查找文件名以两个小写字母开头，跟着是两个数字，最后是*.txt的文件。-print选项会输出到标准输出中。<br>命令：<code>find . -name &quot;[a-z][a-z][0-9][0-9].txt&quot; -print</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-name-wildcard.png" alt=""></p>
<h2 id="第二部分：根据权限查找文件"><a href="#第二部分：根据权限查找文件" class="headerlink" title="第二部分：根据权限查找文件"></a>第二部分：根据权限查找文件</h2><p><strong>实例：6. 查找符合指定的权限数值的文件或目录</strong><br>描述：查找权限为777的文件。-print将文件或目录的名称列出到标准输出，格式为每列一个名称。<br>命令：<code>find . -type f -perm 777 -print</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-perm.png" alt=""></p>
<p><strong>实例：7. 查找不符合指定的权限数值的文件或目录</strong><br>描述：查找权限不为777的文件。<br>命令：<code>find . -type f ! -perm 777</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-!-perm.png" alt=""></p>
<p><strong>实例：8. 查找所有权限为644的SGID文件</strong><br>描述：在指定目录中找到名称为find的文件。<br>命令：<code>find . -perm 2644</code></p>
<p><strong>实例：9. 查找所有权限为551的Stickt Bit文件</strong><br>命令：<code>find / -perm 1511</code></p>
<p><strong>实例：10. 找到所有SUID文件</strong><br>命令：<code>find / -perm /u=s</code></p>
<p><strong>实例：11. 找到所有SGID文件</strong><br>命令：<code>find / -perm /g=s</code></p>
<p><strong>实例：12. 查找所有只读文件</strong><br>命令：<code>find . -perm /u=r</code></p>
<p><strong>实例：13. 查找所有可执行文件</strong><br>命令：<code>find . -perm /a=x</code></p>
<p><strong>实例：13. 查找对所有人可读的文件</strong><br>描述：在主目录中查找对所有人可读的文件。<br>命令：<code>find ~ -perm -o=r</code></p>
<p><strong>实例：14. 查找所有权限为777的文件，将其改为644</strong><br>命令：<code>find / -type f -perm 0777 -print -exec chmod 644{} \;</code></p>
<p><strong>实例：15. 查找所有权限为777的目录，将其改为755</strong><br>命令：<code>find / -type d -perm 777 -print -exec chmod 755{} \;</code></p>
<p><strong>实例：16. 查找并删除单个文件</strong><br>命令：<code>find . -type f -name &quot;test.log&quot; -exec rm -f {} \;</code></p>
<p><strong>实例：17. 查找并删除多个文件</strong><br>命令：<code>find . -type f -name &quot;*.txt&quot; -exec rm -f {} \;</code></p>
<p><strong>实例：18. 查找所有空文件</strong><br>命令：<code>find . -type f -empty</code></p>
<p><strong>实例：19. 查找所有空目录</strong><br>命令：<code>find . -type d -empty</code></p>
<p><strong>实例：20. 查找所有隐藏文件</strong><br>描述：在当前目录下查找所有隐藏文件（dotfile）。<br>命令：<code>find . -type f -name &quot;.*&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-dotfile.png" alt=""></p>
<p><strong>实例：20. 忽略某个目录</strong><br>描述：-prune选项指出需要忽略的目录，如果使用了-depth选项，那么-prune选项会被find命令忽略。<br>命令：<code>find . -name &quot;best&quot; -prune -o -print</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-prune.png" alt=""></p>
<h2 id="第三部分：根据所有者和组查找文件"><a href="#第三部分：根据所有者和组查找文件" class="headerlink" title="第三部分：根据所有者和组查找文件"></a>第三部分：根据所有者和组查找文件</h2><p><strong>实例：21. 查找基于用户的单个文件</strong><br>描述：查找文件属主为root的find.txt文件。-user指定文件拥有者的名字，也可以是UID。<br>命令：<code>find . -user root -name find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-user-name.png" alt=""></p>
<p><strong>实例：22. 查找所有用户文件</strong><br>命令：<code>find . -user root</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-user.png" alt=""></p>
<p><strong>实例：22. 查找没有有效账户的文件</strong><br>描述：-nouser选项查找那些属主在/etc/passwd文件中没有有效账户的文件。<br>命令：<code>find /home -nouser -print</code></p>
<p><strong>实例：23. 查找基于组的文件</strong><br>命令：<code>find . -group root</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-group.png" alt=""></p>
<p><strong>实例：22. 查找没有有效用户组的文件</strong><br>描述：-nogroup选项查找没有有效所属用户组的所有文件。<br>命令：<code>find / -nogroup -print</code> </p>
<p><strong>实例：24. 查找用户特定的文件</strong><br>命令：<code>find . -user root -iname &quot;*.txt&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-user-wildcard.png" alt=""></p>
<h2 id="第四部分：根据日期和时间查找"><a href="#第四部分：根据日期和时间查找" class="headerlink" title="第四部分：根据日期和时间查找"></a>第四部分：根据日期和时间查找</h2><p>形式：<code>find . -type f 时间戳</code></p>
<p>UNIX/Linux文件系统每个文件都有三种时间戳：</p>
<ul>
<li>访问时间 （-atime/天，-amin/分钟）：用户最近一次访问时间。</li>
<li>修改时间 （-mtime/天，-mmin/分钟）：文件最后一次修改时间。</li>
<li>变化时间 （-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</li>
</ul>
<p>除非你确切地知道你想要的时间，否则可能需要在 + （大于）或 - （小于）的后面加上数字。</p>
<p>/home/nijun/images目录中文件:<br><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-ls.png" alt=""></p>
<p><strong>实例：25. 查找3天以前被修改过的所有文件</strong><br>命令：<code>find . -mtime +3</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-mtime-after.png" alt=""></p>
<p><strong>实例：26. 查找5天以内被访问过的所有文件</strong><br>命令：<code>find . -atime -5</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-atime-before.png" alt=""></p>
<p><strong>实例：26. 查找恰好4天前访问过的文件</strong><br>命令：<code>find . -atime 4</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-atime.png" alt=""></p>
<p><strong>实例：27. 查找2-7天前访问过的文件</strong><br>描述：在当前目录中查找两天以前，七天以内的文件。<br>命令：<code>find . -mtime +2 -mtime -7</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-mtime-between.png" alt=""></p>
<p><strong>实例：28. 查找在1小时之内改变过（Changed）的文件或目录</strong><br>描述：在当前目录查找在1小时之内改变过的文件或目录，mmin和amin同理。<br>命令：<code>find . -cmin -60</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-c.png" alt=""></p>
<p><strong>实例：30. 查找比某个文件新或旧的文件</strong><br>一般形式：newest_file_name ! oldest_file_name<br>描述：查找更改时间比文件brooke-lark-275181.jpg新但比文件abc.txt旧的所有文件。<br>命令：<code>find . -type f -newer brooke-lark-275181.jpg ! -newer abc.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-newer.png" alt=""></p>
<p><strong>实例：30. 新建指定时间戳文件查找时间范围内的文件</strong><br>描述：使用touch -t命令新建一个自定义时间戳（6月6日8点30分）的文件，用来满足时间范围查找的要求。然后查找比这个文件更新的文件或目录。<br>命令：<code>touch -t 06060830 dstamp</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-touch.png" alt=""></p>
<p>命令：<code>find . -newer det/dstamp  -print</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-newfile-newer.png" alt=""></p>
<p><strong>实例：30. 筛选出上周拍的照片</strong><br>描述：在/home/nijun目录下，忽略大小写地查找以.jpeg和.jpg为后缀的，修改时间在七天以内的所有文件。<br>命令：<code>find /home/nijun -iname &#39;*.jpeg&#39; -o -iname &#39;*.jpg&#39; -type f -mtime -7</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-images.png" alt=""></p>
<h2 id="第五部分：根据大小查找文件和目录"><a href="#第五部分：根据大小查找文件和目录" class="headerlink" title="第五部分：根据大小查找文件和目录"></a>第五部分：根据大小查找文件和目录</h2><p>形式：<code>find . -type f -size 文件大小单元</code></p>
<p>文件大小单元：</p>
<ul>
<li>b —— 块（512字节）</li>
<li>c —— 字节</li>
<li>w —— 字（2字节）</li>
<li>k —— 千字节</li>
<li>M —— 兆字节</li>
<li>G —— 吉字节</li>
</ul>
<p><strong>实例：31. 查找文件大小恰好等于31MB的所有文件</strong><br>描述：在当前目录下查找文件大小恰好等于31MB的所有文件。<br>命令：<code>find . -size 31M</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-size.png" alt=""></p>
<p><strong>实例：31. 查找文件大小小于10MB的文件</strong><br>描述：在当前目录下查找文件大小小于10MB的所有文件。<br>命令：<code>find . -size 10M</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-size-smaller.png" alt=""></p>
<p><strong>实例：31. 查找文件大小大于5MB的文件</strong><br>描述：在当前目录下查找文件大小大于5MB的所有文件。<br>命令：<code>find . -size +5M</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-size-bigger.png" alt=""></p>
<p><strong>实例：32. 查找所有大小在5MB-10MB之间的文件</strong><br>描述：在当前目录下查找文件大小在5MB到10MB的所有文件。<br>命令：<code>find . -size +5M -size -10M</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-size-between.png" alt=""></p>
<p><strong>实例：33. 查找并删除巨大的（假设大于1G）文件</strong><br>描述：-delete选项可以代替rm命令删除查找到的文件。<br>命令：<code>find . -size +1G -exec rm -rf {} \;</code><br>或者：<code>find . -size +1G -delete</code></p>
<p><strong>实例：34. 查找指定文件并删除</strong><br>描述：查找以.mp3为后缀，文件大于10M（-size +10M）的所有文件（-type f），并执行（-exec）删除命令删除之。<br>命令：<code>find . -type f -name *.mp3 -size +10M -exec rm {} \;</code></p>
<h2 id="第六部分：根据文件内容或路径查找"><a href="#第六部分：根据文件内容或路径查找" class="headerlink" title="第六部分：根据文件内容或路径查找"></a>第六部分：根据文件内容或路径查找</h2><p><strong>实例：35. 根据文件内容查找</strong><br>描述：查找当前目录下的所有文件中，内容含有hello的所有行。<br>命令：<code>find . -type f -name &quot;*&quot; | xargs grep &quot;hello&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-type-f-xargs-grep.png" alt=""></p>
<p><strong>实例：36. 匹配文件路径或者文件</strong><br>描述：查找/usr目录下所有路径中带有local字样的文件或目录。<br>命令：<code>find /usr/ -path &quot;*local*&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-path.png" alt=""></p>
<p><strong>实例：37. 基于正则表达式匹配文件路径</strong><br>描述：用-regex查找以.txt或.mp3结尾的文件。-iregex则是忽略大小写。<br>命令：<code>find . -regex &quot;.*\(\.txt\|\.mp3\)$&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-regex.png" alt=""></p>
<p><strong>实例：38. 使用mount选项</strong><br>描述：在当前的文件系统中查找文件（不进入其他文件系统）查找以.txt结尾的文件。<br>命令：<code>find . -mount -name &quot;*.txt&quot;  -print</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-mount.png" alt=""></p>
<h2 id="第七部分：借助exec或ok选项来执行shell命令"><a href="#第七部分：借助exec或ok选项来执行shell命令" class="headerlink" title="第七部分：借助exec或ok选项来执行shell命令"></a>第七部分：借助exec或ok选项来执行shell命令</h2><p><strong>实例：38. 与chown命令结合使用</strong><br>描述：找出当前目录下所有root的文件，并把所有权更改为用户jack。 {} 用于与 -exec 选项结合使用来匹配所有文件，然后会被替换为相应的文件名。<br>命令：<code>find . -type f -user root -exec chown jack {} \;</code></p>
<p><strong>实例：39. 与rm命令结合使用</strong><br>描述：找出当前目录下最近一天内修改的所有文件并删除它们。-ok 和 -exec 行为一样，不过它会给出提示，是否执行相应的操作。按y键删除文件，按n键不删除。<br>命令：<code>find . -mtime -1 -ok rm {} \;</code></p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-ok-rm.png" alt=""></p>
<p><strong>实例：40. 与cat命令结合使用</strong><br>描述：查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中。<br>命令：<code>find . -type f -name &quot;*.txt&quot; -exec cat {} \; &gt; all.txt</code></p>
<p><strong>实例：41. 与cp结合使用</strong><br>描述：查找当前目录下30天以前并且以.log结尾的文件，将它们拷贝到./old目录中。<br>命令：<code>find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp {} old \;</code></p>
<p><strong>实例：41. 与grep结合使用</strong><br>描述：查找/etc目录下名字带有passwd的文件中，含有nijun字样的内容。<br>命令：<code>find /etc -name &quot;passwd*&quot; -exec grep &quot;nijun&quot; {} \;</code></p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/find/find-grep.png" alt=""></p>
<p><strong>实例：42. 与printf结合使用</strong><br>描述：找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来。<br>命令：<code>find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; {} \;</code></p>
<p><strong>实例：43. 执行多条命令</strong><br>描述：因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令。<br>命令：<code>-exec ./text.sh {} \;</code></p>
<p><strong>实例：44. 搜索但跳出指定的目录</strong><br>描述：查找当前目录或者子目录下所有.txt文件，但是跳过子目录output。<br>命令：<code>find . -path &quot;./output&quot; -prune -o -name &quot;*.txt&quot; -print;</code></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/11/linux/daily-command-du/</loc>
    <lastmod>2018-06-22T01:12:42.564Z</lastmod>
    <data>
        <display>
        <title>Linux du总结</title>
        <pubTime>2018-06-10T21:50:41.000Z</pubTime>
      
         <content><p>du命令显示文件和目录的磁盘使用空间。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>du [选项] [文件]</p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>du（disk usage 的简称）命令用于检查计算机上文件和目录的磁盘使用情况，可以递归显示文件和目录。显示每个文件和目录的磁盘使用空间。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-a或-all：显示目录中个别文件的大小。   </li>
<li>-b或-bytes：显示目录或文件大小时，以byte为单位。   </li>
<li>-c或–total：除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 </li>
<li>-k或–kilobytes：以KB(1024bytes)为单位输出。</li>
<li>-m或–megabytes：以MB为单位输出。   </li>
<li>-s或–summarize：仅显示总计，只列出最后加总的值。</li>
<li>-h或–human-readable：以K，M，G为单位，提高信息的可读性。</li>
<li>-x或–one-file-xystem：以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 </li>
<li>-L&lt;符号链接&gt;或–dereference&lt;符号链接&gt;：显示选项中所指定符号链接的源文件大小。   </li>
<li>-S或–separate-dirs：显示个别目录的大小时，并不含其子目录的大小。 </li>
<li>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt;：在&lt;文件&gt;指定目录或文件。   </li>
<li>–exclude=&lt;目录或文件&gt;：略过指定的目录或文件。    </li>
<li>-D或–dereference-args ：显示指定符号链接的源文件大小。   </li>
<li>-H或–si：与-h参数相同，但是K，M，G是以1000为换算单位。   </li>
<li>-l或–count-links：重复计算硬件链接的文件。  </li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 找出 <code>/root</code> 目录树及其每个子目录的磁盘使用情况摘要</strong><br>描述：以下命令的输出显示了 <code>/root</code> 目录以及其子目录的磁盘块数。<br>命令：du /root<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/du/du-path.png" alt=""></p>
<p><strong>实例：2. 以人类可读格式也就是 kb、mb 等显示文件/目录大小</strong><br>命令：du -h /root<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/du/du-h-path.png" alt=""></p>
<p><strong>实例：3. 目录的总磁盘使用大小摘要</strong><br>命令：du -s /root<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/du/du-s-path.png" alt=""></p>
<p><strong>实例：4. 所有文件和目录的磁盘使用情况</strong><br>命令：du -a /root<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/du/du-a-path.png" alt=""></p>
<p><strong>实例：5. 总的使用磁盘空间</strong><br>描述：-c选项在最后一行提供了一个总的使用磁盘空间。<br>命令：du -c /root<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/du/du-c-path.png" alt=""></p>
<p><strong>实例：6. 排除给定模式的文件或目录</strong><br>描述：在计算/root的总大小时排除.ssh文件。<br>命令：du -h –exclude=”.ssh” /root<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/du/du-h-exclude-path.png" alt=""></p>
<p><strong>实例：7. 根据修改时间显示磁盘使用情况</strong><br>描述：在计算/root的总大小时排除.ssh文件。<br>命令：du -h –exclude=”.ssh” /root<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/du/du-time.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/11/linux/daily-command-df/</loc>
    <lastmod>2018-06-22T01:11:49.538Z</lastmod>
    <data>
        <display>
        <title>Linux df总结</title>
        <pubTime>2018-06-10T22:16:12.000Z</pubTime>
      
         <content><p>df命令用于显示文件系统磁盘空间使用情况。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>df [选项] [文件]</p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>df（disk filesystem 的简称）用于显示文件系统磁盘空间使用情况。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-a或–all：全部文件系统列表。</li>
<li>-h或–human-readable：方便阅读方式显示。</li>
<li>-H或–si：等于“-h”，但是计算式，1K=1000，而不是1K=1024。</li>
<li>-i或–inodes：显示inode信息。</li>
<li>-k或–kilobytes：区块为1024字节。</li>
<li>-l或–local：只显示本地文件系统。</li>
<li>-m或–megabytes：区块为1048576字节。</li>
<li>–no-sync：忽略sync命令。</li>
<li>-P或–portability：输出格式为POSIX。</li>
<li>–sync：在取得磁盘信息前，先执行sync命令。</li>
<li>-T或–print-type：文件系统类型。</li>
<li>–block-size=&lt;区块大小&gt;：指定区块大小。</li>
<li>-t&lt;文件系统类型&gt;或–type=&lt;文件系统类型&gt;：只显示选定文件系统的磁盘信息。</li>
<li>-x&lt;文件系统类型&gt;或–exclude-type=&lt;文件系统类型&gt;：不显示选定文件系统的磁盘信息。</li>
<li>–help：显示帮助信息。</li>
<li>–version：显示版本信息。</li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 检查文件系统磁盘空间使用情况</strong><br>描述：显示设备名称、总块数、总磁盘空间、已用磁盘空间、可用磁盘空间和文件系统上的挂载点。<br>命令：df<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/df/df.png" alt=""></p>
<p><strong>实例：2. 以人类可读的格式显示磁盘使用情况</strong><br>描述：以人类可读格式显示信息。<br>命令：df -h<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/df/df-h.png" alt=""></p>
<p><strong>实例：3. 检查所有文件系统磁盘使用空间信息</strong><br>描述：与上述相同，但它也显示虚拟文件系统的信息以及所有文件系统磁盘使用情况和内存使用情况。<br>命令：df -a<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/df/df-a.png" alt=""></p>
<p><strong>实例：4. 显示文件系统的类型</strong><br>描述：以人类可读格式（h）显示文件系统的类型（T）信息。<br>命令：df -hT<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/df/df-hT.png" alt=""></p>
<p><strong>实例：5. 检查特定分区的信息</strong><br>描述：-hT将以可读格式显示/root的信息。<br>命令：df -hT /root<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/df/df-hT-path.png" alt=""></p>
<p><strong>实例：6. 筛选指定的文件系统类型</strong><br>描述：筛选文件系统类型为ext4的磁盘使用情况。<br>命令：df -t ext4 -hT<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/df/df-t.png" alt=""></p>
<p><strong>实例：7. 排除指定的文件系统类型</strong><br>描述：排除文件系统类型为ext4的磁盘，显示剩下的磁盘类型使用情况。<br>命令：df -x ext4 -hT<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/df/df-x.png" alt=""></p>
<p><strong>实例：8. 显示文件系统的inodes信息</strong><br>描述：-i选项显示文件系统使用的inode数量及其百分比的信息。<br>命令：df -i<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/df/df-i.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/10/linux/daily-command-cat/</loc>
    <lastmod>2018-06-22T01:10:14.536Z</lastmod>
    <data>
        <display>
        <title>Linux cat总结</title>
        <pubTime>2018-06-10T15:58:31.000Z</pubTime>
      
         <content><p>cat命令可以创建单个或多个文件，查看文件的内容和控制字符，连接文件以及在终端或文件中重定向输出。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>cat [选项] [文件]</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>cat（concatenate）命令可以创建单个或多个文件，查看文件的内容和控制字符，连接文件以及在终端或文件中重定向输出。<br>cat命令不会在文件分页处停下来，而是一下子显示完整整个文件。如果希望每次显示一页，可以使用more命令或把cat命令的输出通过管道传递到另外一个具有分页功能的命令中。</p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-n或-number：显示行号。</li>
<li>-b或–number-nonblank：和-n相似，只不过对于空白行不编号。</li>
<li>-s或–squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。</li>
<li>-A：显示不可打印字符，行尾显示$，等价于-vET。</li>
<li>-v或–show-nonprinting：使用^和M-引用，除了LFD和TAB之外。</li>
<li>-E或–show-ends：在每行结束处显示$。</li>
<li>-e：等价于”-vE”选项。</li>
<li>-T或–show-tabs 将TAB字符显示为^I。</li>
<li>-t：显示 tab 分隔符，等价于”-vT”选项。</li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 显示文件的内容</strong><br>描述：打印passwd文件的所有内容。<br>命令：<code>cat /etc/passwd</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-file.png" alt=""></p>
<p><strong>实例：2. 查看终端中多个文件的内容</strong><br>描述：打印linux.txt和Find.txt两个文件的内容。<br>命令：<code>cat linux.txt Find.txt</code><br>等同于：<code>cat linux.txt; cat Find.txt;</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-mul-file.png" alt=""></p>
<p><strong>实例：3. 从文件中读入内容</strong><br>描述：从文件fairy中读取内容，通过cat显示到标准输出上。cat默认是加上&lt;操作符。<br>命令：<code>cat &lt; fairy</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-read.png" alt=""></p>
<p><strong>实例：4. 与more或less命令配合使用</strong><br>描述：输入完成后，按CTRL+D退出输入。输入的内容通过IO重定向创建文件被写入到test文件中。<br>命令：<code>cat /etc/passwd | more</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-more.png" alt=""></p>
<p><strong>实例：5. 显示行号</strong><br>描述：在打印的行前加上行号，从1开始。<br>命令：<code>cat -n fairy</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-n.png" alt=""></p>
<p><strong>实例：6. 在结尾显示<code>$</code>符号</strong><br>描述：<code>$</code>符号将出现在每行的末尾和每个空行之间，这个选项有助于压缩行数。<br>命令：<code>cat -e fairy</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-e.png" alt=""></p>
<p><strong>实例：7. 显示TAB分隔符</strong><br>描述：TAB空格将以^I显示。<br>命令：<code>cat -T test</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-T.png" alt=""></p>
<p><strong>实例：8. 通过IO重定向创建文件</strong><br>描述：输入完成后，按CTRL+D退出输入。输入的内容通过IO重定向创建文件被写入到test文件中。<br>命令：<code>cat &gt; test</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-to-file.png" alt=""></p>
<p><strong>实例：9. 使用重定向机制追加到文件中</strong><br>描述：将文件aa的内容追加到文件bb中。<br>命令：<code>cat aa &gt;&gt; bb</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-append.png" alt=""></p>
<p><strong>实例：10. 重定向多个文件到一个文件中</strong><br>描述：将文件aa和bb的内容合并输入到cc文件中。若cc不存在，则创建，若存在，则覆盖它。<br>命令：<code>cat aa bb &gt; cc</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-merge.png" alt=""></p>
<p><strong>实例：11. 重定向多个文件到一个文件中并排序</strong><br>描述：将文件aa，bb和cc的内容合并，通过管道并排序后输入到dd文件中。若dd不存在，则创建，若存在，则覆盖它。<br>命令：<code>cat aa bb cc | sort &gt; dd</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-merge-and-sort.png" alt=""></p>
<p><strong>实例：12. 在/home/$USER/iweeek创建一个文件并填入内容</strong><br>描述：在/home/$USER/Desktop创建一个文件（例如 test）并填入以下内容。要求创建，编辑，输入内容这些操作一步完成。<br>命令：<code>cat &lt;&lt; EOF &gt; /home/$USER/iweeek/test</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/cat/cat-redirection.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/09/linux/daily-command-awk/</loc>
    <lastmod>2018-06-22T01:09:55.482Z</lastmod>
    <data>
        <display>
        <title>Linux awk总结</title>
        <pubTime>2018-06-09T08:17:44.000Z</pubTime>
      
         <content><p>awk命令在文件或字符串中基于指定规则浏览和抽取信息。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>awk是一种小巧的编程语言及命令行工具。（其名称得自于它的创始人Alfred Aho、Peter Weinberger 和 Brian Kernighan姓氏的首个字母）。它非常适合服务器上的日志处理，主要是因为awk可以对文件进行操作，通常以可读文本构建行。<br>awk命令在文件或字符串中基于指定规则浏览和抽取信息。awk抽取信息后，才能进行其他文本操作，awk脚本通常用来格式化文本文件中的信息。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>有三种方式调用awk，第一种是命令行方式，例如：<br><code>awk [-F field-separator] &#39;commands&#39; input-file(s)</code><br>awk默认使用空格作为缺省的域分隔符。如果要浏览诸如passwd文件，此文件是以冒号作为分隔符，则必须指明-F选项。例如：<br><code>awk -F : &#39;commands&#39; input-file</code><br>第二种方式是将所有awk命令插入一个文件，并使awk程序可执行，然后用awk命令解释器作为脚本的首行，以便通过键入脚本名称来调用它。<br>第三种方式是将所有的awk命令插入一个单独文件，然后调用：<br><code>awl -f awk-script-file input-file(s)</code><br>-f选项指明在文件awk-script-file中的awk脚本，input_file(s)是使用awk进行浏览的文件名。</p>
<h2 id="awk脚本"><a href="#awk脚本" class="headerlink" title="awk脚本"></a>awk脚本</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>awk脚本的代码结构很简单，就是一系列的模式（pattern）和动作（action）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># comment</span><br><span class="line">Pattern1 &#123; ACTIONS; &#125;</span><br><span class="line"># comment</span><br><span class="line">Pattern2 &#123; ACTIONS; &#125;</span><br><span class="line"># comment</span><br><span class="line">Pattern3 &#123; ACTIONS; &#125;</span><br><span class="line"># comment</span><br><span class="line">Pattern4 &#123; ACTIONS; &#125;</span><br></pre></td></tr></table></figure>
<p>扫描文档的每一行时都必须与每一个模式进行匹配比较，一次只匹配一个模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is line 1</span><br><span class="line">this is line 2</span><br></pre></td></tr></table></figure>
<p>this is line 1这行会先Pattern1进行匹配，如果匹配成功，就会执行ACTIONS。然后this is line 1会和Pattern2进行匹配，如果匹配失败，就调到Pattern3进行匹配，以此类推。<br>一旦所有的模式都匹配过了，this is line 2就会以同样的步骤进行匹配。其他的行也一样，直到读取完整个文件。这就是awk的运行模式。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>awk仅有两个主要的数据类型：字符串和数字，它们可以相互转换。<br>在ACTIONS部分使用=操作符给变量赋值，可以在任意时刻、任意地方声明和使用变量，也可以使用未初始化的变量，默认是空字符串。<br>awk有数组类型，并且它们是动态的一维关联数组。</p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式分为三大类：正则表达式、布尔表达式和特殊模式。</p>
<p>所有模式都是可选的，下面的脚本形式会对输入的每一行都会简单地执行ACRIONS。<br><code>{ ACTIONS }</code></p>
<h3 id="特殊的模式"><a href="#特殊的模式" class="headerlink" title="特殊的模式"></a>特殊的模式</h3><p>模式包括两个特殊字段：BEGIN和END。BEGIN在所有输入未被处理之前，即文本浏览动作之前进行匹配。可以初始化脚本变量和所有种类的状态的主要地方。END会在所有的输入都被处理完后，即完成文本浏览动作后进行匹配。可以在退出前进行清除工作和一些最后的输出。<br>最后一类模式，要把它进行归类有点困难。它处于变量和特殊值之间，我们通常称它们为域（Field）。而且名副其实。</p>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># According to the following line</span><br><span class="line">#</span><br><span class="line"># $1 $2 $3</span><br><span class="line"># 00:34:23 GET /foo/bar.html</span><br><span class="line"># _____________ _____________/</span><br><span class="line"># $0</span><br><span class="line"> </span><br><span class="line"># Hack attempt?</span><br><span class="line">/admin.html$/ &amp;&amp; $2 == &quot;DELETE&quot; &#123;</span><br><span class="line">print &quot;Hacker Alert!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>域（默认地）由空格分隔。$0域代表了一整行的字符串。$1 域是第一块字符串（在任何空格之前），$2\$域是后一块，以此类推。<br>awk执行时，其浏览域标记为$1, $2, $3…$n。这种方式称为域标识。使用$1, $3标识表示第1和第3域。使用$0$标识表示所有域。<br>awk浏览到一新行时，即到达域的记录末尾，执行新记录下一行的读动作，重新设置域分隔。</p>
<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>最常用和最有用的行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123; print $0; &#125; # prints $0. In this case, equivalent to &apos;print&apos; alone</span><br><span class="line">&#123; exit; &#125; # ends the program</span><br><span class="line">&#123; next; &#125; # skips to the next line of input</span><br><span class="line">&#123; a=$1; b=$0 &#125; # variable assignment</span><br><span class="line">&#123; c[$1] = $2 &#125; # variable assignment (array)</span><br><span class="line"> </span><br><span class="line">&#123; if (BOOLEAN) &#123; ACTION &#125;</span><br><span class="line">else if (BOOLEAN) &#123; ACTION &#125;</span><br><span class="line">else &#123; ACTION &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123; for (i=1; i&lt;x; i++) &#123; ACTION &#125; &#125;</span><br><span class="line">&#123; for (item in c) &#123; ACTION &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>awk里的变量都是全局变量。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的<a href="https://www.gnu.org/software/gawk/manual/html_node/Built_002din.html#Built_002din" target="_blank" rel="noopener">通用文档(regular documentation)</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; somecall($2) &#125;</span><br></pre></td></tr></table></figure>
<p>用户定义的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># function arguments are call-by-value</span><br><span class="line">function name (parameter-list) &#123;</span><br><span class="line">	ACTIONS; #same actions as usual</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># return is valid keyword</span><br><span class="line">function add (val) &#123;</span><br><span class="line">return val+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：0. 新建测试文件</strong><br>描述：新建一个device文件，其中(1)为序号，(2)为Android版本，(3)为访问时间，(4)为IP，(5)为访问次数。本文大部分实例根据这一文件进行说明。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-origin.png" alt=""></p>
<p><strong>实例：1. 抽取域</strong><br>描述：打印第1个（序号）域和第2个（Android版本）域的内容。print用来输出其后跟着的内容，用大括号把print语句括起来，表示一个打印动作。<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-partion-domain.png" alt=""></p>
<p><strong>实例：2. 打印所有记录</strong><br>描述：打印所有记录。$0代表所有域。<br>命令：<code>awk &#39;{print $0}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-$0.png" alt=""></p>
<p><strong>实例：3. 打印报告头</strong><br>描述：在序号和IP地址之间用一些空格使之更容易划分，也可以在域间使用tab键加以划分。本例中加入NO和IP两个信息头以及中划线，\n启动新行，并在\n下一行启动打印文本操作。打印信息头放置在BEGIN模式部分，因为打印信息头被界定为一个动作，必须用大括号括起来。在awk查看第一条记录前，信息头被打印。<br>命令：<code>awk &#39;BEGIN {print &quot;NO        IP\n------------------------&quot;} {print $1&quot;\t&quot;$4}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-Begin.png" alt=""></p>
<p><strong>实例：4. 打印信息尾</strong><br>描述：在末行加入end of report信息。END语句在所有文本处理动作执行完之后才被执行，在脚本中的位置是在主要动作之后。<br>命令：<code>awk &#39;BEGIN {print &quot;Version\n-------&quot;} {print $2} END {print &quot;end-of-report&quot;}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-End.png" alt=""></p>
<p><strong>实例：5. 错误信息提示</strong><br>描述：如果将在awk命令中缺少一个双引号，awk将返回错误提示信息。<br>命令：<code>awk &#39;BEGIN {print &quot;Version\n-------&quot;} {print $2} END {print &quot;end-of-report}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-error.png" alt=""></p>
<p>注意：在碰到awk错误时，应从以下几点进行排查：</p>
<ul>
<li>确保整个awk命令引用单引号括起来。</li>
<li>确保命令内所有引号成对出现。</li>
<li>确保用花括号括起动作语句，用圆括号括起条件语句。</li>
<li>可能忘记使用花括号。</li>
</ul>
<p>描述：如果查询的文件不存在，将得到以下错误信息：<br>命令：<code>awk &#39;END {print NR}&#39; device.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-file-not-found.png" alt=""></p>
<h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p><strong>实例：1. 匹配</strong><br>描述：如果field-4以数字4开头，打印它。如果条件满足，则打印匹配的记录行。符号~后紧跟正则表达式，使一域号匹配正则表达式，也可以使用if语句。awk的if后面的条件用()括起来。^尖角符号表示行首。<br>命令：<code>awk &#39;{ if ($4 ~ /^4/) print $0}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-if.png" alt=""></p>
<p>等同于：<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-same-if.png" alt=""></p>
<p><strong>实例：2. 精确匹配</strong><br>描述：精确匹配访问次数为1次的记录，确保不匹配访问次数为15次的记录。使用等号==，并用单引号括起条件，也可以使用if语句。<br>命令：<code>awk &#39;$5==&quot;1&quot; {print $0}&#39; device</code><br>或者：<code>awk &#39;{if($5==/1/) print $0}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-==.png" alt=""></p>
<p><strong>实例：3. 不匹配</strong><br>描述：不匹配IP地址以4开头的记录。使用!~表示不匹配。<br>命令：<code>awk &#39;$4 !~ /^4/&#39; device</code><br>或者：<code>awk &#39;{ if ($4 !~ /^4/) print $0}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-!~.png" alt=""></p>
<p>注意这里不能用!=，因为用引号或者/括起了^4，将只匹配4而不匹配49.65.119.165等。如果查询非49.65.119.165的记录，可做如下操作：<br><code>awk &#39;$4 != &quot;49.65.119.165&quot;&#39; device</code></p>
<p><strong>实例：4. 小于，小于等于，大于，大于等于</strong><br>描述：匹配访问次数小于序号的记录。同样的有小于等于（&lt;=），大于（&gt;），大于等于（&gt;=）。<br>命令：<code>awk &#39;$4 !~ /^4/&#39; device</code><br>或者：<code>awk &#39;{ if ($4 !~ /^4/) print $0}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-less-than.png" alt=""></p>
<p><strong>实例：5. 设置大小写</strong><br>描述：匹配含有前面是i或I，后面是OS的记录。[]符号可匹配[]内任意字符或单词。<br>命令：<code>awk &#39;/[iI]OS/&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-i.png" alt=""></p>
<p><strong>实例：6. 任意字符</strong><br>描述：匹配Android版本，第八个字符是7，打印它。表达式/^…….7/表示行首前7个字符任务，第八个是7。<br>命令：<code>awk &#39;$2 ~ /^.......7/&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-dot.png" alt=""></p>
<p><strong>实例：7. 或关系匹配</strong><br>描述：匹配IP地址以4或者3开头的记录。竖线符|意为两边模式之一。可以得到与[]表达式相同的结果。<br>命令：<code>awk &#39;$4 ~ /^(4|3)/&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-or.png" alt=""></p>
<p>注意，在使用竖线符时，语句必须用圆括号括起来。另外，除了字符重复出现外，其他的正则表达式在awk中都是合法的。</p>
<p><strong>实例：8. AND</strong></p>
<p>描述：匹配Android版本在7.0以上，并且IP地址以4开头的记录。OR，非与之类似。<br>命令：<code>awk &#39;$2 ~ /^.......7/ &amp;&amp; $4 ~ /^4/&#39; device</code><br>等同于：<code>awk &#39;{ if ($2 ~ /^.......7/ &amp;&amp; $4 ~ /^4/) print $0} &#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-&amp;&amp;.png" alt=""></p>
<h3 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h3><p>awk内置变量如下：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-builtin-variable-table-1.png" alt=""></p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-builtin-variable-table-2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123; # Can be modified by the user</span><br><span class="line">FS = &quot;,&quot;; # Field Separator</span><br><span class="line">RS = &quot;n&quot;; # Record Separator (lines)</span><br><span class="line">OFS = &quot; &quot;; # Output Filed Separator</span><br><span class="line">ORS = &quot;n&quot;; # Output Record Separator (lines)</span><br><span class="line">&#125;</span><br><span class="line">&#123; # Can&apos;t be modified by the user</span><br><span class="line">NF # Number of Fileds in the current Record (lines)</span><br><span class="line">NR # Number of Records seen so far</span><br><span class="line">ARGV / ARGC # Script Arguments</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NF：支持记录域个数，在记录被读之后再设置。<br>NR：已读的记录数。<br>FILENAME：告知系统目前正在浏览的实际文件，因为awk可以同时处理许多文件。</p>
<p><strong>实例：1. NF、NR、FILENAME</strong></p>
<p>描述：所有记录被打印，并带有记录号（第二和第三列），并在最后输出文件名。使用NF变量显示每一条读记录中有多少个域（5个），使用NR显示已读的记录数，使用FILENAME显示正在处理的文件名。<br>命令：<code>awk &#39;{print NF,NR,$0} END {print FILENAME}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-builtin-variable.png" alt=""></p>
<p><strong>实例：2. 判断文件至少有一个记录</strong></p>
<p>描述：先检查文件中至少有一个记录时才查询IP地址。<br>命令：<code>awk &#39;NR &gt; 0 &amp;&amp; $4 ~ /^4/&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-NR.png" alt=""></p>
<p><strong>实例：3. 与echo结合使用</strong></p>
<p>描述：将变量$PWD的返回值传入awk并显示其目录。需要指定域分隔符/。<br>命令：<code>echo $PWD | awk -F / &#39;{print $NF}&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-echo.png" alt=""></p>
<p>描述：显示文件名。<br>命令：<code>echo &quot;/etc/vimrc&quot; | awk -F / &#39;{print $NF}&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-show-filename.png" alt=""></p>
<h3 id="awk操作符"><a href="#awk操作符" class="headerlink" title="awk操作符"></a>awk操作符</h3><p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-operator.png" alt=""></p>
<p><strong>实例：1. 设置输入域到域变量名</strong><br>描述：赋值IP地址域为ip，版本域为version，查询版本大于7的记录，并打印IP地址和版本信息。<br>命令：<code>awk &#39;{ip=$4;version=$2; if (version ~ /*7*/) print ip&quot;&quot;version}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-set-variable.png" alt=""></p>
<p><strong>实例：2. 域值比较操作</strong><br>有两种方式测试数值域是否小于另一数值域。</p>
<ul>
<li>在BEGIN中给变量名赋值。</li>
<li>在关系操作中使用实际数值。</li>
</ul>
<p>描述：找出访问次数大于10次的所有记录。<br>命令：<code>awk &#39;{if ($5 &gt; 10) print $0}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-comparable.png" alt=""></p>
<p><strong>实例：3. 修改数值域的值</strong></p>
<p>当在awk中修改任何域时，实际输入文件是不可修改的，修改的只是保存在缓存里的awk副本，awk会在变量NR或NF变量中反映出修改痕迹。</p>
<p>描述：修改序号为6的记录，将其访问次数减一。<br>命令：<code>awk &#39;{if ($1==6) $5=$5-1; print $1, $2, $5 }&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-modify-copy-number-domain.png" alt=""></p>
<p><strong>实例：4. 修改文本域</strong></p>
<p>描述：修改序号为6的记录，将其版本修改为iOS11.2.3。修改文本域就是对其重新赋值。<br>命令：<code>awk &#39;{if ($1==6) ($2=&quot;iOS11.2.3&quot;); print $1, $2, $5 }&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-modify-text-copy-domain.png" alt=""></p>
<p><strong>实例：5. 只显示修改记录</strong></p>
<p>描述：只显示修改后序号为6的记录。<br>命令：<code>awk &#39;{if ($1==6) {$2=&quot;iOS11.2.3&quot;; print $2}; }&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-modify-and-only-show-modified.png" alt=""></p>
<p><strong>实例：6. 创建新的输出域</strong></p>
<p>描述：创建新域6保存目前访问次数大于序号的减法值，表达式为’{$6=$5-$1}’，只打印其值大于零的序号和其新域值。在BEGIN部分加入tab键以对齐报告头。也可以赋给新域更有意义的变量名。<br>命令：<code>awk &#39;BEGIN {print &quot;IP\t Difference&quot;} {if ($5 &gt; $1) {$6=$5-$1; print $1 &quot;\t&quot; $6}}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-add-new-domain.png" alt=""></p>
<p><strong>实例：7. 增加列值</strong></p>
<p>描述：使用+=累加访问次数的值。awk的每一个操作匹配时，如果没有说明打印记录，那默认会打印所有记录。<br>命令：<code>awk &#39;(total+=$5); END {print &quot;total visits : &quot; total}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-add-column-value.png" alt=""></p>
<p><strong>实例：8. 文件长度相加</strong></p>
<p>描述：查看当前目录中所有文件的长度及其综合，但要排除子目录，使用ls -l命令，然后管道输出到awk，awk首先剔除首字符d（/^[^d]/）的记录，然后将文件长度相加，并输出每一文件长度及在END部分输出所有文件的长度。<br>命令：<code>ls -l | awk &#39;/^[^d]/ {print $9&quot;\t&quot;$5} {total+=$5} END {print &quot;total KB: &quot; total}&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-acc-file-size.png" alt=""></p>
<h3 id="内置字符串函数"><a href="#内置字符串函数" class="headerlink" title="内置字符串函数"></a>内置字符串函数</h3><p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-string-function.png" alt=""></p>
<p>gsub类似于sed查找和替换。它允许替换一个字符串或字符为另一个字符串或字符，并以正则表达式的形式执行，第一个函数作用于记录$0，第二个gsub函数允许指定目标，如果未指定，默认是$0。<br>index(s, t)函数返回目标字符串s中查询字符串t的首位置。<br>length函数返回字符串s字符长度。<br>match函数测试字符串s是否包含一个正则表达式r定义的匹配。<br>split函数使用域分隔符fs，将字符串s划分为指定序列a。<br>sprint函数类似于printf函数，返回基本输出格式fmt的结果字符串exp。<br>sub(r, s)函数将用s代替$0中最左边最长的子串，该子串被（r）匹配。<br>sub(s, p)返回字符串s在位置p后的后缀部分。<br>substr(s, p, n)函数返回字符串s在位置p后长度为n的后缀部分。</p>
<p><strong>实例：1. gsub</strong></p>
<p>描述：匹配记录中访问时间为11:35的记录，修改为11:40。注意要用双引号括起来。<br>命令：<code>awk &#39;gsub(/11:35/, &quot;11:40&quot;) {print $0}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-gsub.png" alt=""></p>
<p><strong>实例：2. index</strong><br>描述：匹配字符串Honey中，ney子串第一次出现的位置，即字符个数。<br>命令：<code>awk &#39;BEGIN {print index(&quot;Honey&quot;, &quot;ney&quot;)}&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-index.png" alt=""></p>
<p><strong>实例：3. length</strong></p>
<p>描述：匹配序号为6，第二个域的字符长度。也可以直接使用字符串。<br>命令：<code>awk &#39;$1==6 {print length($2) &quot;---&quot; $2}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-length.png" alt=""></p>
<p><strong>实例：4. match</strong></p>
<p>描述：match测试目标字符串是否包含查找字符的一部分，可以使用正则表达式。<br>命令：<br>在AWK中查找d，因其不存在，所以返回0。<br><code>awk &#39;BEGIN {print match(&quot;AWK&quot;, /d/)}&#39;</code><br>在AWK中查找K，因其存在，所有返回AWK中K出现的首位置字符数。<br><code>awk &#39;BEGIN {print match(&quot;AWK&quot;, /K/)}&#39;</code><br>在序号为6的记录中，查找Android的大版本号。<br><code>awk &#39;$1==6 {print match($2, &quot;7&quot;)}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-match.png" alt=""></p>
<p><strong>实例：5. split</strong></p>
<p>描述：如果域中具有分隔符形式的字符串，使用split函数将其分隔，并保存到一个数组中，最后将数组的第一个元素打印出来。<br>命令：<code>awk &#39;BEGIN {print split(&quot;123#456#789&quot;, myarray, &quot;#&quot;)}&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-split.png" alt=""></p>
<p><strong>实例：6. sub</strong></p>
<p>描述：匹配所有Android，替换为android。注意只在模式第一次出现时进行替换操作。<br>命令：<code>awk &#39;sub(/Android/, &quot;android&quot;)&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-sub.png" alt=""></p>
<p><strong>实例：7. substr</strong></p>
<p>描述：匹配第二个域版本信息中，打印从第一个字符开始到第七个字符。如果给定的长度值远大于字符串长度，awk将从起始位置返回所有字符。另一种形式是返回字符串后缀或指定位置后面的字符。<br>命令：<code>awk &#39;$1==5 {print substr($2,1,7)}&#39; device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-substr.png" alt=""></p>
<p><strong>实例：8. 从shell向awk传入字符串</strong><br>命令：<br>使用管道将字符串powerful传入awk，返回其长度。<br><code>echo &quot;powerful&quot; | awk &#39;{print length($0)}&#39;</code><br>设置文件名为一变量，管道输出到awk，但会不带扩展名的文件名。<br><code>STR=&quot;myawk.txt&quot; | echo $STR | awk &#39;{print substr($STR,1,5)}&#39;</code><br>设置文件名为一变量，管道输出到awk，只返回其扩展名。<br><code>TR=&quot;myawk.txt&quot; | echo $STR | awk &#39;{print substr($STR,7)}&#39;</code></p>
<p>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-shell.png" alt=""></p>
<h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-escape.png" alt=""></p>
<h3 id="printf修饰符"><a href="#printf修饰符" class="headerlink" title="printf修饰符"></a>printf修饰符</h3><p>基本语法：<code>printf([格式控制符], 参数)</code><br>格式控制符通常在引号里。</p>
<p>awkprintf修饰符：<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-printf-table.png" alt=""></p>
<p>awk printf格式：<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-printf-format-table.png" alt=""></p>
<p><strong>实例：1. 字符转换</strong><br>描述：通过管道输出65到awk中，printf进行ASCII码字符转换。<br>命令：<br><code>echo &quot;65&quot; | awk &#39;{printf (&quot;%c\n&quot;, $0)}&#39;</code><br>或者<br><code>awk &#39;BEGIN {printf &quot;%c\n&quot;, 65}&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-char-convert.png" alt=""></p>
<p>描述：数字1024转换为浮点数之后，被加入了六个小数点。<br>命令：<br><code>awk &#39;BEGIN {printf &quot;%f\n&quot;, 1024}&#39;</code> </p>
<p>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-number-convert.png" alt=""></p>
<p><strong>实例：2. 格式化输出</strong></p>
<p>描述：BEGIN后的第一个花括号嵌入头信息，第二个花括号打印所有用户的IP地址和访问时间，要求IP地址左对齐，23个字符长度，后跟访问时间。<br>命令：<br><code>awk &#39;BEGIN {print &quot;IP\t\t\tTime&quot;} {printf &quot;%-23s %s\n&quot;, $4, $3}&#39; device</code> </p>
<p>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-printf-format.png" alt=""></p>
<p><strong>实例：3. 向一行awk命令传值</strong></p>
<p>描述：在命令行中设置VISITS等于10，然后传入awk中，查询访问次数大于10的所有记录。<br>命令：<code>awk &#39;{if($5 &gt; VISITS) print $0} &#39; VISITS=10 device</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-command-line-pass-to-awk.png" alt=""></p>
<p>描述：用管道将df -k传入awk，然后抽出第四列，即剩余可利用空间容量。使用$4 ~ /^[0-9]/取得容量数值，最后对命令行if($4 &lt; TRIGGER)上变量TRIGGER的值进行查询。<br>查看文件系统空间容量，观察其是否达到一定水平。因为要监视的已使用空间容量不断在变化，所以需要再命令行指定一个触发值。<br>命令：<code>df -k | awk &#39;($4 ~ /^[0-9]/) {if ($4 &lt; TRIGGER) printf &quot;%-15s %s\n&quot;,$6,$4}&#39; TRIGGER=930000</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-df.png" alt=""></p>
<p>描述：打印当前注册用户，并加入一定信息。<br>命令：<code>who | awk &#39;{print $1 &quot; is logged on&quot;}&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-who.png" alt=""></p>
<p>描述：传入环境变量LOGNAME，显示当前用户名。<br>命令：<code>who | awk &#39;{if ($1 == user) print $1&quot; you are connected to &quot; $2}&#39; user=$LOGNAME&quot;}&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-env-variable.png" alt=""></p>
<p><strong>实例：4. awk脚本文件</strong></p>
<p>描述：第一行#! /usr/bin/awk -f告知脚本系统awk命令的位置。在脚本文件后键入文件名之前，需要先对脚本文件加入可执行权限。<br>命令：<code>chmod u+x user_tot.awk</code><br>user_tot.awk脚本文件：<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-script-user-tot.png" alt=""></p>
<p>描述：执行user_tot.awk脚本文件。<br>命令：<code>./user_tot.awk device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-script-run-user-tot.png" alt=""></p>
<p><strong>实例：5. 在awk中使用FS变量</strong></p>
<p>描述：从/etc/passwd文件中抽取第1和第5域，通过FS变量，指定冒号:分隔passwd文件域。第1域时账号名，第5域是账号所有者。<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-script-passwd-file.png" alt=""><br>命令：<code>chmod u+x passwd.awk | ./passwd.awk /etc/passwd</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-script-run-passwd.png" alt=""></p>
<p><strong>实例：6. 向awk脚本传值</strong></p>
<p>向awk脚本传值与向awk一行命令传值的方式大体相同，格式为：<br><code>awk script_file var=value input_file</code></p>
<p>描述：对比检查文件中域号和指定数字。注意不要忘了增加脚本的可执行权限。<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-script-fieldcheck-file.png" alt=""><br>命令：<code>chmod u+x fieldcheck.awk | ./fieldcheck.awk MAX=7 FS=&quot;:&quot; /etc/passwd</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-script-run-fieldcheck.png" alt=""></p>
<p>描述：从du命令获得输入，并输出块和字节数。<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-script-duawk-file.png" alt=""><br>命令：<code>chmod u+x duawk.awk | du /root | ./duawk.awk</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-script-run-duawk.png" alt=""></p>
<p><strong>实例：9. awk数组</strong></p>
<p>描述：用split将123#456#789划分开，并存入myarray数组，再使用循环打印各数组元素。<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-script-array-file.png" alt=""><br>命令：<code>chmod u+x duawk.awk | du /root | ./duawk.awk</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-script-run-array.png" alt=""></p>
<p><strong>实例：10. 处理由通配符指定的多个文件名</strong></p>
<p>描述：打印当前目录中以.txt结尾的文件。nextfile告诉awk停止处理当前的输入文件。下一个输入记录读取来自下一个输入文件。<br>命令：<br><code>awk &#39;{ print FILENAME; nextfile } &#39; *.txt</code><br><code>awk &#39;BEGIN{ print &quot;Starting...&quot;} { print FILENAME; nextfile }END{ print &quot;....DONE&quot;} &#39; *.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/awk/awk-multiple-filename.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/21/linux/daily-command-stat/</loc>
    <lastmod>2018-06-22T01:07:12.200Z</lastmod>
    <data>
        <display>
        <title>Linux stat总结</title>
        <pubTime>2018-06-20T17:14:22.000Z</pubTime>
      
         <content><p>stat命令用来显示文件或文件系统的状态。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>stat命令用来显示文件或文件系统的状态。stat命令从文件的索引节点获取信息，它们包括文件类型的信息，八进制访问权限和人类可读形式的权限，SELinux安全上下文字符串，文件创建时间，上次访问时间，上次数据修改时间，上次状态改变时间以及Epoch以来的秒数等等。因此，stat命令的输出信息比ls命令的输出信息要更详细。见touch命令。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/stat/stat-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>stat [OPTION]… FILE…</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-c或–format：使用特定或自定义格式而不是默认格式，在每一行结束之后打印一个新行。</li>
<li>-L：支持符号连接。</li>
<li>-f：显示文件系统状态而非文件状态。</li>
<li>–printf：类似于format，但它能够解释反斜线转义，并关闭后续换行符的打印，可以手动添加\n打印新行。</li>
<li>-t：以简洁方式输出信息。</li>
<li>–help：显示指令的帮助信息。</li>
<li>–version：显示指令的版本信息。</li>
</ul>
<h2 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h2><h3 id="stat显示更多信息"><a href="#stat显示更多信息" class="headerlink" title="stat显示更多信息"></a><strong>stat显示更多信息</strong></h3><p>描述：使用ls命令的长列表模式和使用stat命令查看文件信息。<br>命令：<br><code>ls -l names.txt</code><br><code>stat names.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/stat/stat-ls.png" alt=""><br>说明：图中，文件状态改变和文件修改的日期/时间是相同的，而访问时间是更近的时间。文件使用了8个块，以两个格式显示文件权限，八进制（0664）和-rw-rw-r–格式。在第三行显示索引为393342，文件没有其他硬链接（Links:1）。这个文件是一个常规文件。</p>
<h3 id="显示文件系统的状态"><a href="#显示文件系统的状态" class="headerlink" title="显示文件系统的状态"></a><strong>显示文件系统的状态</strong></h3><p>描述：f选项将显示指定文件系统的信息。需要提供一个目录/文件系统作为参数。<br>命令：<br><code>stat -f /dev/vda1</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/stat/stat-file-system.png" alt=""></p>
<h3 id="重命名改变状态时间"><a href="#重命名改变状态时间" class="headerlink" title="重命名改变状态时间"></a><strong>重命名改变状态时间</strong></h3><p>描述：重命名文件将会改变状态时间，即ctime。文件创建的时候ctime存储文件的创建日期和时间，修改文件后就变为记录文件的状态改动时间。<br>命令：<br><code>mv fairy fairy2</code><br><code>stat fairy2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/stat/stat-mv.png" alt=""></p>
<h3 id="查看多个文件"><a href="#查看多个文件" class="headerlink" title="查看多个文件"></a><strong>查看多个文件</strong></h3><p>描述：使用通配符查看多个文件的状态。<br>命令：<code>stat t*</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/stat/stat-wild.png" alt=""></p>
<h3 id="用ls获取额外的信息"><a href="#用ls获取额外的信息" class="headerlink" title="用ls获取额外的信息"></a><strong>用ls获取额外的信息</strong></h3><p>描述：ls的u选项显示最后访问时间，c选项显示状态改动时间。<br>命令：<br><code>ls -lu fairy2</code><br><code>ls -lc fairy2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/stat/stat-ls-u-c.png" alt=""></p>
<h3 id="用ls获取额外的信息-1"><a href="#用ls获取额外的信息-1" class="headerlink" title="用ls获取额外的信息"></a><strong>用ls获取额外的信息</strong></h3><p>描述：ls的u选项显示最后访问时间，c选项显示状态改动时间。<br>命令：<br><code>ls -lu fairy2</code><br><code>ls -lc fairy2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/stat/stat-ls-u-c.png" alt=""></p>
<h3 id="显示指定的信息"><a href="#显示指定的信息" class="headerlink" title="显示指定的信息"></a><strong>显示指定的信息</strong></h3><p>--format选项可以单独显示具体的信息。可用的选项如下：</p>
<p>表: 文件的格式序列</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%a</td>
<td style="text-align:left">八进制表示的访问权限</td>
</tr>
<tr>
<td style="text-align:left">%A</td>
<td style="text-align:left">可读格式表示的访问权限</td>
</tr>
<tr>
<td style="text-align:left">%b</td>
<td style="text-align:left">分配的块数（参见%B）</td>
</tr>
<tr>
<td style="text-align:left">%B</td>
<td style="text-align:left">%b参数显示的每个块的字节数</td>
</tr>
<tr>
<td style="text-align:left">%d</td>
<td style="text-align:left">十进制表示的设备号</td>
</tr>
<tr>
<td style="text-align:left">%D</td>
<td style="text-align:left">十六进制表示的设备号</td>
</tr>
<tr>
<td style="text-align:left">%f</td>
<td style="text-align:left">十六进制表示的Raw模式</td>
</tr>
<tr>
<td style="text-align:left">%F</td>
<td style="text-align:left">文件类型</td>
</tr>
<tr>
<td style="text-align:left">%g</td>
<td style="text-align:left">属主的组ID</td>
</tr>
<tr>
<td style="text-align:left">%G</td>
<td style="text-align:left">属主的组名</td>
</tr>
<tr>
<td style="text-align:left">%h</td>
<td style="text-align:left">硬连接数</td>
</tr>
<tr>
<td style="text-align:left">%i</td>
<td style="text-align:left">Inode号</td>
</tr>
<tr>
<td style="text-align:left">%n</td>
<td style="text-align:left">文件名</td>
</tr>
<tr>
<td style="text-align:left">%N</td>
<td style="text-align:left">如果是符号链接，显示器所链接的文件名</td>
</tr>
<tr>
<td style="text-align:left">%o</td>
<td style="text-align:left">I/O块大小</td>
</tr>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:left">全部占用的字节大小</td>
</tr>
<tr>
<td style="text-align:left">%t</td>
<td style="text-align:left">十六进制的主设备号</td>
</tr>
<tr>
<td style="text-align:left">%T</td>
<td style="text-align:left">十六进制的副设备号</td>
</tr>
<tr>
<td style="text-align:left">%u</td>
<td style="text-align:left">属主的用户ID</td>
</tr>
<tr>
<td style="text-align:left">%U</td>
<td style="text-align:left">属主的用户名</td>
</tr>
<tr>
<td style="text-align:left">%x</td>
<td style="text-align:left">最后访问时间</td>
</tr>
<tr>
<td style="text-align:left">%X</td>
<td style="text-align:left">最后访问时间，自Epoch开始的秒数</td>
</tr>
<tr>
<td style="text-align:left">%y</td>
<td style="text-align:left">最后修改时间</td>
</tr>
<tr>
<td style="text-align:left">%Y</td>
<td style="text-align:left">最后修改时间，自Epoch开始的秒数</td>
</tr>
<tr>
<td style="text-align:left">%z</td>
<td style="text-align:left">最后改变时间</td>
</tr>
<tr>
<td style="text-align:left">%Z</td>
<td style="text-align:left">最后改变时间，自Epoch开始的秒数</td>
</tr>
</tbody>
</table>
<p>表: 文件系统的格式序列</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%a</td>
<td style="text-align:left">普通用户可用的块数</td>
</tr>
<tr>
<td style="text-align:left">%b</td>
<td style="text-align:left">文件系统的全部数据块数</td>
</tr>
<tr>
<td style="text-align:left">%c</td>
<td style="text-align:left">文件系统的全部文件节点数</td>
</tr>
<tr>
<td style="text-align:left">%d</td>
<td style="text-align:left">文件系统的可用文件节点数</td>
</tr>
<tr>
<td style="text-align:left">%f</td>
<td style="text-align:left">文件系统的可用节点数</td>
</tr>
<tr>
<td style="text-align:left">%C</td>
<td style="text-align:left">SELinux的安全上下文</td>
</tr>
<tr>
<td style="text-align:left">%i</td>
<td style="text-align:left">十六进制表示的文件系统ID</td>
</tr>
<tr>
<td style="text-align:left">%l</td>
<td style="text-align:left">文件名的最大长度</td>
</tr>
<tr>
<td style="text-align:left">%n</td>
<td style="text-align:left">文件系统的文件名</td>
</tr>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:left">块大小（用于更快的传输）</td>
</tr>
<tr>
<td style="text-align:left">%S</td>
<td style="text-align:left">基本块大小（用于块计数）</td>
</tr>
<tr>
<td style="text-align:left">%t</td>
<td style="text-align:left">十六进制表示的文件系统类型</td>
</tr>
<tr>
<td style="text-align:left">%T</td>
<td style="text-align:left">可读格式表示的文件系统类型</td>
</tr>
</tbody>
</table>
<p>描述：–format选项可以一次显示所有指定的信息。例如只查看文件类型，和硬链接数。<br>命令：<br><code>stat --format=%F %h fairy2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/stat/stat-F-h.png" alt=""></p>
<p>描述：以两种格式查看权限，查看文件的最后访问时间，自Epoch开始的秒数，还查看了文件的属主。–format或-c选项可以打印特定或自定义格式，在每一行结束之后打印一个新行。<br>命令：<br><code>stat --format=%a fairy2</code><br><code>stat --format=%A fairy2</code><br><code>stat --format=%X fairy2</code><br><code>stat --format=%U fairy2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/stat/stat-format.png" alt=""></p>
<p>描述：以两种格式查看权限，查看文件的最后访问时间，自Epoch开始的秒数，还查看了文件的属主。–printf类似于format，但它能够解释反斜线转义，并关闭后续换行符的打印，可以手动添加\n打印新行。<br>命令：<br><code>stat --printf=&quot;%a\n&quot; fairy2</code><br><code>stat --printf=&quot;%A\n&quot; fairy2</code><br><code>stat --printf=&quot;%X\n&quot; fairy2</code><br><code>stat --printf=&quot;%U\n&quot; fairy2</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/stat/stat-printf.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/02/linux/daily-command-tar/</loc>
    <lastmod>2018-06-20T12:35:44.922Z</lastmod>
    <data>
        <display>
        <title>Linux tar总结</title>
        <pubTime>2018-06-02T08:26:43.000Z</pubTime>
      
         <content><p>tar命令用来归档多个文件或目录到单个归档文件中，并且归档文件可以进一步使用gzip或者bzip2等技术进行压缩。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>tar [OPTION...] [FILE]...</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>Tar（Tape ARchive，磁带归档的缩写，最初设计用于将文件打包到磁带上，现在大都使用它来实现备份某个分区或者某些重要的目录）是类Unix系统中使用最广泛的命令，用于归档多个文件或目录到单个归档文件中，并且归档文件可以进一步使用gzip或者bzip2等技术进行压缩，还能保留其文件权限。换言之，tar命令也可以用于备份：先是归档多个文件和目录到一个单独的tar文件或归档文件，然后在需要之时将tar文件中的文件和目录释放出来。</p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><p>表:tar命令选项</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-A或–catenate</td>
<td style="text-align:left">新增文件到以存在的备份文件</td>
</tr>
<tr>
<td style="text-align:left">-B</td>
<td style="text-align:left">设置区块大小</td>
</tr>
<tr>
<td style="text-align:left">-c或–create</td>
<td style="text-align:left">建立新的备份文件</td>
</tr>
<tr>
<td style="text-align:left">-C&lt;目录&gt;</td>
<td style="text-align:left">这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项</td>
</tr>
<tr>
<td style="text-align:left">-d</td>
<td style="text-align:left">记录文件的差别</td>
</tr>
<tr>
<td style="text-align:left">-x或–extract或–get</td>
<td style="text-align:left">从备份文件中还原文件</td>
</tr>
<tr>
<td style="text-align:left">-t或–list</td>
<td style="text-align:left">列出备份文件的内容</td>
</tr>
<tr>
<td style="text-align:left">-z或–gzip或–ungzip</td>
<td style="text-align:left">通过gzip指令处理备份文件</td>
</tr>
<tr>
<td style="text-align:left">-Z或–compress或–uncompress</td>
<td style="text-align:left">通过compress指令处理备份文件</td>
</tr>
<tr>
<td style="text-align:left">-f&lt;备份文件&gt;或–file=&lt;备份文件&gt;</td>
<td style="text-align:left">指定备份文件</td>
</tr>
<tr>
<td style="text-align:left">-v或–verbose</td>
<td style="text-align:left">显示指令执行过程</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">添加文件到已经压缩的文件</td>
</tr>
<tr>
<td style="text-align:left">-u</td>
<td style="text-align:left">添加改变了和现有的文件到已经存在的压缩文件</td>
</tr>
<tr>
<td style="text-align:left">-j</td>
<td style="text-align:left">支持bzip2解压文件</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">显示操作过程</td>
</tr>
<tr>
<td style="text-align:left">-l</td>
<td style="text-align:left">文件系统边界设置</td>
</tr>
<tr>
<td style="text-align:left">-k</td>
<td style="text-align:left">保留原有文件不覆盖</td>
</tr>
<tr>
<td style="text-align:left">-m</td>
<td style="text-align:left">保留文件不被覆盖</td>
</tr>
<tr>
<td style="text-align:left">-w</td>
<td style="text-align:left">确认压缩文件的正确性</td>
</tr>
<tr>
<td style="text-align:left">-p或–same-permissions</td>
<td style="text-align:left">用原来的文件权限还原文件</td>
</tr>
<tr>
<td style="text-align:left">-P或–absolute-names</td>
<td style="text-align:left">文件名使用绝对名称，不移除文件名称前的“/”号</td>
</tr>
<tr>
<td style="text-align:left">-N</td>
<td style="text-align:left">&lt;日期格式&gt;或–newer=&lt;日期时间&gt;只将较指定日期更新的文件保存到备份文件里</td>
</tr>
<tr>
<td style="text-align:left">–exclude=&lt;范本样式&gt;</td>
<td style="text-align:left">排除符合范本样式的文件</td>
</tr>
</tbody>
</table>
<h2 id="什么是“文件压缩”？"><a href="#什么是“文件压缩”？" class="headerlink" title="什么是“文件压缩”？"></a>什么是“文件压缩”？</h2><p>我们知道，在计算机系统中文件的内容是信息，信息实际上就是一个由值0和值1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。一般来说，一个字节的8位是没有被全部利用起来的，这些没有被利用的位占据了一个文件的大部分空间，而“文件压缩”就是利用复杂的计算方式，将这些没有利用的空间腾出来，以让文件占用的空间变小。</p>
<p>简单来说，「压缩」就是把文件中没有完全填满的空间填满。压缩过的文件不能直接被操作系统所使用，因此，「解压缩」就是指把文件「还原」为未压缩之前的模样。压缩前与压缩后的文件所占用的磁盘空间大小之比就是「压缩比」。</p>
<!-- more -->
<h2 id="常见的压缩格式"><a href="#常见的压缩格式" class="headerlink" title="常见的压缩格式"></a>常见的压缩格式</h2><p>Linux 中常见的压缩格式有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*.Z：compress 程序压缩的文件。</span><br><span class="line">*.gz：gzip 程序压缩的文件。</span><br><span class="line">*.bz2：bzip2 程序压缩的文件。</span><br><span class="line">*.tar：tar 程序打包的数据，没有被压缩过。</span><br><span class="line">*.tar.gz（简写为 .tgz）：tar 程序打包的数据，经过 gzip 的压缩。</span><br><span class="line">*.tar.bz2（简写为 .tbz2）：tar 程序打包的数据，经过 bzip2 的压缩。</span><br></pre></td></tr></table></figure>
<p>上面的压缩格式中，主要是gzip和bzip2两个压缩命令，它们是GNU计划的中的一部分，在此之前是compress命令，但它已经不再流行了。bzip2比gzip的压缩比很好，不过bzip2通常只能针对一个文件来压缩和解压缩。如果是这样的话，压缩整个开发环境目录就太繁琐了。</p>
<p>因此tar命令就出现了，tar不是一个 “压缩命令”，而是一个“打包命令”。也就是说，tar可以把很多文件「打包」成一个文件，甚至连目录也可以进行打包。一开始tar命令的确是不支持压缩的功能，后来GNU计划为了提供给使用者更方便并且更加强大的压缩与打包功能，就把整个tar与压缩的功能结合在一起了。</p>
<p>仅仅打包起来的tar文件俗称tarfile文件，经过压缩的tar文件叫做tarball文件。</p>
<h2 id="全能的-tar-命令"><a href="#全能的-tar-命令" class="headerlink" title="全能的 tar 命令"></a>全能的 tar 命令</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>tar可以将多个目录或文件打成一个大文件，同时支持gzip/bzip2</p>
<p>归档：tar {-c} [option…] -f destination source<br>追加归档：tar {-r | -u} -f source [option…] destination<br>解压：tar {-t | -x} -f source [option…] -C destination</p>
<p>最简单的使用 tar 只要记住下面的方式：</p>
<ul>
<li>压缩：tar -jcv -f filename.tar.bz2 被压缩的文件或目录名称</li>
<li>查看文件：tar -jtv -f filename.tar.bz2 </li>
<li>解压缩：tar -jxv -f filename.tar.gz -C 解压到哪里</li>
</ul>
<p>filename.tar.bz2 既然tar不是一个压缩命令，是个打包命令，那么是如何做到打包并压缩的呢？我们先来看一下tar命令的常用参数：</p>
<h3 id="模式参数"><a href="#模式参数" class="headerlink" title="模式参数"></a>模式参数</h3><ul>
<li>-c（–create）：创建新的归档文件。</li>
<li>-r（–append）：与-c一样创建新的归档文件，但这是以追加的模式，只能往未压缩过的归档文件中追加，要求指定-f参数。</li>
<li>-t：查看归档文件的内容含有哪些文件，可以看到包括文件名在内的详细信息。</li>
<li>-u：与-r一样，但是只往归档文件添加更新的文件。</li>
<li>-x：解压缩归档文件。如果一个归档文件里有相同文件名的多个文件，那么会先将每个文件解压，最新的文件将覆盖旧的文件。</li>
</ul>
<p>tar分为三种模式，-c，-r，-u三个一类，为归档/压缩模式，在该模式下，tar会递归遍历指定目录下的所有目录和文件，并创建归档文件。-x表示为去归档/解压模式，-t表示为打印列表模式。</p>
<h3 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h3><ul>
<li>-j：使用bzip2的支持进行压缩和解压缩，文件名最好为*.tar.bz2。</li>
<li>-z：使用gzip的支持进行压缩和解压缩，文件名最好为*.tar.gz。</li>
<li>-v：在压缩/解压缩的过程中，将正在处理的文件名显示出来。</li>
<li>-f：后面接被处理的文件名，最好把-f单独出来写一个参数。</li>
<li>-C：指定解压的目录。</li>
<li>-p：保留文件的原始信息，权限等等</li>
<li>-P：解压时保留绝对路径。</li>
<li>–exclude=FILE：在打包压缩的时候，不要将FILE打包。</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>本文讲解的案例在CentOS Linux release 7.4.1708下进行。</p>
<h3 id="打包并创建归档文件"><a href="#打包并创建归档文件" class="headerlink" title="打包并创建归档文件"></a><strong>打包并创建归档文件</strong></h3><p>示例：打包一个目录。<br>描述：将/home/nijun这个目录打包，生成文件名为command-18-06-02.tar的归档文件，保存在当前目录下。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -cv -f command-18-06-02.tar /home/nijun</span><br><span class="line">/home/nijun/.bash_logout</span><br><span class="line">/home/nijun/.bashrc</span><br><span class="line">/home/nijun/apache-tomcat-9.0.7.tar.gz</span><br><span class="line">/home/nijun/.bash_profile</span><br><span class="line">/home/nijun/nginx-1.10.1.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>-c（–create的简写）参数，这表示为指定的文件或者目录创建新的归档文件。使用-f指定读取或者写入的归档文件，可以用-表示标准输入或者标准输出，-f可以与其他参数连起来写，必须保证f参数后面跟的是文件名。但不推荐这样写，因为参数调换顺序是允许的，如果写成-cfv就会导致压缩后的文件名变成了v。</p>
<p>使用-v表示生成详细的输出，在压缩或者解压的模式中，会列出正在向归档文件读或者写的文件名字。</p>
<h3 id="创建tar-gz归档文件"><a href="#创建tar-gz归档文件" class="headerlink" title="创建tar.gz归档文件"></a><strong>创建tar.gz归档文件</strong></h3><p>示例：打包并且使用gzip压缩。<br>描述：将/home/nijun/images目录下的所有文件以及目录中的文件打包，并用gzip进行压缩，生成名为MyImages-18-06-02.tar.gz的归档文件，放在当前目录下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -zcv -f MyImages-18-06-02.tar.gz /home/nijun/images</span><br><span class="line">OR</span><br><span class="line"><span class="meta">#</span> tar -zcv -f MyImages-18-06-02.tar.tgz /home/nijun/images</span><br><span class="line">/home/nijun/images/alejandro-gonzalez-17189.jpg</span><br><span class="line">/home/nijun/images/brooke-lark-275181.jpg</span><br><span class="line">/home/nijun/images/brenda-godinez-228181.jpg</span><br><span class="line">/home/nijun/images/artur-rutkowski-97622.jpg</span><br><span class="line">/home/nijun/images/ben-white-138743.jpg</span><br></pre></td></tr></table></figure>
<p>-z表示要使用gzip支持来压缩或者解压文件，注意gzip的压缩的文件格式最好写成tar.gz。（注：tar.gz 和 tgz 是同一个意思）</p>
<h3 id="打包压缩排除某些文件"><a href="#打包压缩排除某些文件" class="headerlink" title="打包压缩排除某些文件"></a><strong>打包压缩排除某些文件</strong></h3><p>示例：打包压缩并排除某些文件。<br>描述：将/home/nijun/images目录下，排除brooke-lark-275181.jpg和ben-white-138743.jpg之外的所有文件打包，并用gzip进行压缩，生成名为MyImages-18-06-02.tar.gz的归档文件，放在当前目录下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -czv -f MyImages-18-06-02.tar.gz --exclude=./brooke-lark-275181.jpg --exclude=./ben-white-138743.jpg /home/nijun/images</span><br><span class="line">/home/nijun/images/alejandro-gonzalez-17189.jpg</span><br><span class="line">/home/nijun/images/brenda-godinez-228181.jpg</span><br><span class="line">/home/nijun/images/artur-rutkowski-97622.jpg</span><br></pre></td></tr></table></figure>
<h3 id="解压归档文件（默认）"><a href="#解压归档文件（默认）" class="headerlink" title="解压归档文件（默认）"></a><strong>解压归档文件（默认）</strong></h3><p>示例：解压，默认解压。<br>描述：将名为MyImages-18-06-02.tar的归档文件解压至当前目录下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -xvf MyImages-18-06-02.tar</span><br><span class="line">home/nijun/images/alejandro-gonzalez-17189.jpg</span><br><span class="line">home/nijun/images/brenda-godinez-228181.jpg</span><br><span class="line">home/nijun/images/artur-rutkowski-97622.jpg</span><br></pre></td></tr></table></figure>
<p>其中，-x参数表示去解压一个归档文件，如果归档文件中有两个相同名字的文件，那么每一个文件都会被解压出来，然后最新的会覆盖旧的文件。注意这里没有指定-j参数，因为tar看到指定了-x参数，就知道这是解压操作，会自动判断该解压包的压缩类型。</p>
<h3 id="解压归档文件并指定目录"><a href="#解压归档文件并指定目录" class="headerlink" title="解压归档文件并指定目录"></a><strong>解压归档文件并指定目录</strong></h3><p>示例：解压到一个指定目录。<br>描述：将名为MyImages-18-06-02.tar.gz的归档文件解压至一个指定的目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -xv -f MyImages-18-06-02.tar -C /home/nijun/public_images</span><br><span class="line">home/nijun/public_images/alejandro-gonzalez-17189.jpg</span><br><span class="line">home/nijun/public_images/brenda-godinez-228181.jpg</span><br><span class="line">home/nijun/public_images/artur-rutkowski-97622.jpg</span><br></pre></td></tr></table></figure>
<h3 id="查看压缩包文件信息"><a href="#查看压缩包文件信息" class="headerlink" title="查看压缩包文件信息"></a><strong>查看压缩包文件信息</strong></h3><p>示例：查看压缩包文件信息。<br>描述：列出MyImages-18-06-02.tar.bz2中的文件信息，-v参数，会生成与ls(1)命令相近的输出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -tv -f MyImages-18-06-02.tar.gz</span><br><span class="line">OR</span><br><span class="line"><span class="meta">#</span> tar -tv -f MyImages-18-06-02.tar.bz2</span><br><span class="line">-rw-r--r-- root/root   2176861 2018-06-02 21:26 home/nijun/images/alejandro-gonzalez-17189.jpg</span><br><span class="line">-rw-r--r-- root/root   8452524 2018-06-02 21:26 home/nijun/images/brenda-godinez-228181.jpg</span><br><span class="line">-rw-r--r-- root/root   1131986 2018-06-02 21:26 home/nijun/images/artur-rutkowski-97622.jpg</span><br></pre></td></tr></table></figure>
<h3 id="解压单个文件"><a href="#解压单个文件" class="headerlink" title="解压单个文件"></a><strong>解压单个文件</strong></h3><p>示例：解压单个文件。<br>描述：将home/nijun/.bashrc这一个文件从归档文件中提取出来。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -xv -f command-18-06-02.tar home/nijun/.bashrc</span><br><span class="line">home/nijun/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="解压多个指定的文件"><a href="#解压多个指定的文件" class="headerlink" title="解压多个指定的文件"></a><strong>解压多个指定的文件</strong></h3><p>示例：解压多个指定的文件。<br>描述：将file1、file2等多个文件从归档文件中提取出来，可以用空格隔开多个文件，也可以用通配符的形式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar -zxv -f MyImages-18-06-02.tar.gz "file 1" "file 2"</span><br><span class="line">OR</span><br><span class="line"><span class="meta">#</span> tar -zxv -f MyImages-18-06-02.tar.gz --wildcards '*b*.jpg'</span><br><span class="line">home/nijun/images/brooke-lark-275181.jpg</span><br><span class="line">home/nijun/images/brenda-godinez-228181.jpg</span><br><span class="line">home/nijun/images/ben-white-138743.jpg</span><br><span class="line">home/nijun/images/aleks-dahlberg-274646.jpg</span><br></pre></td></tr></table></figure>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/20/linux/daily-command-wc/</loc>
    <lastmod>2018-06-19T17:39:21.204Z</lastmod>
    <data>
        <display>
        <title>Liunx wc总结</title>
        <pubTime>2018-06-19T16:43:34.000Z</pubTime>
      
         <content><p>wc命令可以计算文件的新行、字符数、字节数。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>wc命令可以计算文件的新行、字符数、字节数。如果指定多于一个文件，也列出总的行数。单词是由空格分隔的非零长度的字符序列。如果没有指定文件，或当文件为-，则读取标准输入。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/wc/wc-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>wc [OPTION]… [FILE]…<br>wc [OPTION]… –files0-from=F</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-c或–bytes或——chars：只显示Bytes数；</li>
<li>-l或——lines：只显示列数；</li>
<li>-w或——words：只显示字数。</li>
<li>-m或——chars：只显示字符数。</li>
<li>-L或–max-line-length：打印最长行的长度。</li>
<li>–files0-from=F：从文件读取文件名，文件名应该是NUL-terminated空字符结尾。如果是-则从标准输入中读取。</li>
</ul>
<h2 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h2><h3 id="打印字节数"><a href="#打印字节数" class="headerlink" title="打印字节数"></a><strong>打印字节数</strong></h3><p>描述：打印letter文件的行数，字符数，字节数和文件名。默认没有参数。<br>命令：<code>wc letter</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/wc/wc.png" alt=""></p>
<h3 id="打印字节数-1"><a href="#打印字节数-1" class="headerlink" title="打印字节数"></a><strong>打印字节数</strong></h3><p>描述：打印file.txt文件的字节数，包含29个字节。-c选项打印字节数。<br>命令：<code>wc -c file.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/wc/wc-c.png" alt=""></p>
<h3 id="打印字符数"><a href="#打印字符数" class="headerlink" title="打印字符数"></a><strong>打印字符数</strong></h3><p>描述：打印file.txt文件的字符数，包含29个字符。-m选项打印字符数。<br>命令：<code>wc -m file.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/wc/wc-m.png" alt=""></p>
<h3 id="打印换行数"><a href="#打印换行数" class="headerlink" title="打印换行数"></a><strong>打印换行数</strong></h3><p>描述：打印file.txt文件中的新行数，包含4行。-l选项打印新行数。<br>命令：<code>wc -l file.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/wc/wc-l.png" alt=""></p>
<h3 id="打印单词数"><a href="#打印单词数" class="headerlink" title="打印单词数"></a><strong>打印单词数</strong></h3><p>描述：打印file.txt文件中的单词数，包含6个单子。-w选项打印单词数。<br>命令：<code>wc -w file.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/wc/wc-w.png" alt=""></p>
<h3 id="打印最长行长度"><a href="#打印最长行长度" class="headerlink" title="打印最长行长度"></a><strong>打印最长行长度</strong></h3><p>描述：打印file.txt文件中的最长行的长度，最长行长度为11。-L选项打印输入文件中最长行的长度。<br>命令：<code>wc -L file.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/wc/wc-width-L.png" alt=""></p>
<h3 id="统计目录中文件或目录的数量"><a href="#统计目录中文件或目录的数量" class="headerlink" title="统计目录中文件或目录的数量"></a><strong>统计目录中文件或目录的数量</strong></h3><p>描述：统计目录中文件夹和文件的数量。ls -1将每个文件夹或文件放在新行上，然后通过wc -l来计算换行数。<br>命令：<code>ls -1 | wc -l</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/wc/wc-pipe.png" alt=""></p>
<h3 id="更多命令信息"><a href="#更多命令信息" class="headerlink" title="更多命令信息"></a><strong>更多命令信息</strong></h3><p><img src="http://pabfn7ecx.bkt.clouddn.com/wc/wc-more-detail.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/19/linux/daily-command-date/</loc>
    <lastmod>2018-06-19T16:41:23.668Z</lastmod>
    <data>
        <display>
        <title>Linux date总结</title>
        <pubTime>2018-06-19T08:10:19.000Z</pubTime>
      
         <content><p>date命令用来显示或设置系统时间与日期。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>date命令用来显示或设置系统时间与日期。date命令可以打印不同格式的时间或日期，被用来根据时间和日期执行操作。<br>在类UNIX系统中，日期被存储为一个整数，其大小为自世界标准时间（UTC）1970年1月1日0时0分0秒起流逝的秒数。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>date [OPTION]... [+FORMAT]</code><br><code>date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</code></p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><p>表1: 命令参数</p>
<table>
<thead>
<tr>
<th style="text-align:left">参 数</th>
<th style="text-align:left">描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-d</td>
<td style="text-align:left">显示字符串描述的时间</td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td style="text-align:left">显示DATEFILE文件中的每行时间</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">显示文件的最后修改时间</td>
</tr>
<tr>
<td style="text-align:left">-R</td>
<td style="text-align:left">以RFC-2822兼容日期格式显示时间</td>
</tr>
<tr>
<td style="text-align:left">-rfc-2822</td>
<td style="text-align:left">以RFC-2822兼容日期格式显示时间</td>
</tr>
<tr>
<td style="text-align:left">-s</td>
<td style="text-align:left">根据字符串来设置日期与时间</td>
</tr>
<tr>
<td style="text-align:left">-u</td>
<td style="text-align:left">显示或设定为Coordinated Universal Time时间格式（UTC）</td>
</tr>
<tr>
<td style="text-align:left">–help</td>
<td style="text-align:left">显示date命令的帮助信息</td>
</tr>
<tr>
<td style="text-align:left">–version</td>
<td style="text-align:left">显示date命令的版本信息</td>
</tr>
</tbody>
</table>
<p>表2: Format参数格式</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%%</td>
<td style="text-align:left">显示字符%</td>
</tr>
<tr>
<td style="text-align:left">%a</td>
<td style="text-align:left">星期几的缩写(Sun..Sat)</td>
</tr>
<tr>
<td style="text-align:left">%A</td>
<td style="text-align:left">星期几的完整名称（Sunday…Saturday）</td>
</tr>
<tr>
<td style="text-align:left">%b</td>
<td style="text-align:left">月份的缩写(Jan..Dec)</td>
</tr>
<tr>
<td style="text-align:left">%B</td>
<td style="text-align:left">月份的完整名称(January..December)</td>
</tr>
<tr>
<td style="text-align:left">%c</td>
<td style="text-align:left">日期与时间。只输入date指令也会显示同样的结果</td>
</tr>
<tr>
<td style="text-align:left">%C</td>
<td style="text-align:left">世纪(年份除100后去整) [00-99]</td>
</tr>
<tr>
<td style="text-align:left">%d</td>
<td style="text-align:left">日期(以01-31来表示)。</td>
</tr>
<tr>
<td style="text-align:left">%D</td>
<td style="text-align:left">日期(含年月日)。</td>
</tr>
<tr>
<td style="text-align:left">%e</td>
<td style="text-align:left">一个月的第几天 ( 1..31)</td>
</tr>
<tr>
<td style="text-align:left">%F</td>
<td style="text-align:left">日期，同%Y-%m-%d</td>
</tr>
<tr>
<td style="text-align:left">%g</td>
<td style="text-align:left">年份(yy)</td>
</tr>
<tr>
<td style="text-align:left">%G</td>
<td style="text-align:left">年份(yyyy)</td>
</tr>
<tr>
<td style="text-align:left">%h</td>
<td style="text-align:left">同%b</td>
</tr>
<tr>
<td style="text-align:left">%H</td>
<td style="text-align:left">小时(00..23)</td>
</tr>
<tr>
<td style="text-align:left">%I</td>
<td style="text-align:left">小时(01..12)</td>
</tr>
<tr>
<td style="text-align:left">%j</td>
<td style="text-align:left">一年的第几天(001..366)</td>
</tr>
<tr>
<td style="text-align:left">%k</td>
<td style="text-align:left">小时( 0..23)</td>
</tr>
<tr>
<td style="text-align:left">%l</td>
<td style="text-align:left">小时( 1..12)</td>
</tr>
<tr>
<td style="text-align:left">%m</td>
<td style="text-align:left">月份(01..12)</td>
</tr>
<tr>
<td style="text-align:left">%M</td>
<td style="text-align:left">分钟(00..59)</td>
</tr>
<tr>
<td style="text-align:left">%n</td>
<td style="text-align:left">换行</td>
</tr>
<tr>
<td style="text-align:left">%N</td>
<td style="text-align:left">纳秒(000000000..999999999)</td>
</tr>
<tr>
<td style="text-align:left">%p</td>
<td style="text-align:left">AM or PM</td>
</tr>
<tr>
<td style="text-align:left">%P</td>
<td style="text-align:left">am or pm</td>
</tr>
<tr>
<td style="text-align:left">%r</td>
<td style="text-align:left">12小时制时间(hh:mm:ss [AP]M)</td>
</tr>
<tr>
<td style="text-align:left">%R</td>
<td style="text-align:left">24小时制时间(hh:mm)</td>
</tr>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:left">从00:00:00 1970-01-01 UTC开始的秒数</td>
</tr>
<tr>
<td style="text-align:left">%S</td>
<td style="text-align:left">秒(00..60)</td>
</tr>
<tr>
<td style="text-align:left">%t</td>
<td style="text-align:left">制表符</td>
</tr>
<tr>
<td style="text-align:left">%T</td>
<td style="text-align:left">24小时制时间(hh:mm:ss)</td>
</tr>
<tr>
<td style="text-align:left">%u</td>
<td style="text-align:left">一周的第几天(1..7); 1 表示星期一</td>
</tr>
<tr>
<td style="text-align:left">%U</td>
<td style="text-align:left">一年的第几周，周日为每周的第一天(00..53)</td>
</tr>
<tr>
<td style="text-align:left">%V</td>
<td style="text-align:left">一年的第几周，周一为每周的第一天 (01..53)</td>
</tr>
<tr>
<td style="text-align:left">%w</td>
<td style="text-align:left">一周的第几天 (0..6); 0 代表周日</td>
</tr>
<tr>
<td style="text-align:left">%W</td>
<td style="text-align:left">一年的第几周，周一为每周的第一天(00..53)</td>
</tr>
<tr>
<td style="text-align:left">%x</td>
<td style="text-align:left">日期(mm/dd/yy)</td>
</tr>
<tr>
<td style="text-align:left">%X</td>
<td style="text-align:left">时间(%H:%M:%S)</td>
</tr>
<tr>
<td style="text-align:left">%y</td>
<td style="text-align:left">年份(00..99)</td>
</tr>
<tr>
<td style="text-align:left">%Y</td>
<td style="text-align:left">年份 (1970…)</td>
</tr>
<tr>
<td style="text-align:left">%z</td>
<td style="text-align:left">RFC-2822 风格数字格式时区(-0500)</td>
</tr>
<tr>
<td style="text-align:left">%:z</td>
<td style="text-align:left">以 +hh:mm 的数字格式表示时区 （如： -04:00）</td>
</tr>
<tr>
<td style="text-align:left">%::z</td>
<td style="text-align:left">以 +hh:mm:ss 的数字格式表示时区 （如： -04:00:00）</td>
</tr>
<tr>
<td style="text-align:left">%:::z</td>
<td style="text-align:left">以数字格式表示时区， 其中 : 的个数由你需要的精度来决定 （例如， -04， +05:30）</td>
</tr>
<tr>
<td style="text-align:left">%Z</td>
<td style="text-align:left">时区(e.g., EDT), 无法确定时区则为空</td>
</tr>
</tbody>
</table>
<h2 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h2><h3 id="显示UTC时间"><a href="#显示UTC时间" class="headerlink" title="显示UTC时间"></a><strong>显示UTC时间</strong></h3><p>描述：显示当前时间。<br>命令：<br><code>date</code><br><code>date -d now</code><br>描述：显示当前UTC时间，UTC意思是世界上最主要的时钟和时间的标准。<br>命令：<code>date -u</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-u-r.png" alt=""></p>
<h3 id="查找3周后的日期"><a href="#查找3周后的日期" class="headerlink" title="查找3周后的日期"></a><strong>查找3周后的日期</strong></h3><p>命令：<code>date -d &quot;3 weeks&quot;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-after-three-weeks.png" alt=""></p>
<h3 id="查找3周又4天后的日期"><a href="#查找3周又4天后的日期" class="headerlink" title="查找3周又4天后的日期"></a><strong>查找3周又4天后的日期</strong></h3><p>命令：<code>date -d &quot;3 weeks 4 days&quot;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-after-three-weeks-four-days.png" alt=""></p>
<h3 id="获取下个月的日期"><a href="#获取下个月的日期" class="headerlink" title="获取下个月的日期"></a><strong>获取下个月的日期</strong></h3><p>命令：<code>date -d &quot;next month&quot;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-after-one-month.png" alt=""></p>
<h3 id="获取上个星期天的日期"><a href="#获取上个星期天的日期" class="headerlink" title="获取上个星期天的日期"></a><strong>获取上个星期天的日期</strong></h3><p>命令：<code>date -d &quot;last sunday&quot;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-last-sunday.png" alt=""></p>
<h3 id="自定义日期格式"><a href="#自定义日期格式" class="headerlink" title="自定义日期格式"></a><strong>自定义日期格式</strong></h3><p>描述：要自定义日期格式，使用加号+。<br>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date +&quot;%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">date +&quot;%Y-%m-%d %H:%M:%S&quot; -d &quot;-1day&quot;</span><br><span class="line">date +&quot;%Y-%m-%d %H:%M:%S&quot; -d &quot;+2day&quot;</span><br><span class="line">date +&quot;%Y-%m-%d %H:%M:%S&quot; -d &quot;+3hour&quot;</span><br><span class="line">date +&quot;%Y-%m-%d %H:%M:%S&quot; -d &quot;+30minute&quot;</span><br><span class="line">date +&quot;%Y-%m-%d %H:%M:%S&quot; -d &quot;+300second&quot;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-d.png" alt=""><br>说明：date命令会翻译所有的百分号（%）开头的格式和输出在引号(“”)内所有的内容。</p>
<h3 id="以yyyy-mm-dd的格式显示日期"><a href="#以yyyy-mm-dd的格式显示日期" class="headerlink" title="以yyyy-mm-dd的格式显示日期"></a><strong>以yyyy-mm-dd的格式显示日期</strong></h3><p>描述：%F的格式是yyyy-mm-dd，即%Y-%m-%d。<br>命令：<code>date +%F</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-F.png" alt=""></p>
<h3 id="只显示时间"><a href="#只显示时间" class="headerlink" title="只显示时间"></a><strong>只显示时间</strong></h3><p>描述：%T格式是 时:分:秒 的格式，即%H:%M:%S。<br>命令：<code>date +%T</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-T.png" alt=""></p>
<h3 id="显示今天是一年中的第几天"><a href="#显示今天是一年中的第几天" class="headerlink" title="显示今天是一年中的第几天"></a><strong>显示今天是一年中的第几天</strong></h3><p>命令：<code>date +%j</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-j.png" alt=""></p>
<h3 id="显示文件最后修改的时间"><a href="#显示文件最后修改的时间" class="headerlink" title="显示文件最后修改的时间"></a><strong>显示文件最后修改的时间</strong></h3><p>命令：<code>date -r date.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-r.png" alt=""></p>
<h3 id="显示文件中的时间"><a href="#显示文件中的时间" class="headerlink" title="显示文件中的时间"></a><strong>显示文件中的时间</strong></h3><p>描述：-f选项可以显示每行一个日期的文件。<br>命令：<code>date -f date.txt</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-file.png" alt=""></p>
<h3 id="设置系统时间"><a href="#设置系统时间" class="headerlink" title="设置系统时间"></a><strong>设置系统时间</strong></h3><p>描述：使用-s或–set来设置系统日期和时间。注意，必须拥有root特权，否则会出错。<br>命令：<br><code>date -s &quot;2017-06-19 00:00:00&quot;</code><br><code>date --set=&quot;2017-06-19 00:00:00&quot;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-s.png" alt=""><br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-cannot-set.png" alt=""></p>
<h3 id="打包时以时间命名"><a href="#打包时以时间命名" class="headerlink" title="打包时以时间命名"></a><strong>打包时以时间命名</strong></h3><p>描述：压缩目录/etc到当前目录，文件名为etc-2018-06-19.tar.gz。通过在`之间`或$()中内嵌命令。<br>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># tar czvf etc-$(date +%F).tar.gz /etc</span><br><span class="line">或者</span><br><span class="line"># tar czvf etc-`date +%F`.tar.gz /etc</span><br></pre></td></tr></table></figure></p>
<h3 id="在脚本中使用date命令"><a href="#在脚本中使用date命令" class="headerlink" title="在脚本中使用date命令"></a><strong>在脚本中使用date命令</strong></h3><p>命令：<br><code>date +&quot;DATE: %A %b-%d-%Y TIME: %T WEEK NUMBER: %W&quot;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/date/date-script.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/19/linux/daily-command-cd/</loc>
    <lastmod>2018-06-19T08:44:11.263Z</lastmod>
    <data>
        <display>
        <title>Linux cd总结</title>
        <pubTime>2018-06-19T01:36:54.000Z</pubTime>
      
         <content><p>cd命令用来切换工作目录。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>cd [选项] 目录</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>cd命令（change directory）用来切换工作目录。其中目录可以表示为绝对路径或相对路径，若目录名称省略，则变换至使用者的home directory（登录时所在的目录）。使用者只能访问自己的目录或者其余指定目录。通常与pwd命令一同使用，pwd命令获取当前目录路径并打印出来。</p>
<p>表: 特殊目录</p>
<table>
<thead>
<tr>
<th style="text-align:left">特殊目录</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">代表此层目录</td>
</tr>
<tr>
<td style="text-align:left">..</td>
<td style="text-align:left">代表上一层目录</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">代表前一个工作目录</td>
</tr>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">代表“目前使用者身份”所在的主文件</td>
</tr>
<tr>
<td style="text-align:left">~account</td>
<td style="text-align:left">代表account这个使用者的主文件夹（account是个账号名称）</td>
</tr>
</tbody>
</table>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-p 如果要切换到的目标目录是一个符号连接，直接切换到符号连接指向的目标目录。</li>
<li>-L 如果要切换的目标目录是一个符号的连接，直接切换到字符连接名代表的目录，而非符号连接所指向的目标目录。</li>
<li>- 只有 - 一个选项时，当前工作目录将被切换到环境变量”OLDPWD”所表示的目录。</li>
</ul>
<h2 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h2><h3 id="切换到当前目录的上一级目录"><a href="#切换到当前目录的上一级目录" class="headerlink" title="切换到当前目录的上一级目录"></a><strong>切换到当前目录的上一级目录</strong></h3><p>命令：<code>cd ..</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-previous.png" alt=""></p>
<h3 id="切换到当前目录的上上两层目录"><a href="#切换到当前目录的上上两层目录" class="headerlink" title="切换到当前目录的上上两层目录"></a><strong>切换到当前目录的上上两层目录</strong></h3><p>命令：<code>cd ../..</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-previous-previous.png" alt=""></p>
<h3 id="切换到当前目录的上一级目录-1"><a href="#切换到当前目录的上一级目录-1" class="headerlink" title="切换到当前目录的上一级目录"></a><strong>切换到当前目录的上一级目录</strong></h3><p>命令：<code>cd ~</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-home.png" alt=""></p>
<h3 id="切换到根目录"><a href="#切换到根目录" class="headerlink" title="切换到根目录"></a><strong>切换到根目录</strong></h3><p>命令：<code>cd /</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-root.png" alt=""></p>
<h3 id="切换到某个目录"><a href="#切换到某个目录" class="headerlink" title="切换到某个目录"></a><strong>切换到某个目录</strong></h3><p>命令：<code>cd /etc/security</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-specific.png" alt=""></p>
<h3 id="返回进入当前目录前所在目录"><a href="#返回进入当前目录前所在目录" class="headerlink" title="返回进入当前目录前所在目录"></a><strong>返回进入当前目录前所在目录</strong></h3><p>命令：<code>cd /etc/security</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-just-now.png" alt=""></p>
<h3 id="把上个命令的参数用作cd命令的参数"><a href="#把上个命令的参数用作cd命令的参数" class="headerlink" title="把上个命令的参数用作cd命令的参数"></a><strong>把上个命令的参数用作cd命令的参数</strong></h3><p>命令：<code>cd !$</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-last-command.png" alt=""></p>
<h3 id="切换到名字带有空格的目录"><a href="#切换到名字带有空格的目录" class="headerlink" title="切换到名字带有空格的目录"></a><strong>切换到名字带有空格的目录</strong></h3><p>命令：<code>cd iweeek\ config/</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-space.png" alt=""></p>
<h3 id="切换到某个目录并且打印列表"><a href="#切换到某个目录并且打印列表" class="headerlink" title="切换到某个目录并且打印列表"></a><strong>切换到某个目录并且打印列表</strong></h3><p>命令：<code>cd /home/nijun/ &amp;&amp; ls;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-pipe.png" alt=""></p>
<h3 id="保存当前工作目录至内存"><a href="#保存当前工作目录至内存" class="headerlink" title="保存当前工作目录至内存"></a><strong>保存当前工作目录至内存</strong></h3><p>描述：保存当前目录到内存，然后切换到要求的目录。一旦popd被执行，它会从内存取出保存的目录位置，作为当前目录。<br>命令：<br><code>cd /home/nijun/sed</code><br><code>popd</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-pushd-popd.png" alt=""><br>说明：pushd和popd是Linux bash命令，也是其他几个能够保存当前工作目录位置至内存，并且从内存读取目录作为当前目录的脚本，这些脚本也可以切换目录。</p>
<h3 id="切换到某个字符串开头的目录"><a href="#切换到某个字符串开头的目录" class="headerlink" title="切换到某个字符串开头的目录"></a><strong>切换到某个字符串开头的目录</strong></h3><p>描述：如果目录中只有一个以s开头的目录，就会直接移动security目录中。如果有很多目录以s开头，而且命令行没有提供更多的标准，这将会移动到第一个以s开头的命令（以标准字典的顺序）。<br>命令：<br><code>cd /etc/s*</code><br><code>cd /etc/securi*</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-asterisk.png" alt=""></p>
<p>命令：<code>cd /etc/p?</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cd/cd-question.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2017/05/04/java/java-array/</loc>
    <lastmod>2018-06-18T13:24:25.857Z</lastmod>
    <data>
        <display>
        <title>java 二维数组</title>
        <pubTime>2017-05-04T14:47:40.000Z</pubTime>
      
         <content><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>Java 的数组是通过方括号[]来定义和使用的，以下两者都可以使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1;</span><br><span class="line"><span class="keyword">int</span> a1[]； <span class="comment">// 符合 C/C++</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>编译器不允许指定数组的大小，现在拥有的只是对数组的一个引用（已经分配的空间），而且没给数组对象本身分配任何空间。<br>为了给数组创建相应的存储空间，必须写初始化一维数组，即初始化表达式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a2;</span><br><span class="line">a2 = a1;</span><br></pre></td></tr></table></figure></p>
<h3 id="生成随机数量的数组元素-基本类型"><a href="#生成随机数量的数组元素-基本类型" class="headerlink" title="生成随机数量的数组元素(基本类型)"></a>生成随机数量的数组元素(基本类型)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br></pre></td></tr></table></figure>
<h3 id="生成随机数量的数组元素-非基本类型"><a href="#生成随机数量的数组元素-非基本类型" class="headerlink" title="生成随机数量的数组元素(非基本类型)"></a>生成随机数量的数组元素(非基本类型)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[rand.nextInt(<span class="number">20</span>)]; <span class="comment">// 这时执行 a[i] 是 null</span></span><br></pre></td></tr></table></figure>
<p>因为是非基本类型，所以 a 只是一个引用数组，直到通过创建新的 Integer 对象（自动包装机制），并把对象赋值给引用，初始化进程才算结束。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = rand.nextInt(<span class="number">500</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><strong>二维数组，即数组的数组，二维数组的每一个元素都是一个一维数组。</strong></p>
<h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><p>数据类型[][] 数组名 = new 数据类型[二维数组的长度/包含以为数组的个数][每个一维数组的长度];<br>数据类型 数组名[][] = new 数据类型[n][m];<br>数据类型[] 数组名[] = new 数据类型[n][m];</p>
<p>int[][] arr = new int[3][5]; // 定义了一个基本类型整体的二维数组，包含 3 个一维数组，每个一维数组可以存储 5 个整数。<br>arr[0] // 第一个一维数组，下标为0<br>arr[1][3] // 获取第二行第四列上的元素</p>
<h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><p>数据类型[][] 数组名 = { {元素},{元素1， 元素2},…… };<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#125;,</span><br><span class="line">	&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.deepToString(); <span class="comment">// 将多维数组转换为多个String</span></span><br></pre></td></tr></table></figure></p>
<h3 id="粗糙数组："><a href="#粗糙数组：" class="headerlink" title="粗糙数组："></a>粗糙数组：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">10</span>)][][];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">8</span>)][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) &#123;</span><br><span class="line">        a[i][j] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.deepToString(a)); <span class="comment">// 对基本类型数组和对象数组都起作用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: [[[0, 0, 0], [], [0]], [[0, 0], [0, 0, 0], [0], </span></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]], [[<span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [], [], [<span class="number">0</span>]]]</span><br></pre></td></tr></table></figure>
<h2 id="二维数组的应用"><a href="#二维数组的应用" class="headerlink" title="二维数组的应用"></a>二维数组的应用</h2><p>二维数组的长度：数组名.length<br>每个一维数组的长度：数组名[下标].length<br>二维数组的遍历——双重 for 循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123; <span class="comment">//遍历二维数组，遍历出来的每一个元素是一个一维数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++)&#123; <span class="comment">//遍历对应位置上的一维数组</span></span><br><span class="line">		System.out.println(arr[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二维数组的反转——头尾交换"><a href="#二维数组的反转——头尾交换" class="headerlink" title="二维数组的反转——头尾交换"></a>二维数组的反转——头尾交换</h3><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">            arr[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[i][j] = arr[i - <span class="number">1</span>][j] + arr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(arr[i][j] + <span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] a = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">12</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">13</span>&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(Find(<span class="number">7</span>, a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Find</span> <span class="params">( <span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> columns = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (array.length != <span class="number">0</span>) &#123;</span><br><span class="line">        columns = array[<span class="number">0</span>].length;</span><br><span class="line">        rows = array.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rows &gt; <span class="number">0</span> &amp;&amp; columns &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> row = rows - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (row &gt;= <span class="number">0</span> &amp;&amp; column &lt; columns) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[row][column] == target) &#123;</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[row][column] &lt; target) &#123;</span><br><span class="line">                    column++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[row][column] &gt; target) &#123;</span><br><span class="line">                    row--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/04/18/other/understanding-the-domain/</loc>
    <lastmod>2018-06-18T12:41:56.346Z</lastmod>
    <data>
        <display>
        <title>浅谈域名</title>
        <pubTime>2018-04-18T01:57:53.000Z</pubTime>
      
         <content><p>前段时间创建了 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> 之后，随便也申请了一个属于我自己的域名。那么从申请域名到最后的设置自定义 GitHub Pages 域名，中间到底究竟发生了什么，本文就来说说离我们并不遥远的<strong>「域名」</strong>。</p>
<a id="more"></a>
<hr>
<h2 id="域名（Domain-Name）"><a href="#域名（Domain-Name）" class="headerlink" title="域名（Domain Name）"></a>域名（Domain Name）</h2><p>域名就是一串由点分隔的文字，更具体地说，是一段人类容易识别的文字，它的作用很简单，就是给一个 IP 取一个人们都够记住他的名字。域名是不区分大小写的。</p>
<h2 id="根域（DNS-Root-Zone）"><a href="#根域（DNS-Root-Zone）" class="headerlink" title="根域（DNS Root Zone）"></a>根域（DNS Root Zone）</h2><p>通常我们知道的域名，例如 <code>example.com</code> ，其实是完整域名的缩写。真正的全称为 <code>example.com.</code>，请注意最后的<code>.</code>，这个就是根域。它的现实体现为全球的 13 台<strong>固定 IP</strong> 的<strong>根域名服务器</strong>（root zone name servers），从 <code>a.root-servers.net</code> 到 <code>m.root.servers.net</code> 。在下文<code>完全限定域名</code>中还会提到它。</p>
<p>当我们在进行 DNS 查询的时候，如果一个全新的域名从来没有进行过查询，那么，最终会向这 13 台根域服务器进行请求。不过，现在的浏览器已经基本上默认不再添加这个「多余」的点了。</p>
<p>事实上，并不是真正的 13 台，而是 13 组，每一台在全球都有很多的镜像节点，所以你不用担心其中一台挂了会引起全球混乱。</p>
<h2 id="顶级域名（Top-level-Domain-TLD）"><a href="#顶级域名（Top-level-Domain-TLD）" class="headerlink" title="顶级域名（Top-level Domain - TLD）"></a>顶级域名（Top-level Domain - TLD）</h2><blockquote>
<p>A top-level domain (TLD) is one of the domains at the highest level in the hierarchical Domain Name System of the Internet. The top-level domain names are installed in the root zone of the name space. For all domains in lower levels, it is the last part of the domain name, that is, the last label of a fully qualified domain name. For example, in the domain name <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a>, the top-level domain is <code>com.</code></p>
</blockquote>
<p><strong>顶级域名</strong>，是域名系统中层次最高的域名，具体表现为低级域名的最后一部分。例如：<code>iweeek.com</code> 其中的<code>.com</code>就是一个顶级域名，它是一种「不完全限定域名」（partially qualified domain name - PQDN）。</p>
<p>常用的顶级域名分为几种：</p>
<ol>
<li>国家顶级域名，例如<code>.cn</code>, <code>.jp</code></li>
<li>机构顶级域名，例如<code>.com</code>, <code>.edu</code>, <code>.org</code></li>
<li>还有其他分类</li>
</ol>
<h2 id="完全限定域名（Fully-Qualified-Domain-Name-FQDN）"><a href="#完全限定域名（Fully-Qualified-Domain-Name-FQDN）" class="headerlink" title="完全限定域名（Fully Qualified Domain Name - FQDN）"></a>完全限定域名（Fully Qualified Domain Name - FQDN）</h2><p>在介绍「完全限定域名」之前（和上文提到过「不完全限定域名」），先来看张图：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/The-hierarchy-of-labels-in-a-fully-qualified-domain%E2%80%93name.png" alt="完全限定域名的层次结构图"></p>
<p>这是一张完全限定域名的层次结构图，<code>ru.wikipedia.org.</code>中每一个被<code>.</code>分隔开的部分，在树形层次结构图中体现到具体的一个节点，根据树的数据结构特点，每个完全限定域名都是唯一的，也就是说，不存在歧义。另外，每一级域名控制它下一级的域名分配。</p>
<p>因为 DNS 的根域名（<strong>ROOT</strong>） 没有被命名，所以它以空字符串表示，体现在域名上，就用 <code>.</code> 代替表示为 <strong>ROOT</strong>。例如：<code>www.iweeek.com.</code>，显式地指定一个绝对域名，以空白的顶级域名标签结束（虽然末尾只看到<code>.</code>）。</p>
<p>下图是「完全限定域名」的一个例子：<br><img src="http://p748dqat4.bkt.clouddn.com/domain-example.jpg" alt=""></p>
<h2 id="二级域名（Second-level-domain）"><a href="#二级域名（Second-level-domain）" class="headerlink" title="二级域名（Second-level domain）"></a>二级域名（Second-level domain）</h2><p>一般我们所说的申请域名，就是申请的二级域名，在顶级域名的左侧加上一个自定义文字段。例如：<code>iweeek.com</code>。写到这里，肯定有人问，是不是有 N 级域名呢？答案是肯定的，形如</p>
<blockquote>
<p><code>二级域名.顶级域名.</code>，<code>三级域名.二级域名.顶级.域名</code>……</p>
</blockquote>
<p>一个域名至少包含一个二级域名（iweeek）和一个顶级域名（com），顶级域名有时候也叫作一级域名。</p>
<p>需要注意的是，一个完整字符串 <code>三级域名.二级域名.顶级域名.</code> 就是一个域名，例如：<code>static.iweeek.com.</code> 这个是一个三级域名。</p>
<h2 id="子域名（Subdomain-Name）"><a href="#子域名（Subdomain-Name）" class="headerlink" title="子域名（Subdomain Name）"></a>子域名（Subdomain Name）</h2><p>在「我们通常所说的域名」的基础上，又加入了子域名的概念，在「一个」域名的前面加上新的字段，代表这个域名下的某个特定的主机或者协议。最常用的就是 WWW 协议，例如：<a href="http://www.iweeek.com">www.iweeek.com</a> 就是 iweeek.com 的一个子域名，<strong>GitHub Pages</strong> 推荐使用 <code>www</code> 子域名作为自定义域名。</p>
<p>需要注意的是，子域名的概念在不同的域名中是不同的，请看上图 <code>pc15.tek.iweeek.com.</code> 的例子，<code>tek.iweeek.com.</code>是<code>iweeek.com.</code>的子域名，而<code>pc15.tek.iweeek.com.</code>则是<code>tek.iweeek.com.</code>的子域名，它们的上一级域名是不同的，这是相对的一个概念。</p>
<hr>
<h2 id="域名系统（Domain-Name-System-DNS）"><a href="#域名系统（Domain-Name-System-DNS）" class="headerlink" title="域名系统（Domain Name System - DNS）"></a>域名系统（Domain Name System - DNS）</h2><h3 id="什么是域名系统？"><a href="#什么是域名系统？" class="headerlink" title="什么是域名系统？"></a>什么是域名系统？</h3><p><strong>域名系统</strong>是互联网的一项服务。</p>
<h3 id="干什么用的？"><a href="#干什么用的？" class="headerlink" title="干什么用的？"></a>干什么用的？</h3><p><strong>域名系统</strong>的主要任务就是所谓的域名解析，通俗点说，就是你给域名系统一个域名，它会给你一个 IP 地址。</p>
<p>在域名解析的过程中，简单的理解就是把一个人类记得住的域名变成网络中机器认识的 IP 地址。</p>
<h3 id="DNS-是如何工作的？"><a href="#DNS-是如何工作的？" class="headerlink" title="DNS 是如何工作的？"></a>DNS 是如何工作的？</h3><p>DNS 服务器上存在一个数据库，数据库里保存了已经解析过的域名和 IP 地址相互映射记录，这么多 DNS 服务器就组成了一个<strong>分布式数据库</strong>。</p>
<p>还是以查询 <code>pc15.tek.iweeek.com.</code> 为例：</p>
<ol>
<li>客户端发送查询报文 <code>query pc15.tek.iweeek.com.</code> 至 DNS 服务器，DNS 服务器首先检查自身缓存，如果存在记录则直接返回结果。</li>
<li>如果记录不存在，则 DNS 服务器向根域名服务器发送查询报文 <code>query pc15.tek.iweeek.com.</code>，根域名服务器返回 <code>.com</code> 域的权威域名服务器地址，这一级首先会返回的是顶级域名的权威域名服务器。</li>
<li>DNS服务器向 <code>.com</code> 域的权威域名服务器发送查询报文 <code>query pc15.tek.iweeek.com.</code>，得到 <code>.iweeek.com</code> 域的权威域名服务器地址。</li>
<li>DNS服务器向 <code>.iweeek.com</code> 域的权威域名服务器发送查询报文 <code>query pc15.tek.iweeek.com.</code>，得到 <code>.tek.iweeek.com</code> 域的权威域名服务器地址。</li>
<li>DNS服务器向 <code>.tek.iweeek.com</code> 域的权威域名服务器发送查询报文 <code>query pc15.tek.iweeek.com.</code>，得到主机 <code>pc15</code> 的A记录，存入自身缓存并返回给客户端。</li>
<li>下次如果再次查询 <code>pc15.tek.iweeek.com.</code> ，那么第 <code>1</code> 步，DNS 服务器可以在缓存中找到这条记录，就直接返回给客户端了。</li>
</ol>
<h2 id="A-记录（A-Record）"><a href="#A-记录（A-Record）" class="headerlink" title="A 记录（A Record）"></a>A 记录（A Record）</h2><blockquote>
<p>An A record maps a domain name to the IP address (IPv4) of the computer hosting the domain. Simply put, an A record is used to find the IP address of a computer connected to the internet from a name.</p>
</blockquote>
<p><strong>A 记录</strong>在 DNS 中的意义就是，域名到 IP 地址的转换。所以，当我们在 DNS 服务器中添加一个 A 记录时，是告诉服务器，将这个特定的域名映射到一个 IP 地址。</p>
<h2 id="CNAME-记录（Canonical-Name-Record）"><a href="#CNAME-记录（Canonical-Name-Record）" class="headerlink" title="CNAME 记录（Canonical Name Record）"></a>CNAME 记录（Canonical Name Record）</h2><p><strong>CNAME</strong> 的意思，简单来说就是<strong>别名</strong>，即将一个域名映射到另一个域名（区别于 A 记录的 IP）。CNAME 通常有两种用法：</p>
<ul>
<li><p><strong>不同顶级域名之间的跳转</strong><br>例如：我的域名是 <code>iweeek.com</code>（顶级域名为 <code>.com</code>），如果我希望，当我访问这个域名的时候，其实是访问我的 <code>iweeek.github.io</code>（顶级域名为 <code>.io</code>），虽然它们是不同的顶级域名，但是我可以用 <strong>CNAME</strong> 记录映射。</p>
</li>
<li><p><strong>将一个子域名映射到域名</strong><br>例如：我的域名是 <code>iweeek.com</code>，如果我希望，当我访问 <code>www.iweeek.com</code> （一个 www 子域名）的时候，仍旧访问 <code>iweeek.com</code> 这个域名指向的内容，就可以利用 <strong>CNAME</strong> 将 <code>www.iweeek.com</code> 映射到 <code>iweeek.com</code>。</p>
</li>
</ul>
<p>例如我在阿里云中的域名配置：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/dns-iweeek.png" alt=""></p>
<p>A 记录的主机记录是 <code>@</code>，表示为空的意思，由于这是 <code>iweeek.com</code> 的解析设置，所以相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iweeek.com.           A       151.101.229.147</span><br><span class="line">www.iweeek.com.       CNAME   iweeek.com.</span><br></pre></td></tr></table></figure>
<p><code>151.101.229.147</code> 是我的 <code>iweeek.github.io</code> 的 IP 地址。上面的例子也就是说，域名 <code>iweeek.com.</code> 映射到 <code>151.101.229.147</code> 这个 GitHub 服务器，然后 <code>www.iweeek.com.</code> 映射到 <code>iweeek.com.</code>。</p>
<h2 id="NS-记录（Name-Serve-Record）"><a href="#NS-记录（Name-Serve-Record）" class="headerlink" title="NS 记录（Name Serve Record）"></a>NS 记录（Name Serve Record）</h2><p><strong>NS 记录</strong>简单来说，就是声明谁来负责解析我这个域名，指定了负责解析我这个域名的域名服务器地址。这条记录赋予我们一个特殊的能力，就是，我可以让自己指定一个 DNS 解析服务器，而不一定使用域名提供商自带的域名解析服务器。一般来讲，是两条记录，一条主服务器，一条副服务器，例如我在阿里云服务里分配的 DNS 服务器就是<code>dns3.hichina.com</code>，<code>dns4.hichina.com</code>。</p>
<blockquote>
<p>“If you want to know about hosts in the foo.com zone, ask the name server ns1.bar.com”</p>
</blockquote>
<p>其大致意思是：如果你想知道谁负责 <code>foo.com</code>这个域名的解析，就找<code>ns1.bar.com</code>域名服务器。</p>
<h2 id="DNS-解析的工作流程"><a href="#DNS-解析的工作流程" class="headerlink" title="DNS 解析的工作流程"></a>DNS 解析的工作流程</h2><p>例如使用我的子域名进行 DNS 追踪，命令如下：</p>
<p><code>dig +trace www.iweeek.com</code></p>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace www.iweeek.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">.			218335	IN	NS	a.root-servers.net.</span><br><span class="line">.			218335	IN	NS	b.root-servers.net.</span><br><span class="line">.			218335	IN	NS	c.root-servers.net.</span><br><span class="line">...</span><br><span class="line">;; Received 228 bytes from 192.168.199.1#53(192.168.199.1) in 156 ms</span><br><span class="line"></span><br><span class="line">com.			172800	IN	NS	a.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	b.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	c.gtld-servers.net.</span><br><span class="line">...</span><br><span class="line">;; Received 492 bytes from 198.97.190.53#53(198.97.190.53) in 679 ms</span><br><span class="line"></span><br><span class="line">iweeek.com.		172800	IN	NS	dns3.hichina.com.</span><br><span class="line">iweeek.com.		172800	IN	NS	dns4.hichina.com.</span><br><span class="line">;; Received 334 bytes from 192.31.80.30#53(192.31.80.30) in 650 ms</span><br><span class="line"></span><br><span class="line">www.iweeek.com.		600	IN	CNAME	iweeek.com.</span><br><span class="line">;; Received 56 bytes from 140.205.41.14#53(140.205.41.14) in 31 ms</span><br></pre></td></tr></table></figure>
<p>可以看到，以查找域名地址 <code>www.iweeek.com</code> 为例。首先，从最权威的 13 台根域名服务器查找，其中包含互联网上所有顶级域名的域名服务器信息。接着，在查询其中一个根域名服务器的时候，根域名服务器可能不会直接包含<code>www.iweeek.com</code>的记录，在这种情况下，根域名服务器会提供一些<code>com.</code>顶级域名服务器的<strong>引用信息（referral）</strong>，再次查询其中一个<code>com.</code>时，解析器可能会再次提供<code>iweeek.com.</code>（NS 记录表示域名服务器<code>dns3.hichina.com.</code>将会处理它）的一些信息。于是它会再次查询<code>www.iweeek.com.</code>（这是一个 CNAME 记录），这时，域名服务器正好有<code>iweeek.com.</code>的权威数据（authoritative data），递归查找到此终止。</p>
<p>这时，再次请求另一个域名，例如：<code>blog.iweeek.com.</code>，由于解析器之前已确定<code>com.</code>的权威名称服务器（authoritative name servers），所以这次它不需要从头开始解决过程，而是从域（zone）<code>com.</code>开始查找，从而避免对根域名服务器的另一个查询。</p>
<h2 id="告诉-GitHub-你的域名"><a href="#告诉-GitHub-你的域名" class="headerlink" title="告诉 GitHub 你的域名"></a>告诉 GitHub 你的域名</h2><p>在项目下建立一个名为 <code>CNAME</code> （注意一定要大写）文件，在其中写上给你的主页分配的域名地址，例如：<code>example.com</code> 或者 <code>blog.example.com</code>，不能是 <code>http://iweeek.com</code>。这个操作的实际作用是什么？</p>
<ul>
<li>当直接访问 <code>github.io</code> 的时候，GitHub 知道如何 redirect 到哪里。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Rebuilt URL to: iweeek.github.io/</span><br><span class="line">  Trying 151.101.229.147...</span><br><span class="line">TCP_NODELAY set</span><br><span class="line">Connected to iweeek.github.io (151.101.229.147) port 80 (#0)</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: iweeek.github.io</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: GitHub.com</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Location: https://www.iweeek.com/</span><br><span class="line">X-GitHub-Request-Id: EA10:30DF:E210B:F6A83:5AD6B9D7</span><br><span class="line">Content-Length: 178</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Wed, 18 Apr 2018 03:22:00 GMT</span><br><span class="line">Via: 1.1 varnish</span><br><span class="line">Age: 0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">X-Served-By: cache-hnd18730-HND</span><br><span class="line">X-Cache: MISS</span><br><span class="line">X-Cache-Hits: 0</span><br><span class="line">X-Timer: S1524021720.208656,VS0,VE116</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Fastly-Request-ID: dc9abadf58c0e71cf1d9c4de07b6607932f15f1b</span><br></pre></td></tr></table></figure>
<p>也就是说，当你指定了 <strong>CNAME</strong> 之后，我们再次访问一个 <code>github.io</code> 的网站时，我们会发现，域名自动变成了我们指定的自定义域名。这是因为 <strong>CNAME</strong> 中指出了自定义域名是什么，所以，当我们访问 <code>github.io</code>的时候，会触发http 301。</p>
<ul>
<li>当用你的域名访问的时候，github知道去哪个 io 里面找</li>
</ul>
<p>当然，当我们直接使用自定义域名访问的时候，由于 <code>DNS</code> 服务器中 <strong>CNAME</strong> 的配置，最终我们会访问 <code>github.io</code>的主机，当主机收到我们的请求的时候，会拿我们 <code>http</code> 请求中的 <code>host</code> 和 <code>repository</code> 中的 <strong>CNAME 文件</strong> 比较，从而知道，当前的域名应该访问哪个具体的 <code>xxx.github.io</code> 的内容。</p>
<hr>
<p>呼~~，总算是写完了，在找资料上面花了很长时间，不过也算是拼拼凑凑地完成了。在此感谢 <a href="http://winterTTr.me/2015/10/23/from-dns-to-github-custom-domain/index.html" target="_blank" rel="noopener">winterttr</a>，我只是在他的基础上，添加了一些自己的理解。</p>
<hr>
<p>References：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Fully_qualified_domain_name" target="_blank" rel="noopener">Fully qualified domain name - wikipedia</a></li>
<li><a href="http://www.omnisecu.com/tcpip/fully-qualified-domain-name-fqdn-and-partially-qualified-domain-name-pqdn.php" target="_blank" rel="noopener">What is Fully Qualified Domain Name?</a></li>
<li><a href="https://en.wikipedia.org/wiki/DNS_root_zone" target="_blank" rel="noopener">DNS Root Zone</a></li>
<li><a href="https://en.wikipedia.org/wiki/DNS_zone" target="_blank" rel="noopener">DNS Zone</a></li>
<li><a href="http://man.chinaunix.net/develop/rfc/default.htm" target="_blank" rel="noopener">中文 RFC 文档</a></li>
<li><a href="https://en.wikipedia.org/wiki/Subdomain" target="_blank" rel="noopener">Subdomain - wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Top-level_domain" target="_blank" rel="noopener">Top-level domain - wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">Domain Name System - wikipedia</a></li>
<li><a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">Using a custom domain with GitHub Pages - Github</a></li>
<li><a href="https://support.dnsimple.com/articles/differences-a-cname-records/" target="_blank" rel="noopener">Differences-a-cname-records</a></li>
<li><a href="https://superuser.com/questions/715632/how-does-dig-trace-actually-work" target="_blank" rel="noopener">How does dig +trace actually work?</a></li>
</ul>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/04/11/other/top-of-the-wave/</loc>
    <lastmod>2018-06-18T12:41:56.346Z</lastmod>
    <data>
        <display>
        <title>《浪潮之巅》读后感（一）</title>
        <pubTime>2018-04-11T12:05:10.000Z</pubTime>
      
         <content><blockquote>
<p>今天开始看《浪潮之巅》，这的确是本难得的好书，个人感觉是一本 IT 史记，不读妄作 IT 人。书中不仅陈述了事实，也总结出许多规律。为什么《史记》使用的是纪传体，而不是编年体？因为历史不是知道就可以了，我认为重要的是在于理解和总结，不懂历史的人是不懂现在，也看不到未来。朝着这个思路，去看《浪潮之巅》，就可以告知我们所处境遇，和未来追逐的目标。</p>
</blockquote>
<p>书中大部分都是以一个公司为题材展开叙述的，讲一家公司的前世今生甚至是未来的发展趋势。介绍地很详细，读完后会对这些公司有更加深入的了解，了解公司的各个方面，譬如：公司的企业文化、基因、创始人和领导人、发展战略等等。当然在讲这些公司的时候，吴军也介绍了一些美国科技企业发展的大环境，美国的商业环境，这让我们对美国又多了一些了解，读完这些章节你会收获很多。</p>
<a id="more"></a>
<p>书的后半部分讲解了许多金融、经济类的知识，深入浅出，能让非专业的人也能够读懂，开阔眼界。不过这部分我还没读到，以后再更新这部分感想。</p>
<p>还有一点，我觉得吴军作为一个计算机博士，不仅在技术上高山仰止，还有非常好的文笔以及对行业的看法。这让我想到了 stormzhang 说过的培养第二技能，也就是不能把自己局限于一个方面，而是要广泛地获取各方面的知识，开拓自己的视野。为了这个目标，「可积累性」更强的<strong>写作</strong>就是一个好的第二技能，因为要想写好，没有大量的阅读几乎是不可能的。所以这会促使你进行大量的阅读，以丰富自己的知识，才能逐渐提高写作水平。</p>
<p>目前看了开头几章，吴军写这本书的一个原因，我想是为了教会我们思考的重要性，书中包括了吴军的许多思考以及对未来的预测等信息，这会感染到我们，这会让我们在闲暇的时候停下手中的研究或者工作，来考虑当前的科技行业的未来在哪里，我需要如何努力才能赶上这次行业的浪潮，成为一个时代的弄潮儿。</p>
<p>下面是每章的总结，会定期更新~</p>
<h2 id="百年帝国-AT-amp-T"><a href="#百年帝国-AT-amp-T" class="headerlink" title="百年帝国 AT&amp;T"></a>百年帝国 AT&amp;T</h2><p>人物：亚历山大·贝尔</p>
<p>关键词：贝尔实验室、电话、电报公司、无线通信、拆分、贪婪、短视、蓝筹股、华尔街投资公司、反垄断</p>
<p>AT&amp;T 是美国电话和电报公司的简称，由亚历山大·贝尔在 1877 年创立，电话的发明和 AT&amp;T 公司的建立，第一次实现了人类的远程实时的交互通信，并且使得平民百姓受益。它旗下的贝尔实验室是历史最大的、最成功的私有实验室。在通信、计算机、半导体等领域领先于世界，一度成为信息科学家趋之若鹜的地方。1995 年是个分水岭，在这之前即使是在反垄断案失败的情况下，也没有使之断气，反而发展得更好了，到 1994 年营业额达 700 亿美元。但在这之后，它便分崩离析，不复存在了。</p>
<p>AT&amp;T 不紧不慢地向上走过了百年，才爬到定点，走下坡路却只要十年。从 1995 年起的这十年间，AT&amp;T 本来有两次绝佳的发展机遇，2000 年前后的网络革命，和从九十年代中期延续至今的无线通信的飞跃。它不仅没有利用好机会，反而在这两场变革中丢了性命。</p>
<p>曾经的百年帝国由于自己的贪婪和短视（自个儿拆了卖），加之互联网的兴起，彻底击垮了这个帝国，葬送在了互联网的浪潮中。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>AT&amp;T 的发展史，具有一定的参考意义，一个公司发展到——全公司上下没有人真正绝对地控制公司，也就是说股票没有那些投资银行控制得多，不以研究为主，导致创新力不复存在的时候，那么这家公司十有八九会被时代的浪潮所吞噬。</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/04/17/other/three-successful-transgenic-companies/</loc>
    <lastmod>2018-06-18T12:41:56.345Z</lastmod>
    <data>
        <display>
        <title>《浪潮之巅》读后感（三）—— 成功的转基因</title>
        <pubTime>2018-04-17T00:22:23.000Z</pubTime>
      
         <content><p>上一篇讲到基因决定定律，一个公司的基因常常决定了它的命运。而转基因对于大多数公司来讲是近乎不可能的。但是凡事总有例外，总有一些了不起的公司成功地从一个衰退的行业转到新的高速发展的行业。这样，公司之间就有了伟大和平庸的差别。《浪潮之巅》里介绍了三种不同的转基因成功的例子。</p>
<a id="more"></a>
<h3 id="从木工厂到手机之王（诺基亚）"><a href="#从木工厂到手机之王（诺基亚）" class="headerlink" title="从木工厂到手机之王（诺基亚）"></a>从木工厂到手机之王（诺基亚）</h3><ul>
<li>长期探索、抓住机遇和制定规则。</li>
</ul>
<h3 id="道琼斯的常青树（3M）"><a href="#道琼斯的常青树（3M）" class="headerlink" title="道琼斯的常青树（3M）"></a>道琼斯的常青树（3M）</h3><ul>
<li>创新力。3M 允许员工用 15% 的时间干任何自己喜欢做的事，也被 Google 学去了，变成了 Google 的“百分之二十项目”。</li>
<li>坚持创新为公司的灵魂，保持着无数的发明作为技术储备。</li>
<li>在适当的时候强制淘汰一些看似还在挣钱但是前景不是很好的产品。</li>
<li>3M 的发明和产品都是针对广大用户的，而且是消耗性的，为 3M 提供了足够的财力保证它的新产品上市并占领市场。</li>
</ul>
<h3 id="通用电气（GE）"><a href="#通用电气（GE）" class="headerlink" title="通用电气（GE）"></a>通用电气（GE）</h3><ul>
<li>经营模式，让子公司相对独立。</li>
<li>从来不缺乏创新。它的创新早已经不是在一两个技术和一两种产品上了，而是行业的创新。很少进入一个已经成熟而且竞争对手很多的市场。它在历次技术革命中都没有落伍。</li>
<li>扩张也有不少失败的，但能很聪明地及时将不可能成功的业务终止掉。</li>
<li>有些虽然盈利但是不看好它们的前景的部门，GE 在它们还值钱的时候出手卖掉。</li>
<li>GE 成功从实体经济进入到金融，有三点。一是它和政府的关系很好，在某种程度上还支撑着美国的基础建设、航空工业和国防工业，二是信用记录和还贷能力非常好，三是有一个好领袖（杰克·韦尔奇）。</li>
</ul>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>由于科学技术是最革命，发展最快的生产力。一个科技公司想在几次技术革命大潮中都能够立于浪潮之巅是一件极不容易的事。企业能否不断成功转型是关键。由于企业基因的影响，大部分企业不能做到这一点，因此就有了新公司的兴起和老牌企业的衰退。一个跨国公司能够像诺基亚那样做到一次成功转型已属不易，像 3M 和 GE 那样一百年来长盛不衰则是凤毛麟角。3M 是靠硬性的制度维持其创新，而 GE 是靠自己不断开创新的产业。</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/04/05/other/this-time-I-am-serious/</loc>
    <lastmod>2018-06-18T12:41:56.345Z</lastmod>
    <data>
        <display>
        <title>这次，我认真了</title>
        <pubTime>2018-04-05T08:40:24.000Z</pubTime>
      
         <content><p>Hi guys, I’m iweeek, who decided to write my own blog while I’m coding. As far as I’m concerned, Writing blog is my favorite thing to do and is also a part of life. EveryTime I felt tired, I would stop coding to read books or play macdown, and then writed my feelings and reviews in it. In this way can I deepen the knowledges in my brain and can also make me relaxing.</p>
<p>Welcome to <a href="https://www.iweeek.com/">iweeek’s blog</a> website, Thank for you coming, and thank for your surpport. They are the energy to encourage me to move forward.</p>
<p>Today I will begin my blog journey, and I will update it frequently.<br><a id="more"></a></p>
<hr>
<p>我是 iweeek, 也许你并不知道我是谁，也许你在其他地方了解过我。但，今天我们在这里相遇便是缘分。</p>
<p>「写博客」这件事去年就做了，但是没有做成，我不为自己找任何理由，因为那不是我。人就是这样一种「懒」的动物，对玩，会上瘾。没有一颗坚定不移的心，抱着试试的心态，注定要失败。可这次，我认真了。</p>
<p>我认真了，不知道原因，也许是因为自己陷入了所谓的舒适圈太久了，也许是因为连自己都开始讨厌自己那停滞不前的自己，也许是遇到了那个 ta。无论什么原因，我就想把这件事坚持下去。每天有那么一件事总在提醒着我，鞭策着我，也许改变就会发生在不知不觉中。</p>
<p>去年 12 月份在校时，由于一些事情受挫，精神上一直很懒散。不过幸好后来及时反思，自己做事就是不够干脆，不够阳刚。然后想要改正，在实习期间，制定了早起计划，想要磨炼性格，一开始还发朋友圈，想要朋友们监督，希望别人看到自己的努力。但后来不发了，自己给自己找了个借口，做这个不是为了炫耀，而是为了让自己成为更好的自己。结果，在缺乏别人的监督之后，只坚持了一个月，半途而废了。</p>
<p>我时常想起，“只要坚持下去，一年之后就能超过 80% 的人。”这句话。但是，道理我都懂，但是有的时候就是不去执行，我想问题只会出在自己身上。</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/onemore.png" alt=""></p>
<p>这张图片大家一定不陌生，1.01 和 0.99 看起来只差 0.02，但是在时间的影响下，结果将会有巨大的不同。记得《数学之美》里，有一段是讲从数字感悟生活的片段：</p>
<blockquote>
<p>1.01^3 * 0.99^2 &lt; 1.01 (三天打渔，两天晒网)。</p>
</blockquote>
<p>这些数字虽然是没有生命的，但是所表达出来的意义却能说明很多东西。</p>
<p>我不想做生理性的懒，那种懒会让整个人处在消极被动状态。而是朝着思想上的懒看去，就是懒于将时间浪费在没有意义的事情上面，进而思考用一种更为合理、高效的方式去处理问题。这种懒是人类种种发明的源泉，是良性的，本质上是两点之间直线最短，谋求效率最大化的品性。这样的「懒」人，往往是现实生活中最勤快的。所以我在 Mac 上装了许许多多的效率工具，其本质就是「懒」，接下来会准备一篇我电脑上的一些好用的工具。</p>
<hr>
<p>简单说说我的经历，大一大二的时候，忙着学校各种事，对编程也没什么兴趣，但关于编程的课程我都考得很好，也不知道当时是怎么考的。直到大三开始，由于我成绩排在专业第一（这个第一，我觉得是很水的，基本上没有真正的编程功力，只是笔试比较好，哈哈哈，写出来也是给自己鼓劲，我也是有过排在第一名的人，以前老是看到别人第一第二的），所以有机会来到校本部。</p>
<p>那时候是大二下学期，在得知有这个机会的时候，我激动不已，当晚都没睡好觉。我原本的学校并不好，是个不入流的学校，高考那会儿贪玩了，只能勉强够上分数，但万幸的是——我进入了我喜欢的计算机专业，这一点很重要的。第二天，我就开始忙着打听校本部的课程安排进度，本部的课程与我那时的课程有些许出入，好强的我，可不想在进入本部的时候被其他人拉下一大截。</p>
<p>真正开始意识到危机感是在大三刚开始的时候，那一年我开始真正静下心来编程，学习各种编程知识，也入手了自己人生中的第一台 Mac，从此开始了不归路，开始研究 Mac 的各种小技巧，Mac 上最好的应用，技术栈的范围也从最初的 C、C#，慢慢扩展到了 Java、JavaScript、Android、Linux、Objective-C，一路上遇到的各种问题和坑，都好像跳跃在眼前一样。</p>
<p>大四的时候在学校里参加了一个运动 APP 的开发，一周七天，基本上都在学习和工作。这样持续了三个月，这段时间里我对编程的认知有了进一步的认识，学到了在学校里很难接触到的新东西和新理念，可以说，这是我进大学以后最有效率的一段时间。手把手带我的是一位曾在 360 工作过的技术主管，他的技术是高山仰止的，同时为人也非常好，有问必答，当然挨骂是避免不了的，在问到一些技术上的细枝末节时，也会冷冷地抛来一句，“自己查去！blah blah……”。不过挨骂这些都不是事儿，在他身上，我学到了如何使用 Google 搜索，自我解决问题的能力，学好英语的重要性，编码上的各种规范，以及各种曾在他身上发生过的坑与坎。</p>
<hr>
<p>因为我知道，想要获得成功，就必须延迟满足。曾在《MacTalk 跨越边界》中看到一段话：</p>
<p>“他们在清晨的微光里编写代码，在轰鸣的机房中调试程序，他们彻夜不眠就是为了解决一个 bug，他们要承受数据丢失或上线失败的痛苦，默默吞下眼泪，准备下一次的战斗。不停的学习、实践和思索，成千上万个小时之后，高手始成。”</p>
<p>读了这段话，我觉得我该上路了，以前欠下的太多，现在只能拼命向前追赶。为了不让自己落下地太多，我决定把自己的起点定得高一些，当别人在看视频的时候，我坚持看博客、文档，这节省了我很多学习时间，也提高了阅读能力。当别人在用百度，查国内各种二手资料的时候，我坚持使用 Google，查看国外英文文档、大牛的博客。我英语很差，只过了四级，这对我来说很难，但是我硬逼着自己，坚持下去，电脑系统、手机都是英文的（后来，慢慢的，阅读英文文档就没有刚开始那么困难，因为常用的词汇就那么些）。虽然现在还看不出来很大的进步，但是时间长了，我相信是可以后来居上的。</p>
<p>现在，我决定写博客，并不是那种一时兴起，我也不愿成为那样。我爱这个爱好，爱好是最容易坚持的，甚至不用坚持，爱好就是那种无论你多忙多累都会挤出时间去做的事情，比如跑步、健身、下棋、弹琴或写作。很多人说工作累得要死，哪还有时间去健身呢？其实，当你感觉自己精疲力尽头脑发晕的时候，去跑上 20 分钟或者去健身就会发现，健身不仅会消除疲劳，提神醒脑，还能让你睡得更香，第二天精力充沛。写作与健身一样，当编程感到很累的时候，打开 MacDown ，整理思绪写下自己的文字，能加深自己的理解。</p>
<p>我会拾起去年定下的目标，努力把每件事情做好，写博客会坚持下去，我在写下这篇文章的时候就已经下定决心了，改变自己。不为了什么，就为了看看自己到底能不能做到。</p>
<p>上个月入手了 Kindle，看完了几本爱看的书，阅读真的是一个非常好的习惯，可以提高写作能力，增长眼界，聊起天来也有趣儿多了。与编程一样，前期没有大量的阅读作为支撑，怎么能写好文章呢？现在也算是养成了阅读的习惯，现在我每天都会阅读，公众号、知识星球、知乎、书籍等等，阅读多了，自然会爱上阅读，写作也是，虽然写作才刚开始，但我希望这也能成为我的习惯，我会在今年以及未来很多年把这件事进行下去。</p>
<p>最近我在学习 Objective-C，直接阅读英文原版书籍，现在的确没感觉到读英文技术书籍有什么难度，知识点也是一个一个掌握，可能现在没有感觉到看英文原版的好处，但我相信会比其他人学得更扎实一些。</p>
<p>认真对待每一天，改变从现在开始，我就想认认真真的做自己，不要再混下去，况且我还有理想，我还有梦！</p>
<p>希望大家以我为鉴，时不时给自己提个醒，<strong>「勿忘初心」</strong>。</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/04/13/other/IT-laws/</loc>
    <lastmod>2018-06-18T12:41:56.344Z</lastmod>
    <data>
        <display>
        <title>《浪潮之巅》读后感（二）—— IT 定理</title>
        <pubTime>2018-04-12T16:47:43.000Z</pubTime>
      
         <content><blockquote>
<p>整个信息技术（Information Technologies，简称IT）产业包括很多领域、很多环节，这些环节之间都是互相关联的。和世界上任何事物同样，IT产业也是不断变化和发展并且有着它自身发展规律的。这些规律，被IT领域的人总结成一些定理，称为IT定理（IT Laws）。</p>
</blockquote>
<a id="more"></a>
<h3 id="摩尔定理（Moore’s-Law）"><a href="#摩尔定理（Moore’s-Law）" class="headerlink" title="摩尔定理（Moore’s Law）"></a>摩尔定理（Moore’s Law）</h3><p>计算机和整个 IT 行业的发展比传统行业要快得多，最早看到这个现象的是英特尔公司的创始人戈登·摩尔（Gorden Moore）。1965 年，他就提出，在至少十年内，集成电路的集成度会每两年翻一番。后来这个周期缩短到十八个月。现在来看，每十八个月，计算机等 IT 产品的性能会翻一番；或者说相同性能的计算机等 IT 产品，每十八个月价钱会降一半。这个定理的适用性一直持续至今，没有任何停下来的迹象。在人类的文明史上，没有任何一个其他行业做到了这一点。</p>
<p>摩尔定理主导者 IT 行业的发展。为了能使摩尔定理成立，IT 公司必须在比较短的时间内完成下一代的产品开发。这就要求，IT 公司在研发上必须投入大量资金，这使得每个产品的市场不会有太多的竞争者。在计算机处理芯片方面，只有英特尔和 AMD；在高端系统和服务方面，只有 IBM 和太阳；在个人电脑方面，是惠普和戴尔。</p>
<h3 id="安迪-比尔定理（Andy-and-Bill’s-Law）"><a href="#安迪-比尔定理（Andy-and-Bill’s-Law）" class="headerlink" title="安迪-比尔定理（Andy and Bill’s Law）"></a>安迪-比尔定理（Andy and Bill’s Law）</h3><p>安迪-比尔定理，简单来说，就是比尔要拿走安迪所给的（What Andy gives, Bill takes away）。安迪是原英特尔公司 CEO 安迪·格鲁夫（AndyGrove），比尔就是微软的创始人比尔·盖茨。个人电脑工业整个的生态链是这样的：以微软为首的软件开发商吃掉硬件提升带来的全部好处，迫使用户更新机器让惠普和戴尔等公司收益，惠普和戴尔等公司以及其他的外设厂在利润得到相应之后，股票也随着增长。各个硬件半导体和外设公司再将利润投入研发，按照摩尔定理制定的速度，提升硬件性能，为微软下一步更新软件、吃掉硬件性能做准备。这是一个互帮互助、双赢的局面。其结果就是，安迪-比尔定理把原本属于耐用消费品的电脑、手机登商品变成了消耗性商品，刺激着整个 IT 领域的发展。</p>
<h3 id="反摩尔定理（Reverse-Moore’s-Law）"><a href="#反摩尔定理（Reverse-Moore’s-Law）" class="headerlink" title="反摩尔定理（Reverse Moore’s Law）"></a>反摩尔定理（Reverse Moore’s Law）</h3><p>Google 的 CEO 埃里克·施密特在一次采访中指出，如果你反过来看摩尔定理，一个 IT 公司如果今天和十八个月前卖掉同样多的、同样的产品，它的营业额就要降一半。也就是说，一个 IT 公司花了同样的劳动，却只得到以前一半的收入。反摩尔定理逼着所有的硬件设备公司必须赶上摩尔定理规定的更新速度，从某种意义上来说，这是反摩尔定理积极的一面。</p>
<h3 id="70-20-10律"><a href="#70-20-10律" class="headerlink" title="70-20-10律"></a>70-20-10律</h3><p>当某个领域发展成熟后，一般在全球容不下三个以上的主要竞争者。老大是这个领域的主导者，不仅占据着超过一半，通常是百分之六七十的市场，并且制定了这个领域的游戏规则。老二有自己稳定的百分之二三十的市场份额，有时也会挑战老大并给老大一些颜色看看，但是总的来讲是受老大欺负的时间多。剩下的数量虽然多，但是却只能占到百分之十甚至更少的市场，它们基本上唯老大马首是瞻。老大总是密切注视着老二，并时不时地打压它，防止它做大。老大和老二通常都不会太在意剩下的小企业，这样就让这一群小的企业能有挣一些小钱的地方。</p>
<blockquote>
<p>为什么在信息产业的公司比传统工业更容易形成主导优势呢？</p>
<p>传统行业研发成本低，但各种制造成本和销售成本是非常高的。研发成本可以通过规模经济来抵消，而制造成本则不能。<br>科技领域则大不相同，制造的成本只占营业额的很小一部分，而研发成本占大多数，软件可以无限复制并且无损耗。<br>其次，信息产品的生态链各环节之间的耦合性非常强。<br>再次，不同童虎对传统商品的品味不同，对性能的要求也不同，使得它很难做到赢者通吃。对于科技产品，虽然不同公司的同类产品可能有所不同，但是，这些区别不足以左右主流用户的选择。对于主流的用户来讲，科技产品的性能指标是硬性的，好就是好，不好就是不好。</p>
</blockquote>
<h3 id="诺威格定理"><a href="#诺威格定理" class="headerlink" title="诺威格定理"></a>诺威格定理</h3><p>谷歌研究院院长彼得·诺威格博士说，“当一个公司的市场占有率超过 50% 以后，就不要再指望在市场占有率上翻番了”。诺威格定理决定了一个市场占有主导地位的公司必须不断开拓新的财源，也就是必须找到和原有市场等规模甚至是更大的新市场，才能做到长盛不衰。</p>
<p>目前为止，「扩展现有业务」和「转型」是被证明了可行的途径。扩展的前提是相近领域有可扩展的空间。转型适合于整个大的行业发展已经饱和，扩展的空间已经不存在，也就是一个行业进入老年期的时候。</p>
<p>成功的转型是失之东隅、收之桑榆。在这种乾坤大挪移的过程中，一个公司的根子或者说基因需要改变，而改变公司的基因和改变人的基因一样困难。</p>
<h3 id="基因决定定理"><a href="#基因决定定理" class="headerlink" title="基因决定定理"></a>基因决定定理</h3><p>一个公司的基因几乎决定了它转型的失败是必然的，成功反而是偶然的。为什么一个公司转型就那么难呢？答案就是“基因使然”。</p>
<p>同一个市场在不同的公司眼里是完全不同的东西。例如，个人微机在苹果公司的眼里和在微软的眼里完全不同。严格地讲，苹果不能算是一个计算机公司，而是一个注重创新的消费电子公司，在苹果眼里，计算机不过是新的电子产品的一种。</p>
<p>一个公司的产品和服务可能随着市场的变化不断改变，但是公司的基因却很难改变。苹果的基因决定它必须通过硬件挣软件的钱。</p>
<p>一个公司的基因并不像人的基因那样看得见摸得着，它是一个公司在市场竞争中进化出来的适应该市场的企业文化、管理方法、产品市场定位、商业模式个营销方式等等。一个公司在早期，一切还是一张白纸的时候，其基于还有改变的可能。越是以前成功的公司越是容易相信自己固有的基因是最优秀的。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>在一个新的信息技术产业刚刚形成时，它总是有多个可以互相抗衡的竞争者。但是，一旦有一家主导公司出现，它就可能成为该行业游戏规则的制定者，并把它变成在商业上难以抵消的优势，迅速占领全球市场。在信息工业产业，这个过程通常比我们想象的快得多。但是，一旦一个公司占有全球一大半市场时，它就不得不寻找新的成长点。而这时的跨国公司已经不是当年那个朝气蓬勃的公司了，它固有的基因使得它的转型十分艰难。如果它能够幸运的转型成功，它将再次获得新生，否则就会被技术革命的浪潮淘汰。 </p>
<p>科学技术无疑是我们这个时代推动社会前进的主要动力。一次次技术革命的浪潮造就出站在它的浪尖上的成功者，埋没掉赶不上大潮的失败者。</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/29/mysql/mysql-jdbc-zeroDateTimeBehavior/</loc>
    <lastmod>2018-06-18T12:41:56.343Z</lastmod>
    <data>
        <display>
        <title>Mysql JDBC 连接池时间转换问题</title>
        <pubTime>2018-05-29T04:48:59.000Z</pubTime>
      
         <content><p>在查询 Mysql 数据库的时候，有时候会产生一个异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value <span class="string">'0000-00-00 00:00:00'</span> can not be represented as java.sql.Timestamp. Stacktrace follows:</span><br><span class="line">java.sql.SQLException: Value <span class="string">'0000-00-00 00:00:00'</span> can not be represented as java.sql.Timestamp</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>查找资料</p>
<blockquote>
<p><strong>Datetimes</strong> with all-zero components (<em>0000-00-00</em> …): These values cannot be represented reliably in Java. Connector/J 3.0.x always converted them to NULL when being read from a ResultSet.<br><br></p>
<p>Connector/J 3.1 throws an exception by default when these values are encountered, as this is the most correct behavior according to the JDBC and SQL standards. This behavior can be modified using the zeroDateTimeBehavior configuration property. The permissible values are:</p>
<ul>
<li>exception (the default), which throws an SQLException with an SQLState of S1009.</li>
<li>convertToNull, which returns NULL instead of the date.</li>
<li>round, which rounds the date to the nearest closest value which is 0001-01-01.</li>
</ul>
</blockquote>
<p>这个问题出现的起因是，尝试将一个存储在 Mysql 里的零值日期（<code>0000-00-00 00:00:00</code>），转换为一个 Java 日期对象。</p>
<p>关键在于在 Mysql 里 <code>0000-00-00 00:00:00</code> 可能是有效的；而在 Java 中，这样的转换是无效的。</p>
<p>因此，Mysql JDBC 驱动将抛出一个 java.sql.SQLException ，因为 Java 不能识别 <code>0000-00-00 00:00:00</code> 这样的日期格式。</p>
<p>解决的办法：<br>1、可以改变数据库的模式（schema），使之允许 NULL 值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> datefield = <span class="literal">NULL</span> <span class="keyword">WHERE</span> datefield = <span class="string">'0000-00-00 00:00:00'</span>;</span><br></pre></td></tr></table></figure>
<p>2、在 JDBC 数据库连接池配置中，编辑 JDBC URL ，添加一个 <code>zeroDateTimeBehavior = convertToNull</code> 的参数。这样 Java 就会把零值日期转换为 null 值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://localhost:3306/yourMySqlDatabase?zeroDateTimeBehavior=convertToNull</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html" target="_blank" rel="noopener">zeroDateTimeBehavior 定义</a><br><a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-installing-upgrading-3-0-to-3-1.html" target="_blank" rel="noopener">zeroDateTimeBehavior 三个选项</a></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/12/linux/daily-command-uniq/</loc>
    <lastmod>2018-06-18T12:41:56.342Z</lastmod>
    <data>
        <display>
        <title>Linux uniq总结</title>
        <pubTime>2018-06-12T00:53:22.000Z</pubTime>
      
         <content><p>uniq命令用于报告或忽略文件中的重复行。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>uniq命令可以轻松地从文件中找到重复的行，而且可以删除重复项，显示重复项出现的次数，只显示重复的行，只显示唯一的行。<br>请注意，除非重复行是相邻的，否则uniq不会删除它们。因此可能需要先对它们进行排序，或将排序命令与uniq组合使用。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>uniq [选项] [文件]</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-c或——count：在每列旁边显示该行重复出现的次数；</li>
<li>-d或–repeated：仅显示重复出现的行列；</li>
<li>-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt;：忽略比较指定的栏位；</li>
<li>-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt;：忽略比较指定的字符；</li>
<li>-u或——unique：仅显示出一次的行列；</li>
<li>-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt;：指定要比较的字符。</li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 默认情况</strong><br>描述：uniq命令删除了给定文件中所有连续重复的行。可以看到输出中，第1行和第3行重复了，第2行和第5行重复了。这是因为uniq命令只有在相邻的情况下才会删除重复的行<br>命令：<code>uniq device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq.png" alt=""></p>
<p><strong>实例：2. 删除所有重复的行</strong><br>描述：经过排序之后，所有相同的行都连续地排在一起，达到了删除所有行的目的。<br>命令：<br><code>sort -u device</code><br><code>sort device | uniq</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-sort.png" alt=""></p>
<p><strong>实例：3. 仅显示不连续重复的单一行</strong><br>描述：只显示device中不连续重复的单一行，只有10:aaa:43是唯一的。<br>命令：<code>uniq -u device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-u.png" alt=""></p>
<p><strong>实例：4. 找出重复的行</strong><br>显示device文件中连续出现的重复行。同样，不连续重复的相同行是不重复的行。</p>
<p>描述：33:fff:221出现了两次，因为它们不是连续的。<br>命令：<code>uniq -d device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-d.png" alt=""></p>
<p>描述：在device文件中的第一行插入一行11:eee:49，但输出中没有出现，因为它们不是连续的。<br>命令：<br><code>vim device &lt;修改文件&gt;</code><br><code>uniq -d device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-d5.png" alt=""></p>
<p>描述：先排序，然后真正找出重复的行。<br>命令：<code>sort device | uniq -d</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-d3.png" alt=""></p>
<p>描述：先排序，然后将所有重复的行全部显示出来。<br>命令：<code>sort device | uniq -D</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-d4.png" alt=""></p>
<p><strong>实例：5. 统计各行在出现的次数</strong><br>描述：-c选项统计device文件中各行重复的次数。<br>命令：<code>uniq -c device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-c.png" alt=""></p>
<p>描述：下面的例子，检查给定文件中每一行重复出现的行数。<br>命令：<code>sort device | uniq -c | sort -nr</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-c-sort.png" alt=""></p>
<p><strong>实例：6. 将比较限制为N个字符</strong><br>描述：只比较每行的第一个字符。输出中可以看到，前两行被当做相同的行。-d选项将比较限制为N个字符。<br>命令：<code>uniq -d -w 1 device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-w.png" alt=""></p>
<p><strong>实例：7. 忽略N个字符后比较</strong><br>描述：下面的命令将忽略在文件中每行的前七个字符后，再进行比较。-s选项来忽略比较前N个字符。<br>命令：<code>uniq -d -s 7 device</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-s.png" alt=""></p>
<p><strong>实例：8. 忽略N个字段后比较</strong></p>
<p>描述：先将device文件的内容排序后，用awk格式化输出。-t和-F指定sort和awk的域分隔符。<br>命令：<code>sort -t: device | awk -F: &#39;{print $1&quot; &quot;$2&quot; &quot;$3}&#39;</code></p>
<p>描述：忽略两个字段后进行比较。从输出中看到，第三个字段只有49和221是重复的。-f选项指定忽略N个字段后，再进行比较。<br>命令：<code>sort -t: device | awk -F: &#39;{print $1&quot; &quot;$2&quot; &quot;$3}&#39; | uniq -d -f 2</code></p>
<p>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/uniq/uniq-f.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/10/linux/daily-command-read/</loc>
    <lastmod>2018-06-18T12:41:56.299Z</lastmod>
    <data>
        <display>
        <title>Linux read总结</title>
        <pubTime>2018-06-10T13:36:30.000Z</pubTime>
      
         <content><p>read命令从键盘或文件的某一行文本中读入信息，并将其赋给一个变量。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>read 变量1 [变量2...]</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>read命令从键盘或文件的某一行文本中读入信息，并将其赋给一个变量。在read命令后面，如果只指定了一个变量，那么read会把所有的输入赋给该变量，直至遇到第一个文件结束符或回车。如果没有指定变量名，读取的数据将被自动赋值给特定的变量REPLY。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-a：后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。</li>
<li>-d：后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志，会举例说  明。</li>
<li>-p：后面跟提示信息，即在输入前打印提示信息。</li>
<li>-e：在输入的时候可以时候命令补全功能。</li>
<li>-n：后跟一个数字，定义输入文本的长度，很实用。</li>
<li>-r：屏蔽\，如果没有该选项，则\作为一个转义字符，有的话\就是个正常的字符了。</li>
<li>-s：安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</li>
<li>-t：后面跟秒数，定义输入字符的等待时间。</li>
<li>-u：后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2></li>
</ul>
<p><strong>实例：1. 从标准输入读取输入并赋值给变量</strong><br>描述：从标准输入读取输入并赋值给变量name。<br>命令：<code>read name</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/read/read-var.png" alt=""></p>
<p><strong>实例：2. 读入并赋给多个变量</strong><br>描述：从标准输入读取输入到第一个空格或者回车，将输入的第一个单词放到变量one中，并将该行其他的输入放在变量two中。<br>命令：<code>read one two</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/read/read-mul-var.png" alt=""></p>
<p><strong>实例：3. 未指定变量</strong><br>描述：从标准输入读取一行并赋值给特定变量REPLY。<br>命令：<code>read</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/read/read.png" alt=""></p>
<p><strong>实例：4. 读入并赋给数组</strong><br>描述：把单词清单读入myarray的数组里。<br>命令：<code>read -a myarray</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/read/read-a.png" alt=""></p>
<p><strong>实例：5. 打印提示</strong><br>描述：打印提示（text），等待输入，并将输入存储在REPLY中。<br>命令：<code>read -p &quot;text&quot;</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/read/read-a.png" alt=""></p>
<p><strong>实例：6. 允许输入包含反斜杠</strong><br>描述：允许输入包含反斜杠。<br>命令：<code>read -r line</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/read/read-r.png" alt=""></p>
<p><strong>实例：7. 等待读取</strong><br>描述：指定读取等待时间为3秒。<br>命令：<code>read -t 3</code> </p>
<p><strong>实例：8. 读取指定数量的字符</strong><br>描述：从输入中读取两个字符并存入变量var，不需要按回车读取。<br>命令：<code>read -n 2 var</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/read/read-n.png" alt=""></p>
<p><strong>实例：9. 指定结束符</strong><br>描述：用定界符“:”结束输入行。<br>命令：<code>read -d &quot;:&quot; var</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/read/read-d.png" alt=""></p>
<p><strong>实例：10. 终端输入密码不显示密码</strong><br>描述：终端输入密码不显示密码。<br>命令：<code>read -p &quot;输入密码：&quot; -s pwd</code> </p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/read/read-s.png" alt=""></p>
<p>第二种方式<br>脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/bash</span><br><span class="line">stty -echo</span><br><span class="line">read -p &quot;输入密码：&quot; pwd</span><br><span class="line">stty echo</span><br><span class="line">echo</span><br><span class="line">echo 输入完毕。</span><br></pre></td></tr></table></figure>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/read/read-no-echo.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/09/linux/daily-command-pipe/</loc>
    <lastmod>2018-06-18T12:41:56.298Z</lastmod>
    <data>
        <display>
        <title>Linux pipe总结</title>
        <pubTime>2018-06-09T11:39:41.000Z</pubTime>
      
         <content><p>管道能把一个命令的输出传递给另一个命令作为输入。管道用竖杠|表示.</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>命令1|命令2</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>管道能处理经由前面一个指令传出的正确输出信息，即standard output信息，但对于standard error信息没有直接处理能力。然后传递给下一个命令，作为标准的输入standard input，管道右边的命令必须能够接收标准输入流命令。</p>
<p>能接收标准输入的命令才可以用在管道右边，否则传递过程中数据会被抛弃。常用来接收数据管道命令有：sed，awk，cut，head，top，less，more，wc，join，sort，split等等。</p>
<h2 id="管道命令与重定向的区别"><a href="#管道命令与重定向的区别" class="headerlink" title="管道命令与重定向的区别"></a>管道命令与重定向的区别</h2><ol>
<li><p>左边的命令应该有标准输出 | 右边的命令应该接受标准输入<br>左边的命令应该有标准输出 &gt; 右边只能是文件<br>左边的命令应该需要标准输入 &lt; 右边只能是文件</p>
</li>
<li><p>管道触发两个子进程执行|两边的程序，而重定向时在一个进程内执行。</p>
</li>
</ol>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 重定向</strong><br>描述：重定向符号，右边只能是文件（普通文件，文件描述符，文件设备）。<br>命令：<code>grep -n &#39;Hello&#39; &lt; find.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/pipe/redirect-grep.png" alt=""></p>
<p><strong>实例：1. 管道</strong><br>描述：管道两边都必须是shell命令。<br>命令：<code>cat find.txt | grep -n &#39;Hello&#39;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/pipe/pipe-grep.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/13/linux/daily-command-head/</loc>
    <lastmod>2018-06-18T12:41:56.291Z</lastmod>
    <data>
        <display>
        <title>Linux head总结</title>
        <pubTime>2018-06-13T02:16:29.000Z</pubTime>
      
         <content><p>head命令用于显示来自文件或者管道开头的内容。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>head命令用于显示来自文件或者管道开头的内容。默认情况下，head命令显示文件的头10行内容。支持多文件处理，在输出每个文件之前都有一个标识文件名的标题。如果未指定文件，或者文件被指定为破折号「-」，则head命令从标准输入中读取。</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/head/head-man.png" alt=""></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>head [选项] [文件]</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul>
<li>-n, –bytes=[-]<em>num</em>：指定显示头部内容的行数；</li>
<li>-c, –lines=[-]<em>num</em>：指定显示头部内容的字节数；</li>
<li>-v, –vervose：总是显示文件名的头信息；</li>
<li>-q, –quirt, –silent：不显示文件名的头信息。</li>
<li>–help：显示一段帮助信息后退出。</li>
<li>–version：打印版本后退出。</li>
</ul>
<p>上面选项中的<em>num</em>可能有一个乘数后缀：</p>
<ul>
<li>b：512</li>
<li>kB：1000</li>
<li>K：1024</li>
<li>MB：1000*1000</li>
<li>M：1024*1024</li>
<li>GB：1000*1000*1000</li>
<li>G：1024*1024*1024</li>
</ul>
<p>还有T，P，E，Z，Y等等。</p>
<h2 id="实用示例"><a href="#实用示例" class="headerlink" title="实用示例"></a>实用示例</h2><p><strong>实例：1. 查看文件的前十行</strong><br>描述：查看words文件的前10行。默认情况下，head命令显示文件的头10行内容。<br>命令：<code>head /usr/share/dict/words</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/head/head.png" alt=""></p>
<p><strong>实例：2. 限制要显示的行数</strong><br>描述：显示words文件的前3行。-n选项限制要显示的行数。<br>命令：<br><code>head -n 3 /usr/share/dict/words</code><br><code>head -3 /usr/share/dict/words</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/head/head-n.png" alt=""></p>
<p>描述：显示words文件的前1000行。可以在num后加上后缀，例如：b，KB，K等等。<br>命令：<code>head -n 1K /usr/share/dict/words</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/head/head-n-1K.png" alt=""></p>
<p><strong>实例：3. 限制要显示的字节数</strong><br>描述：显示words文件的前16个字节。-c选项限制显示的字节数。<br>命令：<code>head -c 16 /usr/share/dict/words</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/head/head-c.png" alt=""></p>
<p><strong>实例：4. 显示多个文件</strong><br>描述：显示多个文件的前十行，同时标题会显示哪个文件正在显示。<br>命令：<code>head /usr/share/dict/words /usr/share/dict/propernames</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/head/head-multi-file.png" alt=""></p>
<p>描述：显示多个文件和标准输入的前三行，同时标题会显示哪个文件正在显示。<br>命令：<code>head -n 3 /usr/share/dict/words /usr/share/dict/propernames -</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/head/head-standard-input.png.png" alt=""></p>
<p><strong>实例：5. 多个文件不显示标题</strong><br>描述：显示多个文件的前十行，不显示正在显示文件的标题。<br>命令：<code>head -q /usr/share/dict/words /usr/share/dict/propernames</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/head/head-q.png" alt=""></p>
<p><strong>实例：6. 与管道配合使用</strong><br>描述：显示/etc/目录下的最近修改的前5个文件或文件夹。head命令可以接受其他命令通过管道传送过来的信息。<br>命令：<code>ls -t /etc/ | head -n 5</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/head/head-pipe.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/03/linux/daily-command-echo/</loc>
    <lastmod>2018-06-18T12:41:56.289Z</lastmod>
    <data>
        <display>
        <title>Linux echo总结</title>
        <pubTime>2018-06-03T08:43:46.000Z</pubTime>
      
         <content><p>echo用来在标准输出或者文件中显示一行文本或者字符串。</p>
<a id="more"></a>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>echo [选项] [字符串]</code></p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>echo命令是内建的shell命令，用于显示变量的值或者打印一行文本。当echo命令不带任何选项或字符串使用时，它会在显示屏上返回一个空白行，后面换一行跟上命令提示符。这是因为按下回车键就是发送一个信号给系统以开始一个新行，而echo重复了该信号。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><ul>
<li>-n 不要在echo命令输出后换行。</li>
<li>-e 使反斜线转义生效。</li>
<li>-E 使反斜线转义失效（默认）。</li>
</ul>
<p>如果使用-e选项，则可以使用如下转义序列：</p>
<ul>
<li>\ 反斜线</li>
<li>\a 警告（BEL）</li>
<li>\b 退格</li>
<li>\c 不产生进一步输出，不换行。</li>
<li>\e 转义</li>
<li>\f 换页</li>
<li>\n 新行</li>
<li>\r 换行字符</li>
<li>\t 水平制表</li>
<li>\v 垂直制表</li>
<li>\0NNN 八进制值表示的字节NNN（1到3个数字）</li>
<li>\xHH 十六进制值表示的字节NNN（1到2个数字）</li>
</ul>
<h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><p><strong>实例：1. 输入一行文本并显示在标准输出上</strong><br>命令：<code>echo A Linux-based system is a modular Unix-like operating system.</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo.png" alt=""></p>
<p><strong>实例：2. 输出一个声明的变量值</strong><br>命令：<code>echo The value of variable x = $x</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-variable.png" alt=""></p>
<p><strong>实例：3. 使用\b选项</strong><br>命令：<code>echo -e &quot;A \bLinux-based \bsystem \bis \ba \bmodular \bUnix-like \boperating \bsystem.&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-b.png" alt=""></p>
<p><strong>实例：4. 显示系统定义的变量的值</strong><br>命令：<code>echo $USER $HOME</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-$.png" alt=""></p>
<p><strong>实例：5. 使用\n选项</strong><br>命令：<code>echo -e &quot;A \nLinux-based \nsystem \nis \na \nmodular \nUnix-like \noperating \nsystem.&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-n.png" alt=""></p>
<p><strong>实例：6. 使用\t选项</strong><br>命令：<code>echo -e &quot;A \tLinux-based \tsystem \tis \ta \tmodular \tUnix-like \toperating \tsystem.&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-t.png" alt=""></p>
<p><strong>实例：7. 同时使用换行\n与水平制表符\t</strong><br>命令：<code>echo -e &quot;\n\tA \n\tLinux-based \n\tsystem \n\tis \n\ta \n\tmodular \n\tUnix-like \n\toperating \n\tsystem.&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-n-t.png" alt=""></p>
<p><strong>实例：8. 使用\v选项</strong><br>命令：<code>echo -e &quot;A \vLinux-based \vsystem \vis \va \vmodular \vUnix-like \voperating \vsystem.&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-v.png" alt=""></p>
<p><strong>实例：9. 同时使用换行\n与垂直制表符\v</strong><br>命令：<code>echo -e &quot;\n\vA \n\vLinux-based \n\vsystem \n\vis \n\va \n\vmodular \n\vUnix-like \n\voperating \n\vsystem.&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-n-v.png" alt=""></p>
<p><strong>实例：10. 使用\r选项</strong><br>命令：<code>echo -e &quot;A \rLinux-based system is a modular Unix-like operating system.&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-r.png" alt=""></p>
<p><strong>实例 11. 使用\c选项</strong><br>命令：<code>echo -e &quot;A Linux-based system \cis a modular Unix-like operating system.&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-c.png" alt=""></p>
<p><strong>实例：12. -n会在echo完后不会输出新行</strong><br>命令：<code>echo -n &quot;A Linux-based system is a modular Unix-like operating system.&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo--n.png" alt=""></p>
<p><strong>实例：13. 使用\a选项</strong><br>描述：-e后面跟上\a选项会听到声音警告。<br>命令：<code>echo -e &quot;A Linux-based system is a \amodular Unix-like operating system.&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-a.png" alt=""></p>
<p><strong>实例：14. 使用echo命令打印所有的文件和文件夹（ls命令的替代）</strong><br>命令：<code>echo *</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-*.png" alt=""></p>
<p><strong>实例：15. 打印制定的文件类型</strong><br>描述：打印所有的以.txt结尾的文件。<br>命令：<code>echo *.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-*-txt.png" alt=""></p>
<p><strong>实例：16. echo可以使用重定向符来输出到一个文件而不是标准输出</strong><br>命令：<code>echo &quot;A Linux-based system is a modular Unix-like operating system.&quot; &gt; linux.txt</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-redirect.png" alt=""></p>
<p><strong>实例：17. 设置echo命令彩色输出</strong><br>echo命令可以修改字体类型，字体背景色以及字体颜色，转义序列\033可以用于改变字体属性。要使转义序列生效，必须使用-e选项。下面列出了部分转义代码：</p>
<ul>
<li>[0m: 正常</li>
<li>[1m: 粗体</li>
<li>[4m: 字体加上下划线</li>
<li>[7m: 逆转前景和背景色</li>
<li>[8m: 不可见字符</li>
<li>[9m: 跨行字体</li>
<li>[30m: 灰色字体</li>
<li>[31m: 红色字体</li>
<li>[32m: 绿色字体</li>
<li>[33m: 棕色字体</li>
<li>[34m: 蓝色字体</li>
<li>[35m: 紫色字体</li>
<li>[36m: 浅蓝色字体</li>
<li>[37m: 浅灰字体</li>
<li>[38m: 黑色字体</li>
<li>[40m: 黑色背景</li>
<li>[41m: 红色背景</li>
<li>[42m: 绿色背景</li>
<li>[43m: 棕色背景</li>
<li>[44m: 蓝色背景</li>
<li>[45m: 紫色背景</li>
<li>[46m: 浅蓝色背景</li>
<li>[47m: 浅灰色背景</li>
</ul>
<p>描述：Magic of Linux变成粗体，of Linux将逆转前景和背景色，并且底色是绿色的。<br>命令：<code>echo -e &quot;\033[1mMagic \033[32m\033[7mof Linux\033[0m&quot;</code><br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-033.png" alt=""></p>
<p><strong>实例：17. 在文本中用抑音符来执行命令</strong><br>命令：echo “$LOGNAME carried them out at `date`“<br>输出：</p>
<p><img src="http://pabfn7ecx.bkt.clouddn.com/echo/echo-date.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/06/13/linux/daily-command-cut/</loc>
    <lastmod>2018-06-18T12:41:56.285Z</lastmod>
    <data>
        <display>
        <title>Linux cut总结</title>
        <pubTime>2018-06-13T00:12:02.000Z</pubTime>
      
         <content><p>cut命令用来从标准输入或文本文件中剪切列或域。</p>
<a id="more"></a>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>cut命令用来显示行中的指定部分，删除文件中指定字段。它也可以用于按字节位置、字符和分隔符来剪切部分行。也可以从CSV等文件格式中剪切数据。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p><code>cut [选项] 文件1 文件2</code></p>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- -b：仅显示行中指定直接范围的内容。</span><br><span class="line">- -c：仅显示行中指定范围的字符。</span><br><span class="line">- -d：指定字段的分隔符，默认的字段分隔符为“TAB”。</span><br><span class="line">- -f：显示指定字段的内容。</span><br><span class="line">- -n：与“-b”选项连用，不分割多字节字符。</span><br><span class="line">- --complement：补足被选择的字节、字符或字段。</span><br><span class="line">- --out-delimiter=&lt;字段分隔符&gt;：指定输出内容是的字段分割符。</span><br><span class="line">- --help：显示指令的帮助信息。</span><br><span class="line">- --version：显示指令的版本信息。</span><br></pre></td></tr></table></figure>
<h2 id="实用示例"><a href="#实用示例" class="headerlink" title="实用示例"></a>实用示例</h2><p>cut命令可以将一串字符作为列来显示：</p>
<ul>
<li>N-：从第N个字节、字符、字段到结尾。</li>
<li>N-M：从第N个字节、字符、字段到第M个（包括M在内）字节、字符、字段。</li>
<li>-M：从第1个字节、字符、字段到第M个（包括M在内）字节、字符、字段。</li>
</ul>
<p>上面是表示法，下面的选项分别表示字节、字符、字段：</p>
<ul>
<li>-b：字节</li>
<li>-c：字符</li>
<li>-f：字段</li>
</ul>
<p><strong>实例：1. 按字节位置切割</strong><br>描述：三个例子切割的分别是（1）第2个、（2）第1和第2个、（3）第2和第3个、（4）第1和第2个、（5）第1和第3个字节位置的内容。-b选项通过指定一个字节位置来切出一行的一部分。<br>命令：<br><code>echo &#39;baz&#39; | cut -b 2</code><br><code>echo &#39;baz&#39; | cut -b -2</code><br><code>echo &#39;baz&#39; | cut -b 2-</code><br><code>echo &#39;baz&#39; | cut -b 1-2</code><br><code>echo &#39;baz&#39; | cut -b 1,3</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cut/cut-b.png" alt=""></p>
<p><strong>实例：2. 按字符位置切割</strong><br>描述：两个例子切割的分别是第1个和第6个、第1至3个字符位置的内容。-c选项通过指定一个字符位置来切出一行的一部分。<br>命令：<br><code>echo &#39;♣foobar&#39; | cut -c 1,6</code><br><code>echo &#39;♣foobar&#39; | cut -c 1-4</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cut/cut-c.png" alt=""></p>
<p><strong>实例：3. 根据分隔符进行剪切</strong><br>描述：两个例子以逗号,作为分隔符进行切割，切割的分别是第1个、第1和第4个字段位置的内容。-d选项指定一个分隔符，-f选项指定选取的字段。<br>命令：<br><code>cut -d , -f 1 names.csv</code><br><code>cut -d , -f 1,4 names.csv</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cut/cut-d-f.png" alt=""></p>
<p><strong>实例：4. 提取指定字段之外的列</strong><br>描述：第一个例子选取第1个字符之外的其他字符，第二个例子选取第2个字段之外的列。–complement用于提取指定字段之外的字节、字符或列。<br>命令：<br><code>echo &#39;foo&#39; | cut --complement -c 1</code><br><code>cut -f2 -d, --complement names.csv</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cut/cut-complement.png" alt=""></p>
<p><strong>实例：5. 输出分隔符</strong><br>描述：选取第1、3、4个字段，并用空格替换分号后显示。或者使用$’\n’的形式替换为换行。<br>命令：<br><code>echo &#39;how;now;brown;cow&#39; | cut -d &#39;;&#39; -f 1,3,4 --output-delimiter &#39; &#39;</code><br><code>echo &#39;how;now;brown;cow&#39; | cut -d &#39;;&#39; -f 1,3,4 --output-delimiter $&#39;\n&#39;</code><br>输出：<br><img src="http://pabfn7ecx.bkt.clouddn.com/cut/cut-output-delimiter.png" alt=""></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/16/linux/5-ways-to-empty-or-delete-a-large-file-content-in-linux/</loc>
    <lastmod>2018-06-18T12:41:56.282Z</lastmod>
    <data>
        <display>
        <title>Linux清空文件内容最便捷的5种方法</title>
        <pubTime>2018-05-15T23:06:04.000Z</pubTime>
      
         <content><p>我们在处理 Linux 文件的时候，如果想直接清空文件的内容而不借助 Linux 命令行编辑器去打开这些文件。那怎样才能实现这个功能呢，本文就将介绍借助一些实用的命令来清空文件内容的方法。</p>
<p>值得注意的是：在 Linux 中，一切都是文件。所以必须始终确保你正在清空的文件不是重要的用户文件或系统文件。意外清空了系统文件或配置文件可能会导致严重的应用失败或系统错误。</p>
<a id="more"></a>
<blockquote>
<p>本文使用<code>access.log</code>作为示例样本。</p>
</blockquote>
<h1 id="1、-通过-shell-重定向到-null"><a href="#1、-通过-shell-重定向到-null" class="headerlink" title="1、 通过 shell 重定向到 null"></a>1、 通过 shell 重定向到 null</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> &gt; access.log</span><br></pre></td></tr></table></figure>
<h1 id="2、-使用-true-命令重定向"><a href="#2、-使用-true-命令重定向" class="headerlink" title="2、 使用 true 命令重定向"></a>2、 使用 <code>true</code> 命令重定向</h1><p><code>:</code>是一个 shell 内建的命令，等同于 <code>true</code>命令，相当于 no-op （即没有进行操作）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> : &gt; access.log</span><br><span class="line">OR</span><br><span class="line"><span class="meta">#</span> true &gt; access.log</span><br></pre></td></tr></table></figure>
<h1 id="3、-使用-cat-cp-dd-工具及-dev-null-设备来清空文件"><a href="#3、-使用-cat-cp-dd-工具及-dev-null-设备来清空文件" class="headerlink" title="3、 使用 cat/cp/dd 工具及 /dev/null 设备来清空文件"></a>3、 使用 <code>cat</code>/<code>cp</code>/<code>dd</code> 工具及 <code>/dev/null</code> 设备来清空文件</h1><p>在 Linux 中，null 设备常被用来丢弃某个进程不再需要的输出流，或者作为某个输入流的空白文件。这些通常利用重定向机制来达到。<br>因此 /dev/null 设备是一个特殊的文件，它将清空所有送到这里的输入，而它的输出则可以看作是一个空文件。<br>你可以使用 cat 命令显示 /dev/null 设备的内容然后重定向到某个文件，以达到清空某个文件的目的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cat /dev/null &gt; access.log</span><br></pre></td></tr></table></figure>
<p>另外，可以使用 cp 命令把 /dev/null 设备的内容复制到文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cp /dev/null access.log</span><br></pre></td></tr></table></figure>
<p>dd 命令主要用来转换和复制文件，下面的命令中，<code>if</code> 表示输入文件，<code>of</code> 表示输出文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> dd if=/dev/null of=access.log</span><br></pre></td></tr></table></figure>
<h1 id="4、-使用-echo-命令清空文件"><a href="#4、-使用-echo-命令清空文件" class="headerlink" title="4、 使用 echo 命令清空文件"></a>4、 使用 <code>echo</code> 命令清空文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> echo "" &gt; access.log</span><br><span class="line">OR</span><br><span class="line"><span class="meta">#</span> echo &gt; access.log</span><br></pre></td></tr></table></figure>
<p>需要注意是，空字符串并等同于 null。一个字符串是一个具体的事物，只不过它的内容是空的。而 null 则意味着这个事物不存在。<br>基于这个原因，当你将 echo命令 的输出作为输入重定向到文件后，使用 cat命令 来查看该文件的时候，你将看到一个空白行（即一个空字符串）。<br>要将 null 作为输出输入到文件中，你应该使用 -n 选项，这个选项告诉 echo命令 不再像上面那个命令一样输出结尾的那个新行。</p>
<h1 id="5、-使用-truncate-命令清空文件"><a href="#5、-使用-truncate-命令清空文件" class="headerlink" title="5、 使用 truncate 命令清空文件"></a>5、 使用 <code>truncate</code> 命令清空文件</h1><p>truncate命令 可用来 将一个文件缩小或者扩大到指定的大小。<br>可以用 <code>-s</code>/<code>-size</code> 选项来指定文件的大小</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> truncate -s 0 access.log</span><br></pre></td></tr></table></figure>
<p>以上就是几种通过简单的命令行工具和重定向机制来达到清空文件的方法。</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/04/19/design-pattern/initialization-on-demand-holder-idiom/</loc>
    <lastmod>2018-06-18T12:41:56.280Z</lastmod>
    <data>
        <display>
        <title>单例模式——双重检查</title>
        <pubTime>2018-04-19T14:52:43.000Z</pubTime>
      
         <content><p>双重检查设计模式的一个推荐版本，Initialization_on_demand_holder。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java语言规范（JLS）规定，在 Java虚拟机（JVM）内执行的初始化阶段，当 JVM 加载类 Singleton 时，类将进行初始化。在JVM没有确认 LazyHolder 必须要执行之前，静态类 LazyHolder不会被初始化。</p>
<p>静态类 LazyHolder 直到 Singleton#getInstance 静态方法被执行才会初始化，第一次的情况下，JVM 会加载并初始化LazyHolder类，所以它的内部静态字段 INSTANCE 会通过调用外部类的私有构造函数进行初始化。</p>
<p>在类的初始化阶段，JLS会保证顺序执行，也就是不会发生并发，因此这里不需要 synchronized。LazyHolder一旦顺序初始化完成一次之后，随后的所有并发调用都会返回相同的正确初始化后的 INSTANCE，不会有任何同步的开销。</p>
<p>这个模式，只有在能成功执行Singleton构造函数的前提下才能使用，一旦执行构造函数失败了，那么随后尝试初始化它的同一个类加载器就会抛出一个 NoClassDefFoundError 异常。</p>
<hr>
<p>References</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom" target="_blank" rel="noopener">IODH - wikipedia</a></li>
</ul>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/04/13/efficiency/the-best-way-to-program/</loc>
    <lastmod>2018-06-18T12:41:56.280Z</lastmod>
    <data>
        <display>
        <title>用正确的方法学习编程</title>
        <pubTime>2018-04-13T04:54:39.000Z</pubTime>
      
         <content><blockquote>
<p>人的一生，会经历从从 0 到 1，从懵懂走向明理、从稚嫩走向成熟、从依赖走向独立。在学习的道路上，也同样会经历相同的过程，如果在刚上路的时候，就知道一些准则或前人的经验，并去践行，那么就会起到事半功倍的效果。</p>
</blockquote>
<p>接下来我要介绍一些我在学习过程中总结出来的一些建议，大家参考就好。</p>
<a id="more"></a>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul>
<li><p>电脑-推荐Mac</p>
<p>  我不是果粉，个人也用过 Windows、Linux、mac OS。Windows 上面的开发工具简直难以恭维，尤其命令行超级难用，而 Linux 自己必须得话不少时间去折腾，更加不适合新手了，mac OS 是我迄今用过的最好用的系统，没有之一，如果不差钱，强烈建议入手一台，推荐 Pro 系列（苹果你的广告费啥时候打过来？）。</p>
<p>  关于更多的 Mac 小技巧，这里推荐池建强老师的《MacTalk 人生元编程》，里面有许多 Mac 的小技巧，Mac 的前世今生以及未来的发展，也不乏有对生活的探索、梳理和记录。相信你读完之后会有不一样的体会。</p>
</li>
</ul>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul>
<li><p>Google</p>
<p>  在 Google 面前，其他的搜索引擎只能甘拜下风了。俗话说，不会翻墙的程序员不是好程序员。当别人在用百度，查看国内各种二手资料的时候，我坚持使用 Google，查看国外大牛博客。在使用 Google 的时候，学会如何使用英文搜索是非常重要的，之后会整理一篇 Google 搜索技巧。</p>
</li>
<li><p>英语</p>
<p>  毫无疑问，学好英语是成为好的程序员的必经之路。我英语很差，刚开始用英语搜索资料，查看文档对我来说很难，但是我硬逼着自己，坚持下去，慢慢地就会发现，读英文文档会变得轻松起来，因为技术文档你不懂的专业词汇就那么几个，看多了自然就记住了。</p>
<p>  当然我知道，想提高英语水平远远没有那么简单，我也在不断摸索中。举个例子，我在 Mac 上装了欧陆词典（Eudic），这款软件是我用过的最好用的英语词典软件，可以自己导入原版词典库，有单词的英文解释（有些单词的中文翻译不敢恭维）。以后我会专门介绍这款软件。</p>
</li>
<li><p>IDEA</p>
<p>  很早就开始用 IDEA 了，但因为实习公司的开发环境是 Eclipse，所以就没继续用 IDEA。不过我以亲身使用者的角度告诉你，IDEA 比 Eclipse 强大。这只是一个建议，你可以去试试，对比一下。</p>
</li>
<li><p><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></p>
<p>  林纳斯（Linus） 因为对版本控制软件 BitKeeper 不太满意，所以在 2005 年花了十天时间写了一个版本控制系统 Git。想要了解林纳斯，可以去看他的自传《Just for Fun》。</p>
<p>  Git 是一个分布式源代码版本控制系统，只要用过 Git，一定无法回头用其他东西了。因为用 Git 备份源代码简单又可靠，范围是整个项目代码，不必担心测试存储库是否会影响到中间存储库。</p>
</li>
<li><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></p>
<p> GitHub 是基于 Git 的程序代码托管服务平台。它相当于是一个免费的远程仓库，也是一个开源协作社区，通过 GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p>
</li>
<li><p><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a></p>
<p> 一个程序设计领域的问答网站，技术上的问题，一般都能在这里找到答案。可以直接在 Google 中搜索<code>关键字 + site:stackoverflow.com</code>，这样查找出来的全是 stackoverflow 站内的结果，这是一个搜索小技巧。</p>
</li>
<li><p>Linux 命令</p>
<p> 电脑使用的是 Mac，平时都是在 Linux 系统下编程，因此掌握一些基本的 Linux 命令显得尤为重要。至于是买本书看，还是遇到什么 Linux 命令就打开 Google 查，都是可以的。如果你想系统地去学，我推荐《鸟哥的 Linux 私房菜》。</p>
</li>
</ul>
<h2 id="不同水平的人用不同的方法"><a href="#不同水平的人用不同的方法" class="headerlink" title="不同水平的人用不同的方法"></a>不同水平的人用不同的方法</h2><p>强烈建议新手们结合视频学习新知识，身为过来人我很清楚一开始入门很难，只是看书或者资料是难以理解的，而这时候结合视频讲解，加上自己的书籍与实战，会起到事半功倍的效果。在积累了一定经验之后，就不需要再去看视频了，因为速度太慢，一个 30 分钟长的视频，我可以看技术博客只要 10 分钟或者更短。</p>
<p>所以如果有你一定的基础，那么直接撸书籍或者技术博客吧。</p>
<h2 id="关于坚持"><a href="#关于坚持" class="headerlink" title="关于坚持"></a>关于坚持</h2><p>坚持这件事，我不能发表太多观点，因为我自己的韧性也不够强，不过也在不断磨练当中。乔布斯最喜欢的一句话叫做：</p>
<blockquote>
<p>Stay hungry, Stay foolish.</p>
</blockquote>
<p>大家在生活中一定有类似的经验，当你不知疲倦地投身于一件事时，会不自觉地去探索其相关知识，非常渴望学到这个领域的所有东西。这就是一种 <strong>Hungry</strong> 的态度，保持 <strong>Hungry</strong> 对我们来说非常可贵。</p>
<p>大家一定听过一万个小时理论，先不去论证这个理论是否有依据，但是就像池建强在 《MacTalk 人生元编程》里所说：</p>
<blockquote>
<p>优秀的程序员同样如此，菜鸟常常羡慕高手在谈笑之间让难题灰飞烟灭，而自己却苦苦思索而不得入门之法，殊不知这些高手同样经历了名将的那些腥风血雨。他们在清晨的微光里编写代码，在轰鸣的机房中调试程序，他们彻夜不眠就是为了解决一个 bug，他们要承受数据丢失或上线失败的痛苦，默默吞下眼泪，准备下一次的战斗。不停的学习、实践和思索，成千上万个小时之后，高手史成。</p>
</blockquote>
<p>这是每个刚要上路或者正在路上的侠客必须要思考的，也是必经之路。所以如果做不到每天坚持 10 个小时的代码开发，建议洗洗睡吧。很多时候你会感到枯燥，这很正常，我很多时候也会觉得枯燥，问了身边志同道合的人，大多数人都会这样，但如果想想以后的发展，这又算得了什么呢？我们现在这个年纪不去拼，难道等到三四十岁再去拼？</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这一切的一切，本质上都是为了提高自己的起点，虽然我们起步晚，但是我们起点高，慢慢的就会缩小差距，时间长了，甚至后来居上。</p>
<p>学习是一个漫长的过程，希望大家都能学有所成，我将会在自己的小站一直前行。</p>
<p>PS：下一篇介绍 Mac OS 里好用的工具。</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/04/16/efficiency/mac-tool/</loc>
    <lastmod>2018-06-18T12:41:56.279Z</lastmod>
    <data>
        <display>
        <title>如何将 Mac 变得更高效？</title>
        <pubTime>2018-04-16T15:47:29.000Z</pubTime>
      
         <content><p>时光荏苒，白驹过隙，使用 Mac 也快有一年时间了，可以毫不夸张的说，Mac OS 是我迄今为止用过的最 <strong>「好」</strong> 用的系统。用一句话来概括就是：用过 Mac 电脑之后，就真的再也回不去了。</p>
<a id="more"></a>
<p>Mac OS 是一套运行在苹果 <strong>Macintosh</strong> 系列电脑上的操作系统，基于 BSD Unix 内核的图形化操作系统，即被称作 <strong>「Unix-like」</strong> 的类 Unix 系统。</p>
<p>为什么会有 Macintosh 这个名字呢？这里有一个有趣儿的故事，在 1976 年，美国有两个叫 Steve 的孩子开了一家以水果命名的电脑公司，叫做苹果电脑公司。为什么叫苹果，据说那会儿乔布斯天天吃素，顿顿水果餐，然后就想取名叫苹果吧，还能排在电话簿的前列，多好，于是苹果公司就诞生了。</p>
<p>但是有人要问了，那跟 Macintosh 还是搭不上边啊。还请大家收好板砖，听我娓娓道来，在 Mac 在还只是一个原型的时候，它那时候叫做<strong>「安妮」</strong>。什么？「安妮」？这不是在逗我呢嘛。没错，在我看到 Mac 的这一幕历史的时候，也着实懵了。不过终于有一天，它的项目负责人拉斯金觉得这个名字太过于女性化了，于是主动更换了项目代号，用自己喜欢的一种苹果来命名，叫做<strong>麦金托什</strong>（McIntosh），但是为了避免和另一家音响设备公司重名，拉斯金对这个单词作了微调，改成了大家所熟知的「Macintosh」。</p>
<p>介绍完苹果的前世今生，接下来我就要开始介绍重点啦。俗话说，人与动物最大的区别就是，人会使用工具，而你与高手之间的最大区别就是，高手会使用高效的工具。</p>
<h3 id="Spotlight"><a href="#Spotlight" class="headerlink" title="Spotlight"></a>Spotlight</h3><p><strong>Spotlight</strong> 是 Apple 的 macOS 和 iOS 的系统级桌面搜索工具，第一次打开 Mac OS，它会创建系统中所有项目和文件的索引，这样用户就可以快速找到计算机上的各种项目，包括文档，图片，音乐，应用程序和系统偏好设置，也可以搜索网页浏览器或书签中的文档和网页中的特定词语，也有快速访问字典和计算器的功能。要是大家还不知道这个功能，赶紧试试去，快捷键 <strong>「⌘ + 空格」</strong>，你会感谢我哒。</p>
<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p><strong>Alfred</strong>，效率软件 <strong>Top#1</strong>，不解释。比 Spotlight 更加强大，想要知道更多就自己去 Google，Alfred 提供的功能很多，但目的只有一个，那就是减少我们工作中的一些重复动作，提升我们的工作效率。目前单用户售价 <strong>19</strong> 欧元，有点小贵，如果没有太多资金，后台回复<strong>「Alfred」</strong>即可。</p>
<h3 id="1Password"><a href="#1Password" class="headerlink" title="1Password"></a>1Password</h3><p>1Password，它是一款密码管理软件，它可以自动生成随机的密码，<strong>「自动填充」</strong>到页面上，只要记住后，那么下一次打开并且登录，<strong>「一键」</strong>就可以完成。嗯，是一键！我已经深深体会到它的好了，节省你非常多的时间不说，还不用去死记密码了，如果你现在用的很多社交软件都是同一个密码，甚至一些支付软件也是用的同一个密码，仔细想想是不是很害怕。具体使用请 Google 吧。1Password 是以订阅服务的方式按月收费的，每月 <strong>2.99</strong> 美元，这个数字对于学生来说，有点贵。老样子，后台回复<strong>「1Password」</strong>，送给你~</p>
<h3 id="TextExpander"><a href="#TextExpander" class="headerlink" title="TextExpander"></a>TextExpander</h3><p>TextExpander， 又是一个效率神器，只要输入几个字符，就可以自动替换成设置好的文字，无论这文字有多长，直接替换，比如在输入邮箱的时候，当你还在一个一个键敲打的时候，我已经<strong>「;yx」</strong>输入好袅。<strong>「;yx」</strong>就是自定义的一个 snippet，大家可以把常用的一些如电话，命令，甚至是密码设置为一个 snippet，我比较常用的就是各种命令，敲几下就可以执行命令，这酸爽，谁用谁知道。后台输入「TextExpander」，还是免费给你。</p>
<h3 id="Moom"><a href="#Moom" class="headerlink" title="Moom"></a>Moom</h3><p>Moom 是一款窗口管理软件，用快捷键就可以直接操作窗口，把鼠标放到左上角绿色按钮处停顿可以选择窗口停靠的位置，非常好用的软件。APP Store 里售价 <strong>68</strong> 元，大家要是很拮据的话，后台回复「Moom」收货。</p>
<h3 id="Bartender"><a href="#Bartender" class="headerlink" title="Bartender"></a>Bartender</h3><p>Bartender，随着软件越装越多，右上角的小图标也是快铺满了整条状态栏了，强迫症的人看着非常不舒服。Bartender 是一款自定义设置 Menu 状态栏图标的软件，可以把不常用的 Menu 图标收到 Bartender 的一个折叠菜单里，多亏了它，才将我那四十多个 Menu 图标精简到了十多个，看着就舒心。后台回复「Bartender」，你懂的。</p>
<h3 id="iStat-Menus"><a href="#iStat-Menus" class="headerlink" title="iStat Menus"></a>iStat Menus</h3><p>iStat Menus， 是一款在 Menu 菜单栏实时显示系统各种信息的软件，其实我只是用它来看网速，直接嵌入在状态栏这点很棒。售价 9.99 美元，如果有需要的话，我也可以提供给你。回复「iStat」即可。</p>
<h3 id="PopClip"><a href="#PopClip" class="headerlink" title="PopClip"></a>PopClip</h3><p>PopClip ，是一个功能极强的划词软件，拥有各类小插件，比如淘宝搜索，Google，翻译，Dash 搜索，地图搜索等等，这一切功能的前提就是，你轻轻的选中你想要的文字，然后 PopClip 就出现啦。这款应用售价 4.99 美元，这价格付全款也是对得起它的功能的。来吧，你懂得，回复「PopClip」。</p>
<h3 id="Manico"><a href="#Manico" class="headerlink" title="Manico"></a>Manico</h3><p>Manico， 是一款通过热键快速启动应用的软件，既可以为 Dock 上的应用配上相应的热键字母，也可自定义热键，只要按住 <strong>「option + 热键」</strong>就可以直接打开指定应用，切换速度极其流畅，节省了我许多不必要的查找软件，然后再用手指去点的时间。</p>
<p>哈哈，今天是写不完了，后台回复「Mac工具」可以获取文章中提到的所有软件。</p>
<p>有一点需要提的是，在这里提供免费的链接并不代表我个人是支持盗版的，是因为考虑到学生没有很多的经济来源。盗版肯定是不对的，程序员也是要吃饭的，我们每个人在自己的电脑上使用的每个软件都是程序员一行一行的代码敲出来的。在经济实力允许的基础上，尽可能用正版，尤其是程序员。换句话说，如果程序员不支持程序员，还怎么指望别人呢？</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/27/c/learn-to-use-gdb/</loc>
    <lastmod>2018-06-18T12:41:56.278Z</lastmod>
    <data>
        <display>
        <title>GDB 用法总结（转载）</title>
        <pubTime>2018-05-27T02:10:07.000Z</pubTime>
      
         <content><p>本文转载自：<a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch10.html" target="_blank" rel="noopener">gdb 入门</a></p>
<p>程序中除了一目了然的 Bug 之外都需要一定的调试手段来分析到底错在哪。到目前为止我们的调试手段只有一种：根据程序执行时的出错现象假设错误原因，然后在代码中适当的位置插入 printf，执行程序并分析打印结果，如果结果和预期的一样，就基本上证明了自己假设的错误原因，就可以动手修正 Bug 了，如果结果和预期的不一样，就根据结果做进一步的假设和分析。</p>
<a id="more"></a>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>本文介绍一种非常强大的调试工具 gdb，可以完全操控程序的运行，使得程序就像你手里的玩具一样，叫它走就走，叫它停就停，并且随时可以查看程序中所有的内部状态，比如各变量的值、传给函数的参数、当前执行的语句位置等。掌握了 gdb 的用法以后，调试的手段就更加丰富了。但要注意，即使调试的手段非常丰富了，其基本思想仍然是“分析现象 -&gt; 假设错误原因 -&gt; 产生新的现象去验证假设”这样一个循环，根据现象如何假设错误原因，以及如何设计新的现象去验证假设，这都需要非常严密的分析和思考，如果因为手里有了强大的工具就滥用，而忽视了严谨的思维，往往会治标不治本地修正 Bug，导致一个错误现象消失了但 Bug 仍然存在，甚至是把程序越改越错。本文根据原作者提供的几个错误实例经过删减，来讲解如何使用 gdb 调试程序，在最后总结一部分常用的 gdb 命令。</p>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install libc6-dbg gdb valgrind</span><br></pre></td></tr></table></figure>
<h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><p>查找帮助信息<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gdb -help</span><br></pre></td></tr></table></figure></p>
<p>在编译时要加上-g选项，生成的目标文件才能用gdb进行调试，生成可执行文件之后，使用 <code>gdb</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gcc -g father.c -o father</span><br><span class="line"><span class="meta">$</span> gdb fatherGNU gdb (Ubuntu 7.7-0ubuntu3.1) 7.7Copyright (C) 2014 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type "show copying"and "show warranty" for details.This GDB was configured as "x86_64-linux-gnu".(gdb)</span><br></pre></td></tr></table></figure>
<p>-g 选项的作用是在目标文件中加入源代码的信息，比如目标文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到目标文件中，所以在调试时目标文件时必须保证 gdb 也能找到源文件。gdb 提供一个类似 shell 的命令行环境，上面的 (gdb) 就是提示符，在这个提示符下输入 help 可以查看命令的类别：</p>
<h3 id="1、help-命令"><a href="#1、help-命令" class="headerlink" title="1、help 命令"></a>1、help 命令</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help<span class="symbol">List</span> of classes of commands:<span class="symbol">aliases</span> -- Aliases of other commands<span class="keyword">breakpoints </span>-- Making program stop at certain points<span class="symbol">data</span> -- Examining <span class="meta">data</span><span class="symbol">files</span> -- Specifying <span class="keyword">and </span>examining files<span class="symbol">internals</span> -- Maintenance commands<span class="symbol">obscure</span> -- Obscure features<span class="symbol">running</span> -- Running the program<span class="symbol">stack</span> -- Examining the stack<span class="symbol">status</span> -- Status inquiries<span class="symbol">support</span> -- Support facilities<span class="symbol">tracepoints</span> -- Tracing of program execution without stopping the program<span class="symbol">user</span>-defined -- User-defined commands<span class="symbol">Type</span> <span class="string">"help"</span> followed <span class="keyword">by </span>a class name for a list of commands in that class.<span class="symbol">Type</span> <span class="string">"help all"</span> for the list of all commands.<span class="symbol">Type</span> <span class="string">"help"</span> followed <span class="keyword">by </span>command name for full documentation.<span class="symbol">Type</span> <span class="string">"apropos word"</span> to search for commands related to <span class="string">"word"</span>.<span class="symbol">Command</span> name abbreviations are allowed <span class="meta">if</span> unambiguous.(gdb)</span><br></pre></td></tr></table></figure>
<p>可以进一步查看某一类别中有哪些命令，例如查看 running 类别下有哪些命令可以用：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help running<span class="symbol">Running</span> the program.<span class="symbol">List</span> of commands:<span class="symbol">advance</span> -- Continue the program up to the given location (same form as args for <span class="keyword">break </span>command)<span class="symbol">attach</span> -- Attach to a process or file outside of GDB<span class="symbol">continue</span> -- Continue program <span class="keyword">being </span>debugged<span class="symbol">detach</span> -- Detach a process or file previously attached<span class="symbol">detach</span> checkpoint -- Detach from a checkpoint (experimental)<span class="symbol">detach</span> inferiors -- Detach from inferior ID (or list of IDS)<span class="symbol">disconnect</span> -- Disconnect from a target<span class="symbol">...</span></span><br></pre></td></tr></table></figure>
<h3 id="2、list-命令"><a href="#2、list-命令" class="headerlink" title="2、list 命令"></a>2、list 命令</h3><p>用 <code>list</code> 命令从第一行开始列出源代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list <span class="number">1</span><span class="number">1</span>	int g(int x)<span class="number">2</span>	&#123;<span class="number">3</span>	    return x+<span class="number">5</span><span class="comment">;</span><span class="number">4</span>	&#125;<span class="number">5</span>	<span class="number">6</span>	int f(int x)<span class="number">7</span>	&#123;<span class="number">8</span>	    return g(x)<span class="comment">;</span><span class="number">9</span>	&#125;<span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>一次只列 10 行，如果要从 11 行开始继续列源代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list</span><br></pre></td></tr></table></figure>
<p>也可以什么都不输直接敲回车，gdb提供了一个很方便的功能，在提示符下直接敲回车表示用适当的参数重复上一条命令。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) (直接回车)</span><br><span class="line">(gdb)<span class="number">11</span>	int main(void)<span class="number">12</span>	&#123;<span class="number">13</span>	    return f(<span class="number">10</span>)+<span class="number">1</span><span class="comment">;</span><span class="number">14</span>	&#125;</span><br></pre></td></tr></table></figure>
<p>gdb 有很多常用命令有简写形式，例如 list 命令可以写成 l，要列一个函数的源代码也可以用函数名做参数：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l main<span class="number">7</span>	&#123;<span class="number">8</span>	    return g(x)<span class="comment">;</span><span class="number">9</span>	&#125;<span class="number">10</span>	<span class="number">11</span>	int main(void)<span class="number">12</span>	&#123;<span class="number">13</span>	    return f(<span class="number">10</span>)+<span class="number">1</span><span class="comment">;</span><span class="number">14</span>	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、quit-命令"><a href="#3、quit-命令" class="headerlink" title="3、quit 命令"></a>3、quit 命令</h3><p>现在退出 gdb 环境：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure>
<p>现在把源代码改名或移到别处，再用gdb调试目标文件，就列不出源代码了：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mv father.c fathe.c</span><br><span class="line">$ gdb father</span><br><span class="line">......</span><br><span class="line">(gdb) l</span><br><span class="line"><span class="number">5</span>	father.c: No such file <span class="keyword">or</span> directory.</span><br><span class="line">	<span class="keyword">in</span> fathe.c</span><br></pre></td></tr></table></figure>
<h3 id="4、start-命令"><a href="#4、start-命令" class="headerlink" title="4、start 命令"></a>4、start 命令</h3><p>可见gcc的-g选项并不是把源代码嵌入到目标文件中的，在调试目标文件时也需要源文件。现在把源代码恢复原样，我们继续调试。首先用start命令开始执行程序：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">nijun@ubuntu:</span>~/C语言程序设计$ gdb father...(gdb) startTemporary breakpoint <span class="number">1</span> <span class="meta">at</span> <span class="number">0x400517</span>: file father.c, line <span class="number">13</span>.Starting program: /home/nijun/C语言程序设计/father Temporary breakpoint <span class="number">1</span>, main () <span class="meta">at</span> father.c:<span class="number">13</span><span class="number">13</span>	    return f(<span class="number">10</span>)+<span class="number">1</span><span class="comment">;</span>(gdb)</span><br></pre></td></tr></table></figure>
<h3 id="5、next-命令-amp-step-命令"><a href="#5、next-命令-amp-step-命令" class="headerlink" title="5、next 命令 &amp; step 命令"></a>5、next 命令 &amp; step 命令</h3><p>这表示停在 main 函数中变量定义之后的第一条语句处等待我们发命令，gdb列出这条语句表示它还没执行，并且马上要执行。我们可以用 <code>next</code> 命令（简写为 <code>n</code>）控制这些语句一条一条地执行，或者用 <code>step</code> 命令（简写为<code>s</code>）：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) sf (x=<span class="number">10</span>) <span class="meta">at</span> father.c:<span class="number">8</span><span class="number">8</span>	    return g(x)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="6、backtrace-命令"><a href="#6、backtrace-命令" class="headerlink" title="6、backtrace 命令"></a>6、backtrace 命令</h3><p>它停在了函数中变量定义之后的第一条语句处。在函数中有几种查看状态的办法， <code>backtrace</code> 命令（简写为<code>bt</code>）可以查看函数调用的栈帧：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="keyword">bt</span>#<span class="number">0</span>  f (x=<span class="number">10</span>) <span class="meta">at</span> father.c:<span class="number">8</span>#<span class="number">1</span>  <span class="number">0x0000000000400521</span> <span class="keyword">in</span> main () <span class="meta">at</span> father.c:<span class="number">13</span></span><br></pre></td></tr></table></figure>
<h3 id="7、info-命令"><a href="#7、info-命令" class="headerlink" title="7、info 命令"></a>7、info 命令</h3><p>可见当前的 f 函数是被 main 函数调用的，main传进来的参数是 x=10。main函数的栈帧编号为 <code>1</code>，f 的栈帧编号为 <code>0</code> 。现在可以用 <code>info</code> 命令（简写为 <code>i</code>）查看 f 局部变量的值，但这里我们没有局部变量：）</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i localsNo locals.</span><br></pre></td></tr></table></figure>
<h3 id="8、frame-命令"><a href="#8、frame-命令" class="headerlink" title="8、frame 命令"></a>8、frame 命令</h3><p>如果想查看 main 函数当前局部变量的值也可以做到，先用 <code>frame</code> 命令（简写为 <code>f</code>）选择 <code>1</code> 号栈帧然后再查看局部变量：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) f <span class="number">1</span>#<span class="number">1</span>  <span class="number">0x0000000000400521</span> <span class="keyword">in</span> main () <span class="meta">at</span> father.c:<span class="number">13</span><span class="number">13</span>	    return f(<span class="number">10</span>)+<span class="number">1</span><span class="comment">;</span></span><br><span class="line">(gdb) i localsNo locals.</span><br></pre></td></tr></table></figure>
<h3 id="9、print-命令"><a href="#9、print-命令" class="headerlink" title="9、print 命令"></a>9、print 命令</h3><p>我们知道，未经初始化的局部变量具有不确定的值。用print命令（简写为p）打出变量参数 x 的值：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p x<span class="number">$1</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="10、display-命令"><a href="#10、display-命令" class="headerlink" title="10、display 命令"></a>10、display 命令</h3><p>用 <code>display</code> 命令使得每次停下来的时候都显示当前 x 值，用 <code>si</code> 命令执行一步汇编指令。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display x<span class="number">1</span>: x = <span class="number">10</span></span><br><span class="line">(gdb) <span class="built_in">si</span><span class="number">4</span>	&#125;<span class="number">1</span>: x = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="11、break-命令"><a href="#11、break-命令" class="headerlink" title="11、break 命令"></a>11、break 命令</h3><p>用 <code>break</code> 命令（简写为 <code>b</code>）在第9行设一个断点（Breakpoint）：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list<span class="number">1</span>	<span class="keyword">int</span> g(<span class="keyword">int</span> x)<span class="number">2</span>	&#123;<span class="number">3</span>	    return x+<span class="number">5</span><span class="comment">;</span><span class="number">4</span>	&#125;<span class="number">5</span>	<span class="number">6</span>	<span class="keyword">int</span> f(<span class="keyword">int</span> x)<span class="number">7</span>	&#123;<span class="number">8</span>	    return g(x)<span class="comment">;</span><span class="number">9</span>	&#125;<span class="number">10</span>	(gdb) b <span class="number">8</span>Breakpoint <span class="number">2</span> <span class="meta">at</span> <span class="number">0x400507</span>: file father.c, line <span class="number">8</span>.</span><br></pre></td></tr></table></figure>
<h3 id="12、continue-命令"><a href="#12、continue-命令" class="headerlink" title="12、continue 命令"></a>12、continue 命令</h3><p>break命令的参数也可以是函数名，表示在某一个函数开头设断点。现在用continue命令（简写为c）连续运行而非单步运行，程序到达断点会自动停下来，这样就可以停在下一次循环的开头：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) cContinuing.Breakpoint <span class="number">2</span>, f (x=<span class="number">10</span>) <span class="meta">at</span> father.c:<span class="number">8</span><span class="number">8</span>	    return g(x)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="13、操作-breakpoint-断点"><a href="#13、操作-breakpoint-断点" class="headerlink" title="13、操作 breakpoint 断点"></a>13、操作 breakpoint 断点</h3><p>用 <code>info breakpoints</code> 命令可以查看已经设置的断点：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpointsNum     Type           Disp Enb Address            What<span class="number">2</span>       breakpoint     keep y   <span class="number">0x0000000000400507</span> <span class="keyword">in</span> f <span class="meta">at</span> father.c:<span class="number">8</span>	breakpoint already hit <span class="number">1</span> time<span class="number">4</span>       breakpoint     keep y   <span class="number">0x0000000000400507</span> <span class="keyword">in</span> f <span class="meta">at</span> father.c:<span class="number">8</span>	breakpoint already hit <span class="number">1</span> time</span><br></pre></td></tr></table></figure>
<p>每个断点都有一个编号，可以用编号指定删除某个断点：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoints <span class="number">4</span></span><br><span class="line">(gdb) info breakpointsNum     Type           Disp Enb Address            What<span class="number">2</span>       breakpoint     keep y   <span class="number">0x0000000000400507</span> <span class="keyword">in</span> f <span class="meta">at</span> father.c:<span class="number">8</span>	breakpoint already hit <span class="number">1</span> time(gdb)</span><br></pre></td></tr></table></figure>
<p>有时候一个断点暂时不想用可以禁用掉而不必删除，这样以后想用的时候可以直接启用，而不必重新从代码里找应该在哪一行设断点：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable breakpoints <span class="number">2</span>(gdb) info breakpointsNum     Type           Disp Enb Address            What<span class="number">2</span>       breakpoint     keep n   <span class="number">0x0000000000400507</span> <span class="keyword">in</span> f <span class="meta">at</span> father.c:<span class="number">8</span>	breakpoint already hit <span class="number">1</span> time(gdb) enable breakpoints <span class="number">2</span>(gdb) info breakpointsNum     Type           Disp Enb Address            What<span class="number">2</span>       breakpoint     keep y   <span class="number">0x0000000000400507</span> <span class="keyword">in</span> f <span class="meta">at</span> father.c:<span class="number">8</span>	breakpoint already hit <span class="number">1</span> time</span><br></pre></td></tr></table></figure>
<p>gdb的断点功能非常灵活，还可以设置断点在满足某个条件时才激活，例如我们仍然在循环开头设置断点，但是仅当 x 不等于 0 时才中断，然后用 <code>run</code> 命令（简写为 <code>r</code>）重新从程序开头连续执行：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break <span class="number">8</span> if x != <span class="number">0</span><span class="symbol">Note:</span> breakpoint <span class="number">2</span> also set <span class="meta">at</span> pc <span class="number">0x400507</span>.Breakpoint <span class="number">5</span> <span class="meta">at</span> <span class="number">0x400507</span>: file father.c, line <span class="number">8</span>.</span><br></pre></td></tr></table></figure>
<h3 id="14、examine-命令"><a href="#14、examine-命令" class="headerlink" title="14、examine 命令"></a>14、examine 命令</h3><p>我们还可以用 <code>examine</code> 命令（简写是 <code>x</code>）来查看内存地址中的值，下面的命令表示从 <code>rsp</code> 寄存器里的地址值开始，向后取 16 个地址的内容，每个默认是 4 字节，<code>x</code> 表示以十六进制表示 ：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/16x $<span class="built_in">rsp</span><span class="number">0x7fffffffd9b8</span>:	<span class="number">0xffffd9d0</span>	<span class="number">0x00007fff</span>	<span class="number">0x00400511</span>	<span class="number">0x00000000</span><span class="number">0x7fffffffd9c8</span>:	<span class="number">0x00400400</span>	<span class="number">0x0000000a</span>	<span class="number">0xffffd9e0</span>	<span class="number">0x00007fff</span><span class="number">0x7fffffffd9d8</span>:	<span class="number">0x00400521</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span><span class="number">0x7fffffffd9e8</span>:	<span class="number">0xf7a35ec5</span>	<span class="number">0x00007fff</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>(gdb)</span><br></pre></td></tr></table></figure>
<h3 id="15、操作-Watchpoint-观察点"><a href="#15、操作-Watchpoint-观察点" class="headerlink" title="15、操作 Watchpoint 观察点"></a>15、操作 Watchpoint 观察点</h3><p>可以用观察点（Watchpoint）来跟踪。我们知道断点是当程序执行到某一代码行时中断，而观察点是当程序访问某一存储单元时中断，如果我们不知道某一存储单元是在哪里被改动的，这时候观察点尤其有用。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch xHardware watchpoint <span class="number">6</span>: x(gdb) info watchpointsNum     Type           Disp Enb Address            What<span class="number">6</span>       hw watchpoint  keep y                      x</span><br></pre></td></tr></table></figure>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>目前仅仅是简单地学会了 gdb 的一些基础用法，剩下更加高级的功能，等需要用到的时候再去查即可。</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令（简写）</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">backtrace（或bt）</td>
<td style="text-align:left">查看各级函数调用及参数</td>
</tr>
<tr>
<td style="text-align:left">finish</td>
<td style="text-align:left">执行到当前函数返回，然后停下来等待命令</td>
</tr>
<tr>
<td style="text-align:left">frame（或f） 帧编号</td>
<td style="text-align:left">选择栈帧</td>
</tr>
<tr>
<td style="text-align:left">info（或i） locals</td>
<td style="text-align:left">查看当前栈帧局部变量的值</td>
</tr>
<tr>
<td style="text-align:left">list（或l）</td>
<td style="text-align:left">列出源代码，接着上次的位置往下列，每次列10行</td>
</tr>
<tr>
<td style="text-align:left">list 行号</td>
<td style="text-align:left">列出从第几行开始的源代码</td>
</tr>
<tr>
<td style="text-align:left">list 函数名</td>
<td style="text-align:left">列出某个函数的源代码</td>
</tr>
<tr>
<td style="text-align:left">next（或n）</td>
<td style="text-align:left">执行下一行语句</td>
</tr>
<tr>
<td style="text-align:left">print（或p）</td>
<td style="text-align:left">打印表达式的值，通过表达式可以修改变量的值或者调用函数</td>
</tr>
<tr>
<td style="text-align:left">set var</td>
<td style="text-align:left">修改变量的值</td>
</tr>
<tr>
<td style="text-align:left">start</td>
<td style="text-align:left">开始执行程序，停在main函数第一行语句前面等待命令</td>
</tr>
<tr>
<td style="text-align:left">step（或s）</td>
<td style="text-align:left">执行下一行语句，如果有函数调用则进入到函数中</td>
</tr>
<tr>
<td style="text-align:left">break（或b） 行号</td>
<td style="text-align:left">在某一行设置断点</td>
</tr>
<tr>
<td style="text-align:left">break 函数名</td>
<td style="text-align:left">在某个函数开头设置断点</td>
</tr>
<tr>
<td style="text-align:left">break…if…</td>
<td style="text-align:left">设置条件断点</td>
</tr>
<tr>
<td style="text-align:left">continue（或c）</td>
<td style="text-align:left">从当前位置开始连续而非单步执行程序</td>
</tr>
<tr>
<td style="text-align:left">delete breakpoints</td>
<td style="text-align:left">删除断点</td>
</tr>
<tr>
<td style="text-align:left">display 变量名</td>
<td style="text-align:left">跟踪查看一个变量，每次停下来都显示它的值</td>
</tr>
<tr>
<td style="text-align:left">disable breakpoints</td>
<td style="text-align:left">禁用断点</td>
</tr>
<tr>
<td style="text-align:left">enable breakpoints</td>
<td style="text-align:left">启用断点</td>
</tr>
<tr>
<td style="text-align:left">info（或i） breakpoints</td>
<td style="text-align:left">查看当前设置了哪些断点</td>
</tr>
<tr>
<td style="text-align:left">run（或r）</td>
<td style="text-align:left">从头开始连续而非单步执行程序</td>
</tr>
<tr>
<td style="text-align:left">undisplay</td>
<td style="text-align:left">取消对先前设置的那些变量的跟踪</td>
</tr>
<tr>
<td style="text-align:left">watch</td>
<td style="text-align:left">设置观察点</td>
</tr>
<tr>
<td style="text-align:left">info（或i） watchpoints</td>
<td style="text-align:left">查看当前设置了哪些观察点</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">从某个位置开始打印存储器的一段内容，全部当成字节来看，而不区分哪些字节属于哪些变量</td>
</tr>
</tbody>
</table>
<h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch10.html" target="_blank" rel="noopener">gdb 入门</a><br><a href="http://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">gdb 手册</a></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/26/c/deep-in-c-proccess/</loc>
    <lastmod>2018-06-18T12:41:56.277Z</lastmod>
    <data>
        <display>
        <title>深入 C 语言的过程</title>
        <pubTime>2018-05-26T12:06:19.000Z</pubTime>
      
         <content><p>过程是软件中一种很重要的抽象，它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。</p>
<p>假设过程 P 调用过程 Q，Q 执行后返回到 P。那么这些动作包括下面一个或多个机制。</p>
<ul>
<li>传递控制</li>
<li>传递数据</li>
<li>分配和释放内存</li>
</ul>
<a id="more"></a>
<h2 id="一、操作数指示符"><a href="#一、操作数指示符" class="headerlink" title="一、操作数指示符"></a>一、操作数指示符</h2><p>各种不同的操作数可以分为三种类型：</p>
<ul>
<li>立即数（immediate）：例如，$3 或 $0x1F。</li>
<li>寄存器（register）：表示某个寄存器的内容，用符号 ra 表示任意寄存器 a，用引用 R[ra] 表示它的值，这将寄存器集合看成一个数组 R，用寄存器标识符作为索引。</li>
<li>内存引用是第三类操作数：它会根据计算出来的地址（有效地址）访问某个内存位置。</li>
<li>寻址模式：Imm（rb, ri, s）由一个立即数偏移Imm，一个基址寄存器 rb，一个变址寄存器 ri 和一个比例因子 s 组成，这里 s 必须是 1、2、4 或者 8。基址和变址寄存器必须是 64 位寄存器。有效地址被计算为 Imm+R[rb]+R[ri]·s。</li>
</ul>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%BC%E5%BC%8F.png" alt=""></p>
<h2 id="二、压入和弹出栈操作"><a href="#二、压入和弹出栈操作" class="headerlink" title="二、压入和弹出栈操作"></a>二、压入和弹出栈操作</h2><p>在聊压栈和弹栈操作之前，我们有必要先了解一下什么是栈？顺便把堆也一块复习了。</p>
<p><strong>(1) 相同点：</strong></p>
<ol>
<li>栈和堆都是用来从底层操作系统中获取内存的。</li>
<li>在多线程环境下每个线程都可以有他自己完全的独立的栈，但是他们共享堆。并行存取是堆来控制，而不是栈。</li>
</ol>
<p><strong>(2) 不同点：</strong><br>栈：</p>
<ol>
<li>栈是为执行线程留出的内存空间，一般提前分配好了，栈必须是连续的内存块。</li>
<li>栈是一种数据结构，可以添加或者删除值，遵循“后进先出”（LIFO）的原则；从栈中释放块（free block）只不过是指针的偏移而已。</li>
<li>每一个线程都有一个栈，但是每一个应用程序通常只有一个堆。</li>
<li>栈经常与 sp 寄存器（stack pointer）一起工作，最初 sp 指向栈顶（栈的高地址）。</li>
<li>CPU 用 push 指令来讲数据压栈，用 pop 指令来弹栈。当用 push 压栈时，sp 值减少（向低地址扩展）。当用 pop 弹栈时，sp 值增大。存储和获取的都是 CPU 寄存器的值。</li>
<li>当函数被调用时，CPU 使用特定的指令把当前的 IP（instruction pointer，指令地址寄存器，用来记录 CPU 指令的位置）压栈。即执行代码的地址。CPU 接下来把将要调用的函数地址赋给 IP，进行调用。当函数返回时，旧的 IP 被弹栈，CPU 继续去调用之前的代码。</li>
</ol>
<p>堆：</p>
<ol>
<li>堆是动态分配预留的内存空间。堆包含一个链表来维护已用和空闲的内存块。在堆上新分配（用 new 或者 malloc）内存是从空闲的内存块中找到一些满足要求的合适块。这个操作会更新堆中的块链表，元信息被存储在每个块头部的区域。</li>
<li>堆通常从低地址向高地址扩展。如果申请的堆内存很小，操作系统可能给它分配的内存为最小的堆内存单元（比申请的大）。</li>
<li>申请和释放许多小的块会产生“堆碎片”，导致申请大块内存失败。</li>
<li>当空闲块旁边的已用块释放时，新的空闲块可能会与相邻的空闲块合并为一个大的空闲块，这样可以减少“堆碎片”的产生。</li>
</ol>
<p>push 和 pop 是汇编中压栈和出栈的指令。这里引用一张图来说明：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E.png" alt=""></p>
<p>当 <code>%rsp</code> 为 <code>0x108</code>，<code>%rax</code> 为 <code>0x123</code> 时</p>
<ul>
<li><p>pushq %rax：做了两件事</p>
<ul>
<li>subq $8, %rsp：内存地址 <code>0x108</code> 向下扩展到 <code>0x100</code>。</li>
<li>movq %rax, (%rsp)：然后将 <code>0x123</code> 存放到内存地址 <code>0x100</code> 处。</li>
</ul>
</li>
<li><p>popq %rdx：做了两件事，这是弹出一个四字的操作。</p>
<ul>
<li>movq (%rsp), %rdx：从栈顶位置读出 <code>0x123</code> 赋值给 <code>%rdx</code>。</li>
<li>addq $8, %rsp：然后将栈顶指针加 <code>8</code>，变为原来的 <code>0x108</code>。</li>
</ul>
</li>
</ul>
<p>注：<code>%rax</code> 是直接寻址操作；<code>(%rsp)</code>是间接寻址操作，也就是先取出 <code>%rsp</code> 里的值作为地址，再根据这个地址到内存中找到相应的位置并取出其中的值。</p>
<h2 id="三、函数调用的栈帧结构"><a href="#三、函数调用的栈帧结构" class="headerlink" title="三、函数调用的栈帧结构"></a>三、函数调用的栈帧结构</h2><p>其实，从某种意义上说，C 语言就是个函数嵌套语言，从一个主函数开始，内部生出几个子函数，每个子函数下面又有更多的子函数，有时候父子函数之间还会出现递归嵌套调用，再加上循环和条件判断，如此复杂的操作，编辑器是怎么翻译成汇编来实现的呢？这依赖于简单实用的栈帧结构，引用《深入理解计算机系统》中的一张图：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E9%80%9A%E7%94%A8%E7%9A%84%E5%B8%A7%E6%A0%88%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>我们先不看栈里面具体的内容，我们带着几个问题去研究栈帧结构，系统中这么多的函数调用，无论函数嵌套有多复杂，肯定有个先后关系。那么这么多的栈，就是根据调用的先后排列顺序入栈，先调用的函数，其栈帧结构就整体先入栈，后调用的函数就后入栈，<strong>栈顶所代表的就是当前栈，就是当前正在调用的函数</strong>。</p>
<p>栈帧结构最难理解的就是那句 “<code>被保存的%rbp</code>”。这句话难的背后，是对 rbp 在栈帧中的作用的理解，可以这么说，只有把 %rbp 理解了，才能真正理解栈帧结构。那么 %rbp 是什么呢？<strong>%rbp 被称为基址指针寄存器（base pointer）或者帧指针（frame pointer），它保存着当前栈帧的基地址</strong>。图中函数 Q 的第一个地址——被保存的%rbp，我们要注意它（在栈中的值）这里保存的可不是函数 Q 的基地址，而是它的调用者函数 P 的基地址。这里大家可能会奇怪，为什么是函数 P 的基地址呢？后文我会讲到这个，这里大家先知道栈中的「被保存的%rbp」保存的是调用者的栈帧首地址。</p>
<p>首先看右侧以帧划分的三个部分，函数 P 要调用函数 Q，较早的帧调用函数 P，可以看出，<strong>函数的调用地址的方向从高地址向低地址扩展的</strong>。</p>
<p>我们接着来看看调用函数 P 的参数部分，参数7…参数n，为什么是从参数 7 开始呢？其实，C 语言的过程 P 调用 Q，通过寄存器，<strong>P 最多可以传送 6 个整数值（指针和整数）给 Q</strong>。假设 Q 需要的参数 n &gt; 6，那么在调用 Q 之前，P 必须在自己的栈帧里为这多出来的参数分配空间，并且分配的帧栈必须能够容纳下 7 到 n 号参数。<strong>参数的压栈顺序是从右向左的</strong>，也就是说参数 7 的地址一定比参数 n 的地址小。</p>
<p>设置好调用参数之后，开始执行 call 指令。call 指令做了两件事，</p>
<ul>
<li>第一件事是 <code>pushl %eip</code>，将返回地址（紧跟在 call 指令的下一条指令）压入栈，用于函数返回继续执行。我们把这个返回地址当做 P 的栈帧的一部分，因为它存放的是与 P 相关的状态。这步执行完后，栈指针 %esp 的值会减少一定大小，用来存放返回地址，即 <code>(%esp)</code>。无论如何，%esp 指向的地址总是在栈顶。 </li>
<li>第二件事是 <code>jmp Q</code>，跳转到函数 Q，会改变程序计数器（PC） <code>%eip</code> 寄存器的值，具体为 call 指令后面跟的地址，在这里为 Q 的第一条指令地址。</li>
</ul>
<p>接下来，进入到了函数 Q 的执行过程，首先我们看到汇编代码的最上面有两句：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushl   %ebp 		# 把父调用者的帧首地址 %ebp 入栈</span><br><span class="line">movl    %esp, %ebp  	# 更新 %ebp 为当前 Q 函数的帧首</span><br></pre></td></tr></table></figure>
<p>关键的地方来了，还记到上面提到过的<strong>栈中的「被保存的%rbp」保存的是调用者的栈帧首地址</strong>吧。根据之前复习过的 push 操作的用法：</p>
<ul>
<li>第一句 <code>pushl %ebp</code> 的意思是 %ebp 寄存器的值压入栈中，我们知道到目前为止，%ebp 的值一直是函数 P 的帧首，所以压入栈帧中的值是函数 P 的帧首。这时候 <code>%rbp</code> 指向的依旧是函数 P 的帧首。</li>
<li>第二句 <code>movl %esp, %ebp</code> 的意思是将当前栈指针寄存器 <code>%esp</code> 的地址赋值给帧指针寄存器 <code>%ebp</code>，这时候 %ebp 指向的是函数 Q 的帧首。对于函数 Q 的栈帧来说，此时栈帧顶和栈帧底指向同一位置。</li>
</ul>
<p>整理一下思路，当一个函数调用另一个函数的时候，需要对栈帧信息进行修改和维护，如何在 Q 函数执行完后让 CPU 顺利地找到 P 函数的帧首地址并成功返回呢？这就要在调用 Q 之前做好充分的准备，我们知道，P 函数有自己的帧首，在 P 函数执行的时候，%ebp 就保存了这个帧首的地址值，或者说 %ebp 指向 P 函数的帧首。当调用 Q 函数的时候，%ebp 的值会更新为 Q 的栈帧首地址，为了让 Q 在返回时能够顺利更新 %ebp 的值，使得帧指针顺利指回到 P 函数的帧首，<strong>有必要在 %ebp 指向 Q 函数（被调用函数）帧首之前，更改 Q 函数帧首空间内所保存的值，为 P 函数（调用函数）的帧首地址值，也就是 Q 栈帧中的「被保存的%rbp」的地址值</strong>。这样一来，每一个当前调用的函数都保存着父函数的帧首，函数执行完后都能顺利更新为父函数的帧首，以此类推，一直到 main 函数的帧首。通过 %ebp 的修改和被保存，就能确保栈帧结构的访问顺利进行，是不是很奇妙？</p>
<h2 id="四、一个例子"><a href="#四、一个例子" class="headerlink" title="四、一个例子"></a>四、一个例子</h2><p>下面用一个例子来说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据汇编代码画了一个图，我们先看看完整的栈结构信息图，这里假设进入 main 函数时栈顶 %rsp 的地址是 <code>0x7fffffffd9e8</code></p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B4.png" alt=""></p>
<p>使用 <code>disassemble</code> 命令显示 main 函数汇编指令代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000400513</span> &lt;main&gt;:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">400513</span>:       <span class="number">55</span>                      <span class="keyword">push</span>   %rbp</span><br><span class="line">  <span class="number">400514</span>:       <span class="number">48</span> <span class="number">89</span> e5                <span class="keyword">mov</span>    %rsp,%rbp</span><br><span class="line">    return f(<span class="number">10</span>)+<span class="number">1</span><span class="comment">;</span></span><br><span class="line">  <span class="number">400517</span>:       bf 0a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>xa,%edi</span><br><span class="line">  40051c:       e8 <span class="built_in">db</span> ff ff ff          callq  4004fc &lt;f&gt;</span><br><span class="line">  <span class="number">400521</span>:       <span class="number">83</span> c0 <span class="number">01</span>                <span class="keyword">add</span>    <span class="number">$0</span>x1,%eax</span><br><span class="line">&#125;</span><br><span class="line">  <span class="number">400524</span>:       <span class="number">5d</span>                      <span class="keyword">pop</span>    %rbp</span><br><span class="line">  <span class="number">400525</span>:       c3                      retq</span><br></pre></td></tr></table></figure>
<h3 id="（1）创建新的栈帧"><a href="#（1）创建新的栈帧" class="headerlink" title="（1）创建新的栈帧"></a>（1）创建新的栈帧</h3><p>一个函数被调用，首先默认要完成以下动作：</p>
<ul>
<li>建立新的栈帧，将调用函数的帧首地址入栈，即将 bp 寄存器的值压入调用栈中</li>
<li>将被调函数的帧首地址放入 bp 寄存器中</li>
</ul>
<p>以下两条指令即完成上面动作：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">400513</span>:       <span class="number">55</span>                      <span class="keyword">push</span>   %rbp</span><br><span class="line"><span class="number">400514</span>:       <span class="number">48</span> <span class="number">89</span> e5                <span class="keyword">mov</span>    %rsp,%rbp</span><br></pre></td></tr></table></figure>
<p>执行完之后，%rsp 将减少 8，变为 <code>0x7fffffffd9e0</code>；<code>%rbp</code> 将和 <code>%rsp</code> 一样，指向同一个地址。</p>
<p>有人要问了，不是说 main 函数是程序的入口吗，难道还会有其他函数来调 main 函数？是的，皆因 main 并不是程序拉起后第一个被执行的函数，main 函数是被 <code>_start</code> 函数拉起的，更详细的解释参看<a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch19s02.html" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="（2）准备调用函数需要的参数"><a href="#（2）准备调用函数需要的参数" class="headerlink" title="（2）准备调用函数需要的参数"></a>（2）准备调用函数需要的参数</h3><p>言归正传，一个函数调用另一个函数，需先将参数准备好。main 函数调用 f 函数，一个参数传入通用寄存器中：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">400517</span>:       bf 0a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>xa,%edi</span><br></pre></td></tr></table></figure>
<h3 id="（3）调用函数"><a href="#（3）调用函数" class="headerlink" title="（3）调用函数"></a>（3）调用函数</h3><p>万事具备，是时候将执行控制权交给 <code>f</code> 函数了，call 指令完成交接任务：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return f(<span class="number">10</span>)+<span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="number">400517</span>:       bf 0a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>xa,%edi</span><br><span class="line">40051c:       e8 <span class="built_in">db</span> ff ff ff          callq  4004fc &lt;f&gt;</span><br><span class="line"><span class="number">400521</span>:       <span class="number">83</span> c0 <span class="number">01</span>                <span class="keyword">add</span>    <span class="number">$0</span>x1,%eax</span><br></pre></td></tr></table></figure>
<p>先把 0xa 的值存入 %edi 寄存器。然后，一条 call 指令，完成了两个任务：</p>
<ul>
<li>被调函数执行完之后要返回紧跟在 call 的下一条指令继续执行，所以把 call 的下一条指令的地址（称为<code>返回地址</code>） <code>0x400521</code> 入栈，同时 <code>%rsp</code> 的值将减去 <code>8</code>，<code>%rsp</code> 的值现在是 <code>0x7fffffffd9d8</code>，如下调用栈图所示。</li>
<li>jmp f，跳转到函数 <code>f</code>，这将会改变 <code>%rip</code> 的值，变为 <code>0x4004fc</code>，即程序将跳转到该地址继续执行。</li>
</ul>
<p>用 <code>si</code> 命令执行到 call 指令之后，使用 <code>info registers</code> 指令查看寄存器 %rbp 和 %rsp 的值：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info registers <span class="built_in">rbp</span> <span class="built_in">rsp</span><span class="built_in">rbp</span>            <span class="number">0x7fffffffd9e0</span>	<span class="number">0x7fffffffd9e0</span><span class="built_in">rsp</span>            <span class="number">0x7fffffffd9d8</span>	<span class="number">0x7fffffffd9d8</span>(gdb)</span><br></pre></td></tr></table></figure>
<p>调用栈：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B 1.png" alt=""></p>
<h3 id="（4）执行控制权交接给被调函数"><a href="#（4）执行控制权交接给被调函数" class="headerlink" title="（4）执行控制权交接给被调函数"></a>（4）执行控制权交接给被调函数</h3><p>程序进入 f 函数，其汇编指令：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas /rmDump of assembler code for function f:<span class="number">7</span>	&#123;   <span class="number">0x00000000004004fc</span> &lt;+<span class="number">0</span>&gt;:	<span class="number">55</span>		<span class="keyword">push</span>   %rbp   <span class="number">0x00000000004004fd</span> &lt;+<span class="number">1</span>&gt;:	<span class="number">48</span> <span class="number">89</span> e5	<span class="keyword">mov</span>    %rsp,%rbp   <span class="number">0x0000000000400500</span> &lt;+<span class="number">4</span>&gt;:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>	<span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp   <span class="number">0x0000000000400504</span> &lt;+<span class="number">8</span>&gt;:	<span class="number">89</span> <span class="number">7d</span> fc	<span class="keyword">mov</span>    %edi,-<span class="number">0x4</span>(%rbp)<span class="number">8</span>	    return g(x)<span class="comment">;</span>=&gt; <span class="number">0x0000000000400507</span> &lt;+<span class="number">11</span>&gt;:	8b <span class="number">45</span> fc	<span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbp),%eax   <span class="number">0x000000000040050a</span> &lt;+<span class="number">14</span>&gt;:	<span class="number">89</span> c7		<span class="keyword">mov</span>    %eax,%edi   <span class="number">0x000000000040050c</span> &lt;+<span class="number">16</span>&gt;:	e8 dc ff ff ff	callq  <span class="number">0x4004ed</span> &lt;g&gt;<span class="number">9</span>	&#125;   <span class="number">0x0000000000400511</span> &lt;+<span class="number">21</span>&gt;:	c9		leaveq    <span class="number">0x0000000000400512</span> &lt;+<span class="number">22</span>&gt;:	c3		retq   End of assembler dump.(gdb)</span><br></pre></td></tr></table></figure>
<p>前面两条指令跟 main 函数里的一样：<strong>建立 f 函数的栈帧，将 main 函数的帧首地址入栈，更新 <code>%rbp</code> 为 <code>f</code> 函数的帧首地址</strong>。</p>
<p>这时的 <code>%rsp</code> 和 <code>%rbp</code> 均为 <code>0x7fffffffd9d0</code>，栈信息如图：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B2.png" alt=""></p>
<p>接下来两条指令，将 <code>%rsp</code> 减少 <code>8</code>（向下扩展 <code>8</code> 个字节），变为 <code>0x7fffffffd9c8</code>。接着， <code>%edi</code> 寄存器里的值被设置为相对于 %rbp （<code>0x7fffffffd9d0</code>）向下偏移 <code>4</code> 个字节的地址 <code>0x7fffffffd9cc</code> 。</p>
<p>继续执行 <code>si</code> 指令，让程序走完 call 指令：这个过程同 main 函数里的一样，准备调用参数，调用函数，压入返回地址。这时候寄存器 %rbp 为 <code>0x7fffffffd9d0</code>，%rsp 为 <code>0x7fffffffd9c0</code>：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">si</span>g (x=<span class="number">32767</span>) <span class="meta">at</span> father.c:<span class="number">2</span><span class="number">2</span>	&#123;(gdb) info registers <span class="built_in">rbp</span> <span class="built_in">rsp</span><span class="built_in">rbp</span>            <span class="number">0x7fffffffd9d0</span>	<span class="number">0x7fffffffd9d0</span><span class="built_in">rsp</span>            <span class="number">0x7fffffffd9c0</span>	<span class="number">0x7fffffffd9c0</span></span><br></pre></td></tr></table></figure>
<p>此时的调用栈：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B3.png" alt=""></p>
<h3 id="（5）继续调用其他函数"><a href="#（5）继续调用其他函数" class="headerlink" title="（5）继续调用其他函数"></a>（5）继续调用其他函数</h3><p>接下来调用函数 g，和调用函数 f 一样，压入紧跟在 call 函数之后的指令地址，程序跳转到函数 g 起始处。这时，<code>%rsp</code> 保存的地址值为 <code>0x7fffffffd9c0</code>。</p>
<p>函数 g 的汇编指令如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas /rmDump of assembler code for function g:<span class="number">2</span>	&#123;=&gt; <span class="number">0x00000000004004ed</span> &lt;+<span class="number">0</span>&gt;:	<span class="number">55</span>		<span class="keyword">push</span>   %rbp   <span class="number">0x00000000004004ee</span> &lt;+<span class="number">1</span>&gt;:	<span class="number">48</span> <span class="number">89</span> e5	<span class="keyword">mov</span>    %rsp,%rbp   <span class="number">0x00000000004004f1</span> &lt;+<span class="number">4</span>&gt;:	<span class="number">89</span> <span class="number">7d</span> fc	<span class="keyword">mov</span>    %edi,-<span class="number">0x4</span>(%rbp)<span class="number">3</span>	    return x+<span class="number">5</span><span class="comment">;</span>   <span class="number">0x00000000004004f4</span> &lt;+<span class="number">7</span>&gt;:	8b <span class="number">45</span> fc	<span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbp),%eax   <span class="number">0x00000000004004f7</span> &lt;+<span class="number">10</span>&gt;:	<span class="number">83</span> c0 <span class="number">05</span>	<span class="keyword">add</span>    <span class="number">$0</span>x5,%eax<span class="number">4</span>	&#125;   <span class="number">0x00000000004004fa</span> &lt;+<span class="number">13</span>&gt;:	<span class="number">5d</span>		<span class="keyword">pop</span>    %rbp   <span class="number">0x00000000004004fb</span> &lt;+<span class="number">14</span>&gt;:	c3		retq   End of assembler dump.(gdb)</span><br></pre></td></tr></table></figure>
<p>对于最前面两条指令，我们已经很熟悉了：建立 g 函数的栈帧，将 f 函数的帧首地址入栈，更新 <code>%rbp</code> 为 g 函数的帧首地址。接着一条指令把 <code>%edi</code> 寄存器里的值被设置为相对于 <code>%rbp</code> 向下偏移 <code>4</code> 个字节的地址 <code>0x7fffffffd9b4</code>。注意，这里并没有将 <code>%rsp</code> 继续向下扩展 <code>8</code> 个字节，因为 g 函数之后没有需要额外栈空间的操作了，只需做一个加法运算然后返回，这样，仅使用 <code>%rax</code> 寄存器就可以完成这个操作。因此，<code>-0x4(%rbp)</code> 这个四字节栈空间只用来临时存储一下 <code>%edi</code>里的值。编译器优化了指令.</p>
<p>接着两条指令将刚才存入到偏移位置的值存入 <code>%rax</code> 寄存器，加上 <code>0x5</code> 之后再赋值给 <code>%rax</code> 作为结果返回。</p>
<p>到目前为止，栈指针和帧指针的值指向同一位置：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i registers <span class="built_in">rbp</span> <span class="built_in">rsp</span><span class="built_in">rbp</span>            <span class="number">0x7fffffffd9b8</span>	<span class="number">0x7fffffffd9b8</span><span class="built_in">rsp</span>            <span class="number">0x7fffffffd9b8</span>	<span class="number">0x7fffffffd9b8</span>(gdb)</span><br></pre></td></tr></table></figure>
<p>调用栈：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B4.png" alt=""></p>
<p>这时，用 <code>x</code> 指令查看内存信息：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/16x $<span class="built_in">rsp</span><span class="number">0x7fffffffd9b8</span>:	<span class="number">0xffffd9d0</span>	<span class="number">0x00007fff</span>	<span class="number">0x00400511</span>	<span class="number">0x00000000</span><span class="number">0x7fffffffd9c8</span>:	<span class="number">0x00400400</span>	<span class="number">0x0000000a</span>	<span class="number">0xffffd9e0</span>	<span class="number">0x00007fff</span><span class="number">0x7fffffffd9d8</span>:	<span class="number">0x00400521</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span><span class="number">0x7fffffffd9e8</span>:	<span class="number">0xf7a35ec5</span>	<span class="number">0x00007fff</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>(gdb)</span><br></pre></td></tr></table></figure>
<p>以上显示的 16 个 4 bytes 内存地址指示的值，以十六进制显示。比较下，是否和上面的调用栈信息一致？</p>
<h3 id="函数返回过程"><a href="#函数返回过程" class="headerlink" title="函数返回过程"></a>函数返回过程</h3><p>函数调用对应着调用栈的建立，而函数返回则是进行调用栈的销毁，返回比调用过程简单多了。继续上面 g 函数的执行，g 函数还剩两条语句：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000000004004fa</span> &lt;+<span class="number">13</span>&gt;:	<span class="number">5d</span>		<span class="keyword">pop</span>    %rbp<span class="number">0x00000000004004fb</span> &lt;+<span class="number">14</span>&gt;:	c3		retq</span><br></pre></td></tr></table></figure>
<p>可以看出，g 函数的返回过程中，第一条指令 <code>pop %rbp</code> 先把当前栈顶 <code>%rsp</code> 的值出栈并赋给 <code>%rbp</code>，这时候栈顶指针指向的是 f 函数的栈帧顶 <code>0x7fffffffd9c0</code>，里面存的就是继续执行 f 函数接下来执行语句的地址 <code>0x400511</code>。 </p>
<p>第二条指令 <code>retq</code>，它是 <code>call</code> 指令的逆操作，它将改变 ip 寄存器的值，值就是当前 <code>%rsp</code> 里存的值 <code>0x400511</code>，同时将 %rsp 的值加 8。</p>
<p>两条指令执行完之后的调用栈：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Chapter%203/%E6%A0%88%E5%B8%A7g%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E.png" alt=""></p>
<p>这时候程序就已经从 g 函数中返回，返回到 f 函数继续执行了。接下来的返回流程就比较类似了，不过注意到 f 函数有一个 <code>leave</code> 指令，那么这个指令有什么作用呢？</p>
<p><code>leave</code> 指令相当于是每个函数开头两条指令的逆操作，等价于以下两条指令：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span> %rbp, %rsp</span><br><span class="line">popq %rbp</span><br></pre></td></tr></table></figure>
<p>这两条指令将 bp 和 sp 寄存器中的值还原为函数调用前的值。接着就是 ret 指令，与 g 函数过程一样的，就不再赘述了。然后返回到 main 函数，main 函数再返回，调用栈被销毁。</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>由于 C 语言学艺不精，欲从基础学起，查资料，看书，看博客，从计算机底层基础学起，逐步了解 C 语言，学习 gdb 单步调试和反汇编工具，梳理了对函数调用的底层实现过程。</p>
<p>1、%rsp 保存的是栈顶的地址，栈顶所代表的就是当前栈，就是当前正在调用的函数。<br>2、%rbp 被称为基址指针寄存器（base pointer）或者帧指针（frame pointer），它保存着当前栈帧的基地址。<br>3、%rip 被称为指令地址寄存器(instruction pointer)，用来记录 CPU 指令的位置。每次 CPU 执行都要先读取 %rip 寄存器的值，然后定位到 %rip 指向的内存地址，并且读取汇编指令，最后执行。读完之后，相应的 %rip 寄存器的值就会增加，增加大小就是读取指令的字节大小。<br>3、函数的调用地址的方向从高地址向低地址扩展的。<br>4、函数调用最多可以传送 6 个整数值（指针和整数）。<br>5、函数调用前如果需要传递参数，参数的压栈顺序是从右向左的。<br>6、栈中的「被保存的%rbp」保存的是调用者的栈帧首地址。<br>7、圧栈和出栈、call、leave、ret等指令完成的实际工作。<br>8、gdb 工具的学习使用。<br>9、函数的调用与返回过程。</p>
<p>栈这种简单的数据结构优雅地完成了支撑计算机程序执行的任务。引用自<a href="http://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html#%E5%B0%8F%E7%BB%93" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="http://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html#%E5%B0%8F%E7%BB%93" target="_blank" rel="noopener">函数调用过程探究</a><br><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch19s01.html" target="_blank" rel="noopener">函数调用</a><br><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch19s02.html" target="_blank" rel="noopener">main函数和启动例程</a><br><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch10.html" target="_blank" rel="noopener">gdb 使用</a><br><a href="https://blog.csdn.net/xungjhj/article/details/70946057" target="_blank" rel="noopener">栈指针和帧指针</a><br><a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">call stack</a><br><a href="https://blog.csdn.net/djbtestingsky/article/details/1884678" target="_blank" rel="noopener">堆栈中的EIP EBP ESP</a><br><a href="http://www.pchou.info/c-cpp/2015/03/03/c-and-asm.html" target="_blank" rel="noopener">一段C语言和汇编的对应分析，揭示函数调用的本质</a></p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/04/android/service-is-a-context/</loc>
    <lastmod>2018-06-18T12:41:56.276Z</lastmod>
    <data>
        <display>
        <title>android 服务记录</title>
        <pubTime>2018-05-04T08:16:18.000Z</pubTime>
      
         <content><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>1、主线程。不能做耗时操作。</p>
<p>2、开启服务两种方式，一种是startService，另一种是bindService。<br>startService开启服务后，服务会一直在后台运行，即使Activity退出也不会停止。<br>bindService与Activity绑定后，可以与Activity进行数据交互，如果不在同一进程中，可以使用进程间通信。（IPC）</p>
<a id="more"></a>
<p>3、 如果一定要做耗时操作，那么就在 Service 里开启一个子线程去做耗时操作。<br>因为Activity的生命可见性比Service短。Activity被销毁了，Service可以继续存活，所以可以继续保持对子线程的引用。</p>
<p>4、onStartCommand会在每次调用startService时执行一次，而onCreate则只会执行一次。<br>多次开启服务，只要调用过一次stopService或者stopSelf就可以停止服务。</p>
<p>5、特别的，启动服务一定要是explicit Intent。</p>
<p>6、使用Messenger发送消息最好是在点击事件里，在生命周期方法中调用可能出现没有发送成功的问题。</p>
<h3 id="绑定服务"><a href="#绑定服务" class="headerlink" title="绑定服务"></a>绑定服务</h3><p>1、多个客户端可以同时绑定同一个服务，但只能绑定一次。系统只会在第一个客户来绑定的时候调用onBind()方法去生成IBinder对象，系统将会分发这个相同的IBinder对象去给其他来绑定这个服务的客户端，只调用onBind()方法。<br>如果重写了onStartCommand方法，也就是说 Service 被 started 和 bound 之后，当所有客户端被unBind之后，也不会销毁服务，我们要明确地调用StopService()和StopSelf()，一旦调用这两个方法，那么即使还有客户端连接着也会被断开。</p>
<p>因此started和bound可以阻止系统销毁Service。</p>
<p>2、Android中绑定服务有几种方式。</p>
<p>AIDL和Messenger。 Messenger方式，在同一时刻只有一个消息可以得到执行。Messenger其实就是一个Handler，</p>
<p>AIDL用在不同的应用中，而且可以同时执行多个消息。</p>
<p>注意： 只有Activity、Service、 Content Provider 可以绑定服务，Broadcast Receiver是不能绑定服务的。</p>
<p>3、音乐播放器就是一个既使用started又使用bound的例子。</p>
<p>4、如果想要在Activity可见的时候与Service进行交互，一般在onStart里绑定服务，在 onStop 里停止服务。<br>尽量不要在onResume和onPause里进行绑定和解绑服务。</p>
<p>注意：如果重写了onStartCommand方法，就相当于被 started 和 bound了。</p>
<p>5、在Android 5.0 之后，如果使用implicit Intent来bindService会抛出异常。所以不要为你的service声明Intent filter，不要使用implicit intent。</p>
<p>References：</p>
<ul>
<li><a href="http://www.truiton.com/2015/01/android-bind-service-using-messenger/" target="_blank" rel="noopener">http://www.truiton.com/2015/01/android-bind-service-using-messenger/</a></li>
<li><a href="https://developer.android.com/guide/components/bound-services.html#Additional_Notes" target="_blank" rel="noopener">https://developer.android.com/guide/components/bound-services.html#Additional_Notes</a></li>
</ul>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/27/css/css-selectors/</loc>
    <lastmod>2018-06-18T12:41:56.276Z</lastmod>
    <data>
        <display>
        <title>CSS 选择器总结</title>
        <pubTime>2018-05-27T08:07:43.000Z</pubTime>
      
         <content><p>前几天在整理博客（Hexo）的时候，发现一个页面样式奇丑无比，都不知道当时是怎么想的，好在页面可以自定义样式。说干就干，但过程当前恰好暴露了我知识上的缺陷，虽说 CSS 很早老师就教过了，但是一直没学明白，本文的总结正好复习一下 CSS 选择器。</p>
<a id="more"></a>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="noopener">阮一峰 CSS选择器笔记</a><br><a href="https://www.w3schools.com/cssref/css_selectors.asp" target="_blank" rel="noopener">w3schools</a><br><a href="http://www.456bereastreet.com/archive/200509/css_21_selectors_part_1/" target="_blank" rel="noopener">456 Berea Street</a></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>后代（descendant）<br>  元素是文档树中元素的子元素，孙元素或后面的后代。</li>
<li>祖先（ancestor）<br>  元素是文档树中父元素，祖父元素或更早元素的祖先。</li>
<li>孩子（child）<br>  元素的直接后代。在文档树中两者之间不会有其他元素。</li>
<li>父亲（parent）<br>  元素的直接祖先。在文档树中两者之间不会有其他元素。</li>
<li>兄弟（sibling）<br>  与当前元素具有相同父元素的元素。</li>
</ul>
<h3 id="一、基本选择器"><a href="#一、基本选择器" class="headerlink" title="一、基本选择器"></a>一、基本选择器</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_all.asp" target="_blank" rel="noopener">*</a></td>
<td style="text-align:left">*</td>
<td style="text-align:left">通用元素选择器，选择所有元素</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_element.asp" target="_blank" rel="noopener">element</a></td>
<td style="text-align:left">p</td>
<td style="text-align:left">元素、类型选择器，选择所有 <code>&lt;p&gt;</code> 元素。</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_class.asp" target="_blank" rel="noopener">.class</a></td>
<td style="text-align:left">.intro</td>
<td style="text-align:left">类选择器，选择 class=<code>&quot;intro&quot;</code> 的所有元素</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_id.asp" target="_blank" rel="noopener">#id</a></td>
<td style="text-align:left">#firstname</td>
<td style="text-align:left">选择 id=<code>&quot;firstname&quot;</code> 的所有元素</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* &#123; <span class="attribute">background</span>: red &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">color</span>:gray; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.important</span> &#123; <span class="attribute">color</span>:red; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.important</span> &#123; <span class="attribute">color</span>:red; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.important</span><span class="selector-class">.warning</span> &#123; <span class="attribute">background</span>:silver; &#125;</span><br><span class="line"></span><br><span class="line">*<span class="selector-id">#intro</span> &#123; <span class="attribute">font-weight</span>:bold; &#125;</span><br></pre></td></tr></table></figure>
<p>ID 选择器与类选择器的区别：<br>区别 1：只能在文档中使用一次<br>区别 2：ID 属性不允许有以空格分隔的词列表。<br>区别 3：ID 能包含更多含义.</p>
<h3 id="二、多元素的组合选择器"><a href="#二、多元素的组合选择器" class="headerlink" title="二、多元素的组合选择器"></a>二、多元素的组合选择器</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_element_comma.asp" target="_blank" rel="noopener">element, element</a></td>
<td style="text-align:left">div, p</td>
<td style="text-align:left">选择所有 <code>&lt;div&gt;</code> 元素和所有 <code>&lt;p&gt;</code> 元素。</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_element_element.asp" target="_blank" rel="noopener">element element</a></td>
<td style="text-align:left">div p</td>
<td style="text-align:left">选择 <code>&lt;div&gt;</code> 元素内部的所有 <code>&lt;p&gt;</code> 元素。</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_element_gt.asp" target="_blank" rel="noopener">element &gt; element</a></td>
<td style="text-align:left">div &gt; p</td>
<td style="text-align:left">选择父元素为 <code>&lt;div&gt;</code> 元素的所有 <code>&lt;p&gt;</code> 元素。</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_element_plus.asp" target="_blank" rel="noopener">element + element</a></td>
<td style="text-align:left">div + p</td>
<td style="text-align:left">选择紧接在 <code>&lt;div&gt;</code> 元素之后的所有 <code>&lt;p&gt;</code> 元素。</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
<p>实例</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> <span class="selector-tag">em</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">strong</span> &#123; <span class="attribute">color</span>:<span class="number">#ff0000</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> + <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、CSS-2-1-属性选择器"><a href="#三、CSS-2-1-属性选择器" class="headerlink" title="三、CSS 2.1 属性选择器"></a>三、CSS 2.1 属性选择器</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_attribute.asp" target="_blank" rel="noopener">E[att]</a></td>
<td style="text-align:left">[target]</td>
<td style="text-align:left">选择带有 <code>target</code> 属性所有元素。</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_attribute_value.asp" target="_blank" rel="noopener">E[att=val]</a></td>
<td style="text-align:left">[target=_blank]</td>
<td style="text-align:left">选择 target=<code>&quot;_blank&quot;</code> 的所有元素。</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_attribute_value_contain.asp" target="_blank" rel="noopener">E[att~=val]</a></td>
<td style="text-align:left">[title~=flower]</td>
<td style="text-align:left">选择 title 属性包含单词 <code>&quot;flower&quot;</code> 的所有元素。</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_attribute_value_start.asp" target="_blank" rel="noopener">E[att&#124;=val]</a></td>
<td style="text-align:left">[lang&#124;=en]</td>
<td style="text-align:left">特定属性选择器，匹配所有 <code>lang</code> 属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以 val 开头的 E 元素，主要用于 lang 属性，比如 “en”、”en-us”、”en-gb” 等等</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
<p>实例</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-attr">[title]</span> &#123; <span class="attribute">color</span>:red; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span> &#123; <span class="attribute">color</span>:red; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span><span class="selector-attr">[title]</span> &#123; <span class="attribute">color</span>:red; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">planet</span><span class="selector-attr">[moons="1"]</span> &#123; <span class="attribute">color</span>: red; &#125;  </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://www.w3school.com.cn/"]</span><span class="selector-attr">[title="W3School"]</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class="important warning"]</span> &#123; <span class="attribute">color</span>: red; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class~="important"]</span> &#123; <span class="attribute">color</span>: red; &#125; </span><br><span class="line"></span><br><span class="line">*<span class="selector-attr">[lang|="en"]</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>部分值属性选择器与点号类名记法的区别：<br>p.important 和 p[class=”important”] 应用到 HTML 文档时是等价的。</p>
</blockquote>
<h3 id="四、CSS-2-1-中的伪类"><a href="#四、CSS-2-1-中的伪类" class="headerlink" title="四、CSS 2.1 中的伪类"></a>四、CSS 2.1 中的伪类</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_link.asp" target="_blank" rel="noopener">:link</a></td>
<td style="text-align:left">a:link</td>
<td style="text-align:left">选择所有未被访问的链接。</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_visited.asp" target="_blank" rel="noopener">:visited</a></td>
<td style="text-align:left">a:visited</td>
<td style="text-align:left">选择所有已被访问的链接。</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_active.asp" target="_blank" rel="noopener">:active</a></td>
<td style="text-align:left">a:active</td>
<td style="text-align:left">选择活动链接。</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_hover.asp" target="_blank" rel="noopener">:hover</a></td>
<td style="text-align:left">a:hover</td>
<td style="text-align:left">选择鼠标指针位于其上的链接。</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_focus.asp" target="_blank" rel="noopener">:focus</a></td>
<td style="text-align:left">input:focus</td>
<td style="text-align:left">选择获得焦点的 input 元素。</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_lang.asp" target="_blank" rel="noopener">:lang(language)</a></td>
<td style="text-align:left">p:lang(it)</td>
<td style="text-align:left">选择带有以 <code>&quot;it&quot;</code> 开头的 lang 属性值的每个 <code>&lt;p&gt;</code> 元素。</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_first-child.asp" target="_blank" rel="noopener">:first-child</a></td>
<td style="text-align:left">p:first-child</td>
<td style="text-align:left">选择属于父元素的第一个子元素的每个 <code>&lt;p&gt;</code> 元素。</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
<p>实例<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: red; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> &#123; <span class="attribute">font-weight</span>: bold; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123; <span class="attribute">color</span>:yellow; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">background</span>:<span class="number">#fff</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">:lang(no)</span> &#123; <span class="attribute">quotes</span>: <span class="string">"~"</span> <span class="string">"~"</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="五、CSS-2-1-中的伪元素"><a href="#五、CSS-2-1-中的伪元素" class="headerlink" title="五、CSS 2.1 中的伪元素"></a>五、CSS 2.1 中的伪元素</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_first-letter.asp" target="_blank" rel="noopener">:first-letter</a></td>
<td style="text-align:left">p:first-letter</td>
<td style="text-align:left">选择每个 <code>&lt;p&gt;</code> 元素的首字母。</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_first-line.asp" target="_blank" rel="noopener">:first-line</a></td>
<td style="text-align:left">p:first-line</td>
<td style="text-align:left">选择每个 <code>&lt;p&gt;</code> 元素的首行。</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_before.asp" target="_blank" rel="noopener">:before</a></td>
<td style="text-align:left">p:before</td>
<td style="text-align:left">在每个 <code>&lt;p&gt;</code> 元素的内容之前插入内容。</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_after.asp" target="_blank" rel="noopener">:after</a></td>
<td style="text-align:left">p:after</td>
<td style="text-align:left">在每个 <code>&lt;p&gt;</code> 元素的内容之后插入内容。</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
<p>实例<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-letter</span> &#123; <span class="attribute">font-size</span>:<span class="number">200%</span>; <span class="attribute">color</span>:<span class="number">#8A2BE2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-line</span> &#123; <span class="attribute">background-color</span>:yellow; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span> &#123; <span class="attribute">content</span>:<span class="string">""</span>; <span class="attribute">background</span>:<span class="built_in">url</span>(top.png) no-repeat <span class="number">0</span> <span class="number">0</span>; <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">18px</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span><span class="selector-pseudo">:after</span> &#123; <span class="attribute">content</span>: <span class="string">" ("</span> <span class="built_in">attr</span>(href) <span class="string">") "</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="六、CSS-3-的同级元素通用选择器"><a href="#六、CSS-3-的同级元素通用选择器" class="headerlink" title="六、CSS 3 的同级元素通用选择器"></a>六、CSS 3 的同级元素通用选择器</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_gen_sibling.asp" target="_blank" rel="noopener">element1 ~ element2</a></td>
<td style="text-align:left">p ~ ul</td>
<td style="text-align:left">选择父元素是 <code>&lt;p&gt;</code> 元素之后的每个 <code>&lt;ul&gt;</code> 元素。</td>
<td style="text-align:left">3</td>
</tr>
</tbody>
</table>
<p>实例</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> ~ <span class="selector-tag">ul</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0</span>; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、CSS-3-属性选择器"><a href="#七、CSS-3-属性选择器" class="headerlink" title="七、CSS 3 属性选择器"></a>七、CSS 3 属性选择器</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_attr_begin.asp" target="_blank" rel="noopener">[attribute^=value]</a></td>
<td style="text-align:left">a[src^=<code>&quot;https&quot;</code>]</td>
<td style="text-align:left">选择其 src 属性值以 <code>&quot;https&quot;</code> 开头的每个 <code>&lt;a&gt;</code> 元素。</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_attr_end.asp" target="_blank" rel="noopener">[attribute$=value]</a></td>
<td style="text-align:left">a[src$=<code>&quot;.pdf&quot;</code>]</td>
<td style="text-align:left">选择其 src 属性以 <code>&quot;.pdf&quot;</code> 结尾的所有 <code>&lt;a&gt;</code> 元素。</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_attr_contain.asp" target="_blank" rel="noopener">[attribute*=value]</a></td>
<td style="text-align:left">a[src*=<code>&quot;abc&quot;</code>]</td>
<td style="text-align:left">选择其 src 属性中包含 <code>&quot;abc&quot;</code> 子串的每个 <code>&lt;a&gt;</code> 元素。</td>
<td style="text-align:left">3</td>
</tr>
</tbody>
</table>
<p>实例</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*="w3school.com.cn"]</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="八、CSS-3-中与用户界面有关的伪类"><a href="#八、CSS-3-中与用户界面有关的伪类" class="headerlink" title="八、CSS 3 中与用户界面有关的伪类"></a>八、CSS 3 中与用户界面有关的伪类</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_enabled.asp" target="_blank" rel="noopener">:enabled</a></td>
<td style="text-align:left">input:enabled</td>
<td style="text-align:left">选择每个启用的 <code>&lt;input&gt;</code> 元素。</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_disabled.asp" target="_blank" rel="noopener">:disabled</a></td>
<td style="text-align:left">input:disabled</td>
<td style="text-align:left">选择每个禁用的 <code>&lt;input&gt;</code> 元素</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_checked.asp" target="_blank" rel="noopener">:checked</a></td>
<td style="text-align:left">input:checked</td>
<td style="text-align:left">选择每个被选中的 <code>&lt;input&gt;</code> 元素。</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_selection.asp" target="_blank" rel="noopener">::selection</a></td>
<td style="text-align:left">::selection</td>
<td style="text-align:left">选择被用户选取的元素部分。</td>
<td style="text-align:left">3</td>
</tr>
</tbody>
</table>
<h3 id="九、CSS-3-中的结构性伪类"><a href="#九、CSS-3-中的结构性伪类" class="headerlink" title="九、CSS 3 中的结构性伪类"></a>九、CSS 3 中的结构性伪类</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_root.asp" target="_blank" rel="noopener">:root</a></td>
<td style="text-align:left">:root</td>
<td style="text-align:left">选择文档的根元素。</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_nth-child.asp" target="_blank" rel="noopener">:nth-child(n)</a></td>
<td style="text-align:left">p:nth-child(2)</td>
<td style="text-align:left">选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_nth-last-child.asp" target="_blank" rel="noopener">:nth-last-child(n)</a></td>
<td style="text-align:left">p:nth-last-child(2)</td>
<td style="text-align:left">同上，从最后一个子元素开始计数。</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_nth-of-type.asp" target="_blank" rel="noopener">:nth-of-type(n)</a></td>
<td style="text-align:left">p:nth-of-type(2)</td>
<td style="text-align:left">选择属于其父元素第二个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_nth-last-of-type.asp" target="_blank" rel="noopener">:nth-last-of-type(n)</a></td>
<td style="text-align:left">p:nth-last-of-type(2)</td>
<td style="text-align:left">同上，但是从最后一个子元素开始计数。</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_last-child.asp" target="_blank" rel="noopener">:last-child</a></td>
<td style="text-align:left">p:last-child</td>
<td style="text-align:left">选择属于其父元素最后一个子元素的每个 <code>&lt;p&gt;</code> 元素。</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_first-of-type.asp" target="_blank" rel="noopener">:first-of-type</a></td>
<td style="text-align:left">p:first-of-type</td>
<td style="text-align:left">选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。等同于 <code>:nth-of-type(1)</code></td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_last-of-type.asp" target="_blank" rel="noopener">:last-of-type</a></td>
<td style="text-align:left">p:last-of-type</td>
<td style="text-align:left">选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。等同于 <code>:nth-last-of-type(1)</code></td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_only-of-type.asp" target="_blank" rel="noopener">:only-of-type</a></td>
<td style="text-align:left">p:only-of-type</td>
<td style="text-align:left">选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。等同于 <code>:first-child:last-child</code>、<code>:nth-child(1):nth-last-child(1)</code></td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_only-child.asp" target="_blank" rel="noopener">:only-child</a></td>
<td style="text-align:left">p:only-child</td>
<td style="text-align:left">选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。等同于 <code>:first-of-type:last-of-type</code>、<code>:first-of-type(1):last-of-type(1)</code></td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_empty.asp" target="_blank" rel="noopener">:empty</a></td>
<td style="text-align:left">p:empty</td>
<td style="text-align:left">选择没有子元素的每个 <code>&lt;p&gt;</code> 元素（文本节点也被看作子元素）。</td>
<td style="text-align:left">3</td>
</tr>
</tbody>
</table>
<p>实例</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0000</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:empty</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0000</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-of-type</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0000</span>; &#125;  </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0000</span>; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:only-of-type</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0000</span>; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:only-child</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0000</span>; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(3)</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0000</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(odd)</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0000</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(even)</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0000</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-last-child(3n+0)</span> &#123; <span class="attribute">background</span>:<span class="number">#ff0000</span>; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="十、CSS-3的反选伪类"><a href="#十、CSS-3的反选伪类" class="headerlink" title="十、CSS 3的反选伪类"></a>十、CSS 3的反选伪类</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_not.asp" target="_blank" rel="noopener">:not(selector)</a></td>
<td style="text-align:left">:not(p)</td>
<td style="text-align:left">选择非 <code>&lt;p&gt;</code> 元素的每个元素。</td>
<td style="text-align:left">3</td>
</tr>
</tbody>
</table>
<p>实例</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:not(p)</span> &#123; <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ccc</span>; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="十一、CSS-3-中的-target-伪类"><a href="#十一、CSS-3-中的-target-伪类" class="headerlink" title="十一、CSS 3 中的 :target 伪类"></a>十一、CSS 3 中的 :target 伪类</h3><table>
<thead>
<tr>
<th style="text-align:left">选择器</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">CSS 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.w3school.com.cn/cssref/selector_target.asp" target="_blank" rel="noopener">:target</a></td>
<td style="text-align:left">#news:target</td>
<td style="text-align:left">选择当前活动（点击）的 #news 元素。</td>
<td style="text-align:left">3</td>
</tr>
</tbody>
</table>
<p>实例</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:target</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#D4D4D4</span>; <span class="attribute">background-color</span>: <span class="number">#e5eecc</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>（完）</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/15/algorithm/quick-sort/</loc>
    <lastmod>2018-06-18T12:41:56.275Z</lastmod>
    <data>
        <display>
        <title>深入浅出之快速排序</title>
        <pubTime>2018-05-15T09:40:02.000Z</pubTime>
      
         <content><p>快速排序是图灵奖得主 <strong>C.R.A. Hoare</strong> 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为<strong>分治法(Divide-and-ConquerMethod)</strong>。</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/QuickSort/Tony_Hoare.jpg" alt=""></p>
<p>在计算机科学中，分而治之是基于多分支递归的算法设计范式。分治法算法通过递归地将问题分解成相同或相关类型的两个或更多个子问题，直到这些问题变得足够简单以直接解决。然后将子问题的解决方案结合起来，解决原始问题。</p>
<h1 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h1><hr>
<p>快速排序算法是一种基于交换的高效的排序算法，但它不是一个稳定的算法，意味着相关元素的顺序在排序后不被保留。它是一个原地排序算法，只需要额外很小的的内存空间。它和选择排序非常像，但它不会总选择最坏的分区。它采用了分治法的思想：<strong>将一个数组分成两个子数组，将两部分独立地排序。</strong> </p>
<p><img src="http://p748dqat4.bkt.clouddn.com/QuickSort/QuickSort%20Overview.png" alt=""></p>
<a id="more"></a>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    StdRandom.shuffle(a); <span class="comment">// 消除对输入的依赖</span></span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = partition(a, lo, hi); <span class="comment">// 处理数组，找到切分位置</span></span><br><span class="line">    sort(a, lo, j-<span class="number">1</span>); </span><br><span class="line">    sort(a, j+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排序轨迹图</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/QuickSort/QuickSort.png" alt=""></p>
<h1 id="如何切分"><a href="#如何切分" class="headerlink" title="如何切分"></a>如何切分</h1><hr>
<ol>
<li>随意取 a[lo] 作为切分元素，即那个会被排定的元素。</li>
<li>然后从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素没有被排定，因此交换它们的位置。</li>
<li>如此继续，我们就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。</li>
<li>当两个指针相遇时，我们只需要将切分元素 a[lo] 和<strong>左数组最右侧的元素 a[j]</strong> 交换然后返回 j 即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到切分位置，将 lo 位置的元素放到切分位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[lo]; <span class="comment">// 切分元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v)) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>; <span class="comment">// 如果一直没有找到比切分元素大的，那么 i 的自增就会因为等于 hi 而停止，就会退出最外层的循环，不进行交换元素。</span></span><br><span class="line">        <span class="keyword">while</span> (less(v, a[--j])) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>; <span class="comment">// j == lo </span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(a, lo, j); <span class="comment">// 将 lo 位置的元素放到切分位置</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准切分轨迹图</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/QuickSort/Partitioning%20trace.png" alt=""></p>
<p>需要注意的几个点：</p>
<ol>
<li>原地切分，如果使用辅助数组，是很容易实现切分的，但将切分后的数组复制回去的开销也许会得不偿失。</li>
<li>如果切分元素是数组中最小或者最大的元素，我们要小心不要让指针跑出数组的边界。</li>
<li>保持随机性</li>
<li>终止循环，正确地检测指针是否越界需要一点技巧，一个常见的错误是没有考虑到数组中可能包含和切分元素的值相同的其他元素。</li>
<li>处理切分元素值有重复的情况。<a href="http://www.cnblogs.com/gnuhpc/archive/2012/12/21/2828166.html" target="_blank" rel="noopener"><strong>荷兰国旗问题</strong></a></li>
</ol>
<h1 id="性能特点与改进"><a href="#性能特点与改进" class="headerlink" title="性能特点与改进"></a>性能特点与改进</h1><hr>
<p>标准的快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较，几乎没有比这更短小的内循环了。归并排序和希尔排序都比快速排序慢，其原因就是它们还在内循环中移动数据。另外，快速排序的比较次数很少。</p>
<p>改进快速排序可以基于以下两点：</p>
<ul>
<li>对于小数组，快速排序比插入排序慢。</li>
<li>因为递归，快速排序的 sort() 方法在小数组中也会调用自己。</li>
</ul>
<p>可以将 sort() 中的语句：<br>if (hi &lt;= lo) return;<br>替换成下面这条语句来对小数组使用插入排序。<br>if (hi &lt;= lo + M) { Insertion.sort(a, lo, hi); return; }<br>参数 M 可以选择 5 ~ 15 之间的任意值。</p>
<h1 id="三向切分法"><a href="#三向切分法" class="headerlink" title="三向切分法"></a>三向切分法</h1><hr>
<ol>
<li>将数组切分为三部分</li>
<li>维护一个指针 lt ，使得 <strong>a[lo..lt-1]</strong> 都小于 v</li>
<li>维护一个指针 gt，使得 <strong>a[gt+1..hi]</strong> 都大于 v</li>
<li><strong>a[lt..i-1]</strong> 等于 v</li>
<li><strong>a[i..gt]</strong> 中的元素都还未确定</li>
</ol>
<p>图如下：</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/QuickSort/3-way%20partitioning%20overview.png" alt=""></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exch(a, i++, lt++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            exch(a, i, gt--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 现在 a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]成立</span></span><br><span class="line">    sort(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">    sort(a, gt + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>a[i] 小于 v，将 a[lt] 和 a[i] 交换，将 lt 和 i 加一。</li>
<li>a[i] 大于 v，将 a[gt] 和 a[i] 交换，将 gt 加一。</li>
<li>a[i] 等于 v，将 i 加一。</li>
</ul>
<p>这样会保证数组元素不变且缩小 gt-i 的值，循环才能结束。与切分元素不相等的元素都会被交换。</p>
<p>三项切分的轨迹图</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/QuickSort/3-way%20partitioning%20trace.png" alt=""></p>
<h1 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h1><hr>
<h2 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h2><p>如果每次选择的切分元素正好是最小或最大的元素，或者在所有元素相等时，就会发生这种情况。这样每次递归调用都会处理一个比先前数组小一个的子数组，那么处理大小为 N 的数组就需要进行 <strong>N-1</strong> 次嵌套调用，这意味着需要 <strong><em>O(n<sup>2</sup>)</em></strong>。 这与插入排序和选择排序是相同的关系式。</p>
<h2 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h2><p>把递归调用看做一棵二叉树，如果每次切分，都将数组分成两个几乎相等的部分，那么只需要 <em>log<sub>x</sub>n</em> 次递归调用就可以完成排序，这意味着调用树的深度为 <em>log<sub>2</sub>n</em>，在同一层次的两个递归调用中，不会处理到原来数列的相同部分，因此程序调用的每一层总共全部仅需要 <em>O(n)</em> 的时间。结果是这个算法仅需使用 <strong><em>O(nlogn)</em></strong> 时间。</p>
<h2 id="平均情况"><a href="#平均情况" class="headerlink" title="平均情况"></a>平均情况</h2><p>对于输入顺序所有排列情形的平均比较次数，可以借由解出这个递归关系式。</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/QuickSort/Average-case%20analysis.png" alt=""></p>
<p>也就是说，平均上快速排序所使用的比较次数，比最好情况大约坏 39%，它更接近最好情况，因此比其他算法更快更有优势。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>快速排序是原地排序，将长度为 N 的数组排序所需的时间和 NlgN 成正比，快速排序的内循环比大多数排序算法都要短小。</p>
<p>快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时，整个数组也就自然有序了。归并排序的递归调用发生在处理整个数组之前；快速排序的递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分为两半；在快速排序中，切分（patition）的位置取决于数组的内容。</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/04/android/android-processes-and-threads/</loc>
    <lastmod>2018-06-18T12:41:56.275Z</lastmod>
    <data>
        <display>
        <title>android 进程和线程记录</title>
        <pubTime>2018-05-04T08:43:56.000Z</pubTime>
      
         <content><h3 id="进程-Processes"><a href="#进程-Processes" class="headerlink" title="进程 (Processes)"></a>进程 (Processes)</h3><ol>
<li>manifest文件中有四大组件activity、service、receiver、provider, application 的范围是所有组件。</li>
<li>Android:process可以指定当前组件运行在哪个处理器核心上。</li>
<li>Android系统会在内存低或者继续大量内存提供给其他应用的时候关闭一个进程。在决定哪个进程需要被关闭的时候，系统会权衡应用对于用户来说的相对重要性，比如前台和可见进程一般是不会被关闭的，只有不可见的服务和缓存进程可能被关闭。</li>
</ol>
<a id="more"></a>
<h3 id="线程-Threads"><a href="#线程-Threads" class="headerlink" title="线程 (Threads)"></a>线程 (Threads)</h3><ol>
<li>一般而言，一个应用启动，系统会创建一个线程来执行这个程序，叫做main线程，也叫做UI线程（与android.widget和android.view包下的组件）。但这不是绝对的，主线程可能不是UI线程。</li>
<li><p>系统所有的组件都运行在同一个进程中。比如，当用户触摸一个按钮的时候，UI线程为这个按钮轮流地（因为onTouch事件会持续进行）dispatch触摸事件，当手指离开按钮的时候为按钮设置pressed状态，并且发送一个invalidate的请求到事件队列中，然后UI线程出列这个请求并且通知这个widget，需要它进行重绘。</p>
</li>
<li><p>如果UI线程因阻塞而超过5秒，就会出现“application not responding”（ANR）对话框。<br>Android单线程模型有两个简单的规则：</p>
<ol>
<li>不要阻塞UI线程</li>
<li>不要在UI线程以外访问UI toolkit。</li>
</ol>
</li>
</ol>
<h3 id="工作线程-Work-threads"><a href="#工作线程-Work-threads" class="headerlink" title="工作线程 (Work threads)"></a>工作线程 (Work threads)</h3><p>因为上述两个规则，Android也提供了几个帮助方法，这几个实现是线程安全的。同时也提供了两个帮助类。</p>
<ol>
<li>Activity.runOnUiThread(Runnable)</li>
<li>View.post(Runnable)</li>
<li>View.postDelayed(Runnable, long)<br>帮助类</li>
<li>Handler （处理来自UI线程的message）</li>
<li>AsyncTask （继承它）</li>
</ol>
<h3 id="线程安全的方法"><a href="#线程安全的方法" class="headerlink" title="线程安全的方法"></a>线程安全的方法</h3><p>方法可能会被多于一个的线程调用。所以必须是线程安全的方法。</p>
<ol>
<li>例如，一个绑定服务，它可能在主线程中运行，方法将在调用者所在的线程执行。也有可能从其他线程运行（这些线程来自线程池），这些RPC方法就可能在其他线程中被调用。</li>
<li>尽管ContentProvider和ContentResolver隐藏了进程间通信是如何管理的细节，但是ContentProvider的那些query(), insert(), delete(), update(), and getType()方法将会在ContentProvider的进程中执行，不是在UI线程。</li>
</ol>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>Android提供了两种通信机制，分别是interprocesses communication(IPC)和remote procedure calls(RPCs)。</p>
<p>具体来说，一个方法在activity或者android的其他组件中被调用，但是却在另一个进程中被执行，然后将结果返回给调用者所在的进程。这需要分解这个方法调用，并且数据是在操作系统能理解的等级，把这些信息从本地进程和地址空间传输到远程的进程和地址空间，然后在远程重新组装和调用，返回的结果按相反的方向传输回去。</p>
<h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><ol>
<li><p>它是一个介于Thread和Handler之间的帮助类，它不是通用的线程框架。</p>
</li>
<li><p>一个异步任务中定义了computation任务，它跑在一个后台线程，并且将允许结果公布在UI线程上。它<br>它有3个generic类型，Params、Progress、Result，并且有4个步骤，onPreExecute、doInBackground、onProgressUpdate、onPostExecute。</p>
</li>
<li><p>AsyncTask最好是用来处理一些短时间的操作（几秒钟），如果是要长时间操作，强烈建议使用java.util.concurrent包下的 Executor, ThreadPoolExecutor 和 FutureTask。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFilesTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">URL</span>, <span class="title">Integer</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">doInBackground</span><span class="params">(URL... urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = urls.length;</span><br><span class="line">        <span class="keyword">long</span> totalSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            totalSize += Downloader.downloadFile(urls[i]);</span><br><span class="line">            publishProgress((<span class="keyword">int</span>) ((i / (<span class="keyword">float</span>) count) * <span class="number">100</span>));</span><br><span class="line">            <span class="comment">// Escape early if cancel() is called</span></span><br><span class="line">            <span class="keyword">if</span> (isCancelled()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progress)</span> </span>&#123;</span><br><span class="line">        setProgressPercent(progress[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Long result)</span> </span>&#123;</span><br><span class="line">        showDialog(<span class="string">"Downloaded "</span> + result + <span class="string">" bytes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> DownloadFilesTask().execute(url1, url2, url3);</span><br></pre></td></tr></table></figure>
<p>3个泛型参数的意义：</p>
<ol>
<li>params，在执行前发送到 doInBackground 的参数，对应上面的url1, url2和url3。</li>
<li>Progress，任务执行的进度，对应上面的指定为Interger。</li>
<li>Result，doInBackground执行的结果。</li>
</ol>
<p>大部分情况下，执行没有任何类型的异步任务，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4个步骤的意义："><a href="#4个步骤的意义：" class="headerlink" title="4个步骤的意义："></a>4个步骤的意义：</h3><ol>
<li>onPreExecute，执行在UI线程，一般是前置设置，比如显示一个进度条。</li>
<li>doInBackground，在 onPreExecute 执行完立即被调用在后台线程，参数将传到这个方法，这一步必须返回执行结果，它将被传递到最后一步。在这一步中可以调用publishProgress(Progress)，每一次调用都会回调onProgressUpdate(Progress…)，除非它被取消执行了。</li>
<li>onProgressUpdate，当在 doInBackground 中调用 publishProgress 的时候被回调，但是回调的时刻是未知的，</li>
<li>onPostExecute，安全的访问UI线程，它将收到来自 doInBackground 递送(deliver)的结果。</li>
</ol>
<h3 id="取消异步任务"><a href="#取消异步任务" class="headerlink" title="取消异步任务"></a>取消异步任务</h3><p>cancel，直接调用后会导致 isCancelled 返回 true，onCancelled 将会代替onPostExecute 的调用。为了确保异步任务是否被取消，应该在 doInBackground中周期性地检查 isCancelled，如果可以，使用循环。</p>
<h3 id="线程规则"><a href="#线程规则" class="headerlink" title="线程规则"></a>线程规则</h3><ol>
<li>AsyncTask 必须在UI线程中加载(load)，这由JELLY_BEAN自动完成。</li>
<li>task 的实例必须在UI线程中创建。</li>
<li>execute(Params…) 必须在UI线程中调用。</li>
<li>不要手动调用上述4个步骤的方法。</li>
<li>这个 task 只能被执行一次，第二次执行会抛出异常。</li>
</ol>
<h3 id="内存可观测"><a href="#内存可观测" class="headerlink" title="内存可观测"></a>内存可观测</h3><p>AsyncTask 担保所有的回调都是同步的，以下2种情况在没有明确同步的情况下，是安全的。</p>
<ol>
<li>在 onPreExecute 或者构造器中设置成员，然后在 doInBackground 中使用它们。</li>
<li>在 doInBackground 中设置成员，在 onProgressUpdate 和 onPostExecute 中使用它们。</li>
</ol>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/11/algorithm/merge-sort/</loc>
    <lastmod>2018-06-18T12:41:56.274Z</lastmod>
    <data>
        <display>
        <title>深入浅出之归并排序</title>
        <pubTime>2018-05-11T05:39:41.000Z</pubTime>
      
         <content><p>二叉树基础知识：<br>高度是：对于任意节点 n, n 的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为 0.<br>深度是：对于任意节点 n, n 的深度从根到 n 的唯一路径长，根的深度为 0.</p>
<h2 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h2><p>归并是指将两个有序的数组归并成一个更大的有序数组，根据这个简单的操作，人们很快就发明了一种简单的递归排序算法，即归并排序。</p>
<p>思路：<strong>要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后再将结果归并起来。</strong></p>
<p>分治思想：<strong>我们将一个大问题分割成小问题分别解决，然后用所有的小问题的答案来解决整个大问题。</strong></p>
<p>归并排序最突出的特点就是，<strong>它能够保证将任意长度为 N 的数组排序所需时间和 NlogN 成正比，它的主要缺点则是它所需的额外空间和 N 成正比。</strong></p>
<p><img src="http://p748dqat4.bkt.clouddn.com/Mergesort%20overview.png" alt=""></p>
<a id="more"></a>
<h2 id="原地归并的抽象方法-Abstract-in-place-merge"><a href="#原地归并的抽象方法-Abstract-in-place-merge" class="headerlink" title="原地归并的抽象方法 (Abstract in-place merge)"></a>原地归并的抽象方法 (Abstract in-place merge)</h2><p><strong>原地归并</strong>（in-place）是指将数组的前半部分排序，再将后半部分排序，在数组中移动元素而不需要额外的空间。也就是 <strong>merge(a, lo, mid, hi)</strong>，它会将子数组 <strong>a[lo..mid]</strong> 和 <strong>a[mid+1, hi]</strong> 归并成一个有序的数组并将结果存放在 <strong>a[lo..hi]</strong> 中。下面的代码实现了这种归并，它将所有的元素复制到一个辅助数组中，再把归并的结果放回原数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原地归并的抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>; <span class="comment">// 将 a[lo..mid] 和 a[mid+1..hi]归并</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123; <span class="comment">// 将 a[lo..hi] 复制到 aux[lo..hi]</span></span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123; <span class="comment">// 归并回 a[lo..hi]</span></span><br><span class="line">        <span class="keyword">if</span>      (i &gt; mid)               a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)                a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))  a[k] = aux[j++]; <span class="comment">// for 循环最多访问 2N + 2N 次数组</span></span><br><span class="line">        <span class="keyword">else</span>                            a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://p748dqat4.bkt.clouddn.com/Abstract%20in-place%20merge%20trace.png" alt=""></p>
<h2 id="自顶向下——递归法-Top-down-mergesort"><a href="#自顶向下——递归法-Top-down-mergesort" class="headerlink" title="自顶向下——递归法 (Top-down mergesort)"></a>自顶向下——递归法 (Top-down mergesort)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自顶向下的归并排序：分治思想</span></span><br><span class="line"><span class="comment"> * 要对子数组 a[lo..hi] 进行排序，先将它分为 a[lo..mid] 和 a[mid+1..hi] 两部分，</span></span><br><span class="line"><span class="comment"> * 分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组 a[lo..hi] 排序</span></span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    sort(a, lo, mid);</span><br><span class="line">    sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">    merge(a, lo, mid, hi); <span class="comment">// 最多 6N 次访问数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://p748dqat4.bkt.clouddn.com/Trace%20of%20merge%20results%20for%20top-down%20mergesort.png" alt=""></p>
<p>假设这棵树有 n 层，对于 0 到 n-1 之间的任意 k，自顶向下的第 k 层有 2^k 个子数组，每个数组的长度为 2^(n-k) ，归并最多需要 2^(n-k) 次比较。因此每层的比较次数为 2^k <em> 2^(n-k) = 2^n，n 层总共 n</em>2^n = NlgN。</p>
<p><img src="http://p748dqat4.bkt.clouddn.com/Mergesort%20sybarray%20dependence%20tree%20for%20N%20=%2016.png" alt=""></p>
<blockquote>
<p>对于长度为 N 的任意数组，自顶向下的归并排序最多需要访问数组 6NlgN 次。</p>
<p>每次归并排序最多需要访问数组 6N 次，其中 2N 用来复制，2N 次用来将排好序的元素移动回去，另外最多比较 2N 次。</p>
</blockquote>
<p>优化：</p>
<ul>
<li><p>对小规模子数组使用插入排序。因为插入排序非常简单，在小数组上很可能比归并排序更快。</p>
</li>
<li><p>数组有序则跳过 merge() 方法。<br>如果 a[mid] 小于等于 a[mid+1]，那么就认为数组已经是有序的并跳过 merge() 方法。</p>
</li>
<li>不将元素复制到辅助数组。</li>
</ul>
<h2 id="自底向上——迭代法-Bottom-up-mergesort"><a href="#自底向上——迭代法-Bottom-up-mergesort" class="headerlink" title="自底向上——迭代法 (Bottom-up mergesort)"></a>自底向上——迭代法 (Bottom-up mergesort)</h2><p>与自顶向下的分治（divide-and-conquer）思想不同，自底向上的思想是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。这种方法比标准递归方法所需要的代码量更少。假设数组的大小不是 N = 2^k+n，如果其中 n 为 0 ，那么最后一个子数组的大小就等于 sz，不然就会比 sz 小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">    <span class="comment">// 最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz，否则会比 sz 小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz + sz) &#123; <span class="comment">// sz 子数组大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - sz; lo += sz + sz) &#123; <span class="comment">// lo: 子数组索引</span></span><br><span class="line">        	merge(a, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://p748dqat4.bkt.clouddn.com/Visual%20trace%20of%20bottom-up%20mergesort.png" alt=""></p>
<p><img src="http://p748dqat4.bkt.clouddn.com/Trace%20of%20merge%20results%20for%20bottom-up%20mergesort.png" alt=""></p>
<blockquote>
<p>设有两个有序数组 arr1 与 arr2，数组长度分别为 m 与 n， 要合并成一个长度位 m+n 的有序数组 arr3，arr3 的长度即 N。</p>
<p>最差情况下：比较次数为 m+n-1<br>将 arr1 和 arr2 中的数组两两比较，最后一次比较是两个数组中的最后一个数进行比较。相当于需要比较 N 次。</p>
<p>最好情况下：比较次数为 min{m, n}<br>假设 arr1 中的每个数都比 arr2 中的小，那么比较的次数就是 arr1 的数组长度。相当于 N/2。</p>
<p>对于长度为 N 的任意数组，自底向上的归并排序需要 1/2NlgN 至 NlgN 次比较。自多访问数组 6NlgN 次。</p>
<p>因为处理一个数组的遍数正好是 ⎡lgN⎤（即 2^n ≤ N &lt; 2^(n+1) 中的 n），每一遍会访问数组 6N 次，比较次数在 N/2 和 N 之间。</p>
</blockquote>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/05/algorithm/print-list-from-tail-to-head/</loc>
    <lastmod>2018-06-18T12:41:56.273Z</lastmod>
    <data>
        <display>
        <title>从尾到头打印链表</title>
        <pubTime>2018-05-05T09:18:02.000Z</pubTime>
      
         <content><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>输入一个链表，从尾到头打印链表每个节点的值。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行时间：26ms</span></span><br><span class="line"><span class="comment"> * 占用内存：9320k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    ListNode pNode = listNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(listNode.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行时间：20ms</span></span><br><span class="line"><span class="comment"> * 占用内存：8708k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead2</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; revLists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        revLists.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> revLists;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行时间：30ms</span></span><br><span class="line"><span class="comment"> * 占用内存：9296k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead1</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; revLists = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lists.add(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lists.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        System.out.println(lists.get(i));</span><br><span class="line">        revLists.add(lists.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> revLists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/10/algorithm/bag-queue-stack/</loc>
    <lastmod>2018-06-18T12:41:56.272Z</lastmod>
    <data>
        <display>
        <title>背包，队列和栈问题</title>
        <pubTime>2018-05-10T05:53:21.000Z</pubTime>
      
         <content><h3 id="问：早期的-Java-版本是不支持泛型的，也不是所有编程语言都支持泛型，有什么代替方案吗？"><a href="#问：早期的-Java-版本是不支持泛型的，也不是所有编程语言都支持泛型，有什么代替方案吗？" class="headerlink" title="问：早期的 Java 版本是不支持泛型的，也不是所有编程语言都支持泛型，有什么代替方案吗？"></a>问：早期的 Java 版本是不支持泛型的，也不是所有编程语言都支持泛型，有什么代替方案吗？</h3><p>一种方案是构造一个 Object 的数组，每次使用 pop 的时候将得到的对象转换为所需的数据类型，但这种方式的问题在于类型不匹配错误只能在运行时发现。另一种方案就是泛型，能够在编译时发现错误。</p>
<a id="more"></a>
<h3 id="问：为什么-Java-不允许泛型数组？"><a href="#问：为什么-Java-不允许泛型数组？" class="headerlink" title="问：为什么 Java 不允许泛型数组？"></a>问：为什么 Java 不允许泛型数组？</h3><hr>
<h3 id="问：什么是公变数组（convariant-array）和类型擦除（type-erasure）？"><a href="#问：什么是公变数组（convariant-array）和类型擦除（type-erasure）？" class="headerlink" title="问：什么是公变数组（convariant array）和类型擦除（type erasure）？"></a>问：什么是公变数组（convariant array）和类型擦除（type erasure）？</h3><p>   <strong>数组的协变性</strong>，如果类 Base 是类 Sub 的基类，那么 Base[] 就是 Sub[] 的基类，也就是在要求 Base[] 的地方安全可以传递或者赋予 Sub[]。<br>   泛型是不可变的（invariant），List<base> 不会是 List<sub> 的基类，更不会是它的子类。</sub></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = <span class="keyword">new</span> String[<span class="number">10</span>]; </span><br><span class="line">array[<span class="number">0</span>] = <span class="number">10</span>;  <span class="comment">// 编译通过，运行时报 ArrayStoreException，在这步就不让赋值，免得后续取出值的时候再出错</span></span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();   </span><br><span class="line">list.add(<span class="number">10</span>);   <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>数组是具体化</strong>（reified）的，而泛型在运行时是被擦除的（erasure）。</p>
<p>​    数组是在运行时才去判断数组元素的类型约束。</p>
<p>​    而泛型刚好相反，在运行时泛型的类型信息是会被擦除的，只有编译的时候才会对类型进行强化。</p>
<p>​    <strong>泛型不是协变的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">List&lt;Number&gt; ln = li; <span class="comment">// illegal  </span></span><br><span class="line">ln.add(<span class="keyword">new</span> Float(<span class="number">3.1415</span>));  <span class="comment">// 如果上面这步允许通过，那么给 List&lt;Number&gt; 赋值 float 类型是理所应当的</span></span><br></pre></td></tr></table></figure>
<p>如果 Ln 是 List<number>类型，向其中添加 Float 类型安全合法，但是如果 List<integer>能赋值给 List<number> 的话，那么就破坏了定义在 li 中的类型安全承诺，因为它是一个整形列表。</number></integer></number></p>
<hr>
<h3 id="问：List-lt-gt-和-List-的区别？"><a href="#问：List-lt-gt-和-List-的区别？" class="headerlink" title="问：List&lt;?&gt; 和 List 的区别？"></a>问：List&lt;?&gt; 和 List<t> 的区别？</t></h3><p><t> 声明泛型类的类型参数。</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(List&lt;T&gt; t)</span> </span>&#123;item = t;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fruit 类里有三个地方出现了List<t>：</t></p>
<ol>
<li>成员字段item的类型</li>
<li>get( )方法的返回值</li>
<li>set( )方法的参数</li>
</ol>
<p><t> 声明泛型方法。</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">reduce</span><span class="params">(List&lt;T&gt; items)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;?&gt; 使用泛型类或泛型方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;?&gt; set(List&lt;?&gt; items) &#123;</span><br><span class="line">    List&lt;?&gt; list = items;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List&lt;?&gt; 的各种坑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// argument mismatch; String cannot be converted to CAP#1</span></span><br><span class="line"><span class="comment">// argument mismatch; int cannot be converted to CAP#1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="问：-lt-extends-T-gt-和-lt-super-T-gt-的区别？"><a href="#问：-lt-extends-T-gt-和-lt-super-T-gt-的区别？" class="headerlink" title="问：&lt;? extends T&gt; 和 &lt;? super T&gt; 的区别？"></a>问：&lt;? extends T&gt; 和 &lt;? super T&gt; 的区别？</h3><p>&lt;? extends T&gt; 是指“上界通配符（Upper Bounds Wildcards）”</p>
<p>&lt;? super T&gt; 是指“下界通配符（Lower Bounds Wildcards）”</p>
<p><strong>上界&lt;? extends T&gt;不能往里存，只能往外取</strong>，因为不知道具体的子类类型是什么，所以不能往里存，但可以往外指定基类类型进行取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple()); <span class="comment">// ”装苹果的盘子“无法转换成”装水果的盘子“。</span></span><br><span class="line">Plate&lt;? extends Fruit&gt; p = <span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple()); <span class="comment">// 看到Plate&lt;Apple&gt;，标上了一个占位符： CAP#1，来表示捕获一个 Fruit 或 Fruit 的子类，具体是什么不知道，代号 CAP#1。编译器不知道往里面插入的 Apple 或者 Fruit 能不能和这个 CAP#1 匹配，所以都不允许。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能存入任何元素</span></span><br><span class="line">p.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">p.set(<span class="keyword">new</span> Apple());</span><br><span class="line"></span><br><span class="line">Fruit newFruit1 = p.get();</span><br><span class="line">Object newFruit2 = p.get();</span><br><span class="line">Apple newFruit3 = p.get(); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p><strong>下界&lt;? super T&gt;不影响往里存，但往外取只能放在 Object 对象里</strong>，因为类型是向上的基类，所以不影响具体子类往里存，但会因具体的子类的信息在存为基类类型的时候被擦除，所以取出来的时候只能是 Object 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="keyword">super</span> Fruit&gt; p = <span class="keyword">new</span> Plate&lt;Fruit&gt;(<span class="keyword">new</span> Fruit()); <span class="comment">// 下界实际上是放松了类型控制，既然元素是 Fruit 的基类，那么往里存粒度比 Fruit 小的都可以。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常存入元素</span></span><br><span class="line">p.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">p.set(<span class="keyword">new</span> Apple());</span><br><span class="line"></span><br><span class="line">Fruit newFruit1 = p.get(); <span class="comment">// Error</span></span><br><span class="line">Apple newFruit3 = p.get(); <span class="comment">// Error</span></span><br><span class="line">Object newFruit2 = p.get(); <span class="comment">// 只能放在 Object 里</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="问：PECS（Producer-Extends-Consumer-Super）原则"><a href="#问：PECS（Producer-Extends-Consumer-Super）原则" class="headerlink" title="问：PECS（Producer Extends Consumer Super）原则"></a>问：<strong>PECS（Producer Extends Consumer Super）</strong>原则</h3><ol>
<li><strong>频繁往外读取内容的，适合用上界Extends。</strong></li>
<li><strong>经常往里插入的，适合用下界Super。</strong></li>
</ol>
<h3 id="问：为什么将-Node-设置为嵌套类？为什么使用private？"><a href="#问：为什么将-Node-设置为嵌套类？为什么使用private？" class="headerlink" title="问：为什么将 Node 设置为嵌套类？为什么使用private？"></a>问：为什么将 Node 设置为嵌套类？为什么使用private？</h3><p>  私有嵌套类的是只有包含它的类能够直接访问它的实例变量。另外，非静态的嵌套类也被称为内部类，因此从技术上来说 Node 类也是内部类。</p>
<h3 id="问：当我输入-javac-Stack-java-编译-java-文件的时候，会生成-Stack-class-和-Stack-Node-class-，第二个文件是做什么用的？"><a href="#问：当我输入-javac-Stack-java-编译-java-文件的时候，会生成-Stack-class-和-Stack-Node-class-，第二个文件是做什么用的？" class="headerlink" title="问：当我输入 javac Stack.java 编译 java 文件的时候，会生成 Stack.class 和 Stack$Node.class ，第二个文件是做什么用的？"></a>问：当我输入 javac Stack.java 编译 java 文件的时候，会生成 Stack.class 和 Stack$Node.class ，第二个文件是做什么用的？</h3><p>  第二个文件是内部类 Node 创建的，Java 的命名规则会使用 $ 分隔外部类和内部类。</p>
<h3 id="问：Java-标准库有栈和队列吗？"><a href="#问：Java-标准库有栈和队列吗？" class="headerlink" title="问：Java 标准库有栈和队列吗？"></a>问：Java 标准库有栈和队列吗？</h3><p>  有，但是不推荐使用，因为内置的库 java.util.Stack 新增了几个一般不属于栈的方法，是典型的<strong>宽接口</strong>例子。</p>
<h3 id="问：那么什么是宽接口呢？对应的是不是窄接口？"><a href="#问：那么什么是宽接口呢？对应的是不是窄接口？" class="headerlink" title="问：那么什么是宽接口呢？对应的是不是窄接口？"></a>问：那么什么是宽接口呢？对应的是不是窄接口？</h3><p>  <strong>宽接口</strong>通常能够让一个类功能强大，但有时容易失去真正的关注点从而破坏了”单一职责原则“。<strong>窄接口</strong>则比较容易确保对某一特定点的关注。</p>
<h3 id="问：是否允许用例向栈或队列中添加空（null）元素？"><a href="#问：是否允许用例向栈或队列中添加空（null）元素？" class="headerlink" title="问：是否允许用例向栈或队列中添加空（null）元素？"></a>问：是否允许用例向栈或队列中添加空（null）元素？</h3><p>  是允许的。</p>
<h3 id="问：如果用例在迭代中调用-push-或者-pop-，Stack-的迭代器应该怎么办？"><a href="#问：如果用例在迭代中调用-push-或者-pop-，Stack-的迭代器应该怎么办？" class="headerlink" title="问：如果用例在迭代中调用 push() 或者 pop() ，Stack 的迭代器应该怎么办？"></a>问：如果用例在迭代中调用 push() 或者 pop() ，Stack 的迭代器应该怎么办？</h3><p>  作为一个快速出错的迭代器，它应该立即抛出一个 java.util.ConcurrentModificationException 异常。</p>
<h3 id="问：我们能够用-foreach-循环访问数组吗？"><a href="#问：我们能够用-foreach-循环访问数组吗？" class="headerlink" title="问：我们能够用 foreach 循环访问数组吗？"></a>问：我们能够用 foreach 循环访问数组吗？</h3><p>  可以，尽管数组没有实现 Iterable 接口。</p>
<h3 id="问：我们能够用-foreach-循环访问字符串吗？"><a href="#问：我们能够用-foreach-循环访问字符串吗？" class="headerlink" title="问：我们能够用 foreach 循环访问字符串吗？"></a>问：我们能够用 foreach 循环访问字符串吗？</h3><p>  不行，String 没有实现 Iterable 接口。</p>
<p>  ​</p>
<p>  ​</p>
</content>

         
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.iweeek.com/2018/05/15/algorithm/DutchNationalProblem/</loc>
    <lastmod>2018-06-18T12:41:56.271Z</lastmod>
    <data>
        <display>
        <title>荷兰国旗问题</title>
        <pubTime>2018-05-15T13:47:54.000Z</pubTime>
      
         <content><p>问题描述：现有n个红白蓝三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，使得从左至右，依次是一些红球、一些白球、一些蓝球。</p>
<p>分析：根据<a href="http://www.iweeek.com/2018/05/15/quick-sort/#%E4%B8%89%E5%90%91%E5%88%87%E5%88%86%E6%B3%95">三向切分快速排序</a>中的 partition 的思路，将整个数组分成三个部分，对应三种颜色。维护三个指针，一个指针 lt ，使得 <strong>a[lo..lt-1]</strong> 都小于 v，维护一个指针 gt，使得 <strong>a[gt+1..hi]</strong> 都大于 v，<strong>a[i..gt]</strong> 中的元素都还未确定。</p>
<p>但是这个问题比较简单，数组的元素只有三种情况，只需要分别列出来。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lt = lo, i = lo, gt = hi + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            exch(a, lt++, i++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            exch(a, --gt, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></content>

         
        </display>
    </data>
    </url>

    
    
    
    
    
    
    
    
    
  <url>
    <loc>http://www.iweeek.com/drafts/iframe.html</loc>
    <lastmod>2018-06-11T02:58:23.333Z</lastmod>
    <data>
        <display>
        <title>hexo-theme-melody v1.5 supports slides & iframe</title>
        <pubTime>2018-03-06T11:57:52.000Z</pubTime>
      
         <content><h2 id="hexo-theme-melody-v1-5"><a href="#hexo-theme-melody-v1-5" class="headerlink" title="hexo-theme-melody v1.5"></a>hexo-theme-melody <small>v1.5</small></h2><!-- .slide: data-background="#49B1F5" -->
<p>Supports iframe &amp; slides. You can use a layout called <code>slides</code> to enabled the slides layout.</p>
<p>Also you can add a <code>iframe</code> front-matter with the <code>slides</code> layout in your <code>md</code> file to enable the iframe page.</p>
<p>===</p>
<h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><!-- .slide: data-transition="concave" data-background="#C7916B" -->
<h3 id="1-Add-a-slides-page"><a href="#1-Add-a-slides-page" class="headerlink" title="1. Add a slides page"></a>1. Add a slides page</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page slides</span><br><span class="line"><span class="built_in">cd</span> ./<span class="built_in">source</span>/slides</span><br></pre></td></tr></table></figure>
<p>===</p>
<h3 id="2-Add-the-layout-type"><a href="#2-Add-the-layout-type" class="headerlink" title="2. Add the layout type"></a>2. Add the layout type</h3><!-- .slide: data-transition="fade" data-background="#00C4B6" -->
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.md</span><br></pre></td></tr></table></figure>
<p>Add a type called <code>slides</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">slides</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-03</span><span class="bullet">-06</span> <span class="number">20</span><span class="string">:24:48</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">slides</span></span><br></pre></td></tr></table></figure>
<p>===</p>
<h3 id="3-Modified-the-melody-yml"><a href="#3-Modified-the-melody-yml" class="headerlink" title="3. Modified the melody.yml"></a>3. Modified the melody.yml</h3><!-- .slide: data-transition="convex" data-background="#1B9EF3" -->
<p>Add slides default config:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slide:</span></span><br><span class="line"><span class="attr">  separator:</span> <span class="string">whatever</span> <span class="string">you</span> <span class="string">like</span></span><br><span class="line"><span class="attr">  separator_vertical:</span> <span class="string">whatever</span> <span class="string">you</span> <span class="string">like</span></span><br><span class="line"><span class="attr">  charset:</span> <span class="string">utf-8</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">black</span></span><br><span class="line"><span class="attr">  mouseWheel:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  transition:</span> <span class="string">slide</span></span><br><span class="line"><span class="attr">  transitionSpeed:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  parallaxBackgroundImage:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  parallaxBackgroundSize:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  parallaxBackgroundHorizontal:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  parallaxBackgroundVertical:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>See reveal.js <a href="https://github.com/hakimel/reveal.js#configuration" target="_blank" rel="noopener">config</a></p>
</blockquote>
<p>===</p>
<h3 id="4-Write-a-md-file-with-slides-layout"><a href="#4-Write-a-md-file-with-slides-layout" class="headerlink" title="4. Write a md file with slides layout"></a>4. Write a md file with slides layout</h3><!-- .slide: data-transition="zoom" data-background="#F47466" -->
<p>In <code>_posts</code> folder, add a <code>md</code> file.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// balalala...</span><br></pre></td></tr></table></figure>
<p>Then you will get a post of slides type.</p>
<p>===</p>
<h2 id="Slides-layout-with-iframe"><a href="#Slides-layout-with-iframe" class="headerlink" title="Slides layout with iframe"></a>Slides layout with iframe</h2><p>If you want to add a website whatever you like within an iframe, try this:</p>
<p>In <code>_posts</code> folder, add a <code>md</code> file.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">iframe: https://the-url-whatever-you-like</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>Then you will get a post of iframe.</p>
<p>===</p>
<h2 id="Configurate-single-slides-in-md"><a href="#Configurate-single-slides-in-md" class="headerlink" title="Configurate single slides in md"></a>Configurate single slides in md</h2><!-- .slide: data-transition="convex" data-background="#69C282" -->
<p>The slides config in <code>meldoy.yml</code> can change whole slides page.</p>
<p>But if you set the config in the md file, it will effect the single page.</p>
<p>==</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">slide:</span><br><span class="line">  theme: white</span><br><span class="line">  transition: zoom</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// balalala...</span><br></pre></td></tr></table></figure>
<p>===</p>
<h1 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy!"></a>Enjoy!</h1><!-- .slide: data-background="#49B1F5" -->
</content>

         
        </display>
    </data>
    </url>

    
    
    
</urlset>